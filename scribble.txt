/* Set up your elemental and default items */
var elemental_items = [
  ["hammer", 
    ["aether", "D"],
    ["poison", "D"],
    ["ice", "D"],
  ],
  ["wand", 
    ["fire", "D"],
    ["poison", "D"],
    ["vigor", "D", "dL"],
  ],
  ["sword", 
    ["aether", "D"],
    ["fire", "dF"],
    ["ice", "dI"],
    ["poison", "dP", "D"],
    ["vigor", "dL"],
    ["default", "sword + 5", "sword + 7"],
  ],
  ["shield", 
    ["vigor", "ah", "A"],
    ["poison", "A"],
    ["ice", "A"],
    ["aether", "A"],
    ["default", "vigor shield ah"],
  ],
]
/* These non-elemental items can be used as 
weapon types in the lists below. */
var special_weapons = ["bardiche", "blade", 
"heavy hammer", "repeater", "arm"]

/* By default script prefers to use melee, and
only uses ranged for scripted bosses, against
specific enemies like mosquitoes and wasps.
What script considers when selecting a weapon:
1. Match foe's weak element.
2. Use hammers or heavy hammer if foe has armor.
3. Use single-target or AoE weapons based on
   `foe.count`.
4. If you're on low HP, uses lifesteal and heal
   weapons/shields.
5. If it's a boss, or if you have Smite buff,
   debuffs the enemy.
Settings below can change this logic. */

/* Weapon type priority for single targets:
1. First type + foe's weak element.
2. Default weapon of the first type.
3. Second type + foe's weak element.
4. Etc. 
If a weapon type isn't listed here, it will not
ever be used. */
var for_melee_single_target = [
  "sword", "big sword", "hammer",
]

/* How many regular enemies are needed to start 
using AoE weapons instead of single target. */
var aoe_treshold = 4

/* Weapons to use for melee AoE, same priority 
logic as the regular melee. */
var for_melee_aoe = [
  "bardiche", "heavy hammer", "big sword",
]

/* If this is set to `true`, script will prefer
to use ranged items from lists below instead of
melee. */
var prefer_ranged = false

/* Used for scripted bosses, some special foes
like ants and mosquitoes, or when 
`prefer_ranged` is true. */
var for_ranged_single_target = [
  "repeating", "wand", "staff", "crossbow",
]

/* Weapons to use for ranged AoE. Ranged AoE is
triggered by the same threshold as melee AoE. */
var for_aoe_ranged = [
  "wand", "staff", "crossbow", "repeating",
]

/* Weapons to use against `immune_to_physical`
enemies. */
var for_phys_immune = ["wand", "staff"]

/* Full name of the shield with the highest
evade%, will be used to block big boss attacks*/
var evade_shield = "vigor ah"

/* Fraction of HP to consider low. When on low 
HP, will prioritize `ah` shield and `dL` weapon 
over foe's elemental weakness.
If 1, will always try to lifesteal to max.
If -1, will never force lifesteal. */
var low_hp_threshold = 0.5

// Switch to 1h + shield when `low_hp_threshold`
var use_shield_on_low_hp = true

/* if true, will debuff even regular enemies
when you have the Smite buff active. */
var debuff_on_smite = true

// Depends on level/enchants of the Blade.
var smite_damage = 85

/* At least this many enemies must be present
to use Smite. */
var smite_treshold = 7

/* If item is not listed here, its `R` ability
won't be used. Supported: dash, bash, 
bardiche, hammer, blade, skeleton_arm, mask,
quarterstaff. */
var useable_abilities = ["dash", "bash", 
"skeleton_arm", "mask", "blade", "hammer", 
"bardiche", "quarterstaff"]

// Choose amount based on your `dI` weapon
var max_chill_stacks = 6

/* Blade of the Fallen God quests.
"bolesh" to kill him with the blade,
"variety" for killing unique enemies */
var bfg_quest = false

/* If you're on the "variety" step of the BFG
quest, fill this array with names of the
enemies you've already defeated. */
var bfg_defeated_foes = ["ant", "mosquito"]

/* Set to true if you're doing Skeleton Arm
quests. Prioritizes last-hitting foes with the 
Arm ability */
var pickpocket_quest = false

// These depend on level/enchants of the Arm
var arm_damage = 32
var max_pickpocket_stacks = 2

/* Cultist Mask quests.
"simple" - steps 1 and 3 (uses on CD)
"prevent" - step 4: do it in Rocky. Script
will approach the scout, use mask, get hit as
long as the debuff lasts, and quit the zone. */
var mask_quest = "prevent"

// Show ability cooldowns in UI
var ui_show_cd = true

// Show your buffs/debuffs in UI
var ui_show_statuses = true

// Show debug info (noisy, useful for research)
var ui_show_debug = true

/*********************
**     #Progress    **
*********************/
func progress()
  ?healwalk() // no enemies nearby
    return true
  ?foe = explode
    return avoid_explosion()
  ?!is_boss & !at_boss
    /* Add your non-boss zone logic here */
    free_mind = true
    return fight()
  stance = "boss combat"
  // enable_hit_tracking = true
  ?loc = rocky
    ?foe.id = "acronian_scout"
      return fight_scout()
    return fight_dysan()
  :?loc = deadwood
    return fight_xyloalgia()
  :?loc = caves
    ?foe.id = "cool_bat" // ceiling decorator
      return auto_melee_miniboss()
    return fight_bolesh()
  :?loc = fungus_forest_boss
    return fight_mushrooms()
  :?loc = mushroom
    ?foe.id = "epic_snail"
      return auto_melee_miniboss()
  :?loc = undead_crypt_boss
    return fight_pallas()
  :?loc = bronze_guardian
    return fight_bronze_guardian()
  :?loc = icy_ridge
    return fight_hrimnir()
  :?loc = nagaraja
    return fight_nagaraja()
  :
    dbg("Fighting unknown boss")
    auto_melee_boss()

func idle()
  ?pickup.distance < 9
    return equip_L("star") & equip_R("trisk")
  :?can_qs_dash()
    return qs_dash()
  stance = "idle"
  found = auto_equip_R("shield", false)
  ?!found
    return equip_L("ouroboros") & 
    ^equip_R("trisk")
  ?hp < maxhp
    return equip_L("ouroboros")
  return equip_L("trisk")

func healwalk()
  stance = "healwalk"
  ?foe & (foe_dist < 23)
    ?hp < (maxhp / 4) & item.potion ! empty &
    ^(item.potion = "healing" | 
    ^item.potion = "vampiric")
      activate potion
    return false // start combat instead
  return idle()

func avoid_explosion()
  stance = "avoiding explosion"
  ?foe_dist < 5
    disable_r("any_dash")
    return try_evade()
  return melee("def")

/********************
**     #Combat    **
********************/
func fight()
  ?phys_immune | foe = magic_vulnerability
    return auto_elemental()
  :?must_melee_foe()
    return auto_melee()
  :?must_ranged_foe()&foe_dist > melee_aoe_range
    return auto_ranged()
  :?prefer_ranged
    ?foe_dist < 8
      ?can_backflip()
        return backflip()
      return auto_melee()
    return auto_ranged()
  :
    return auto_melee()

func auto_melee()
  ?use_abilities()
    return true
  :?can_aoe & eff_dist <= melee_aoe_range
    return melee("aoe")
  :?low_hp & use_shield_on_low_hp
    return melee("def")
  :
    return melee("dps")

// mode: "dps" | "def" | "aoe"
func melee(mode)
  ?come_closer()
    return true
  ?mode = "dps"
    stance = "melee dps"
    auto_equip("melee", false)
  :?mode = "aoe"
    stance = "melee aoe"
    auto_equip("melee", true)
  ?mode = "def" | 
  ^eff_dist > get(weapon_ranges, _equip_L_type)
    stance = "melee def"
    found = auto_equip_L("melee", false)
    ?!is_2hander(_equip_L_type)
      found = auto_equip_R("shield", false)
      ?!found
        auto_equip_R("melee", false)
  ?low_hp
    stance = "low_hp " + stance

func come_closer()
  ?can_dash()
    return dash()
  :?should_qs_dash()
    return qs_dash()
  return false  

func auto_ranged()
  ?use_abilities()
    return true
  :?can_aoe & for_aoe_ranged.Count() > 0 & 
  ^eff_dist <= ranged_aoe_range
    return ranged_aoe()
  :?for_ranged_single_target.Count() > 0
    return ranged()
  :
    return auto_melee()

func ranged()
  stance = "ranged"
  ?low_hp
    stance = "low_hp ranged"
  return auto_equip("ranged", false)

func ranged_aoe()
  stance = "ranged aoe"
  ?low_hp
    stance = "low_hp ranged aoe"
  return auto_equip("ranged", true)

func auto_elemental()
  ?use_abilities()
    return true
  :?elemental()
    return true
  :
    return auto_ranged()

func elemental()
  stance = "magic"
  ?auto_equip("magic", true)
    return true
  return false

func can_dash()
  return (can_use("dash") | can_use("bash"))
  ^& eff_dist > 10 & eff_dist < 17 &
  ^can_activate()

func dash()
  ?can_use("bash")
    stance = "bashing"
    return equip_R("bashing")
  :?can_use("dash")
    stance = "dashing"
    return equip_R("dashing")
  return false

var ranged_foes = ["mosquito", "huge_mosquito",
"wasp", "ant"]
func must_ranged_foe()
  return ranged_foes.Contains(foe.id) 

func must_melee_foe()
  return foe = immune_to_ranged | foe = ranged | 
  ^foe.id = "cult_guard" // poisons on being hit

func auto_melee_boss()
  auto_melee()
  stance = "boss " + stance

func auto_melee_miniboss()
  disable_r("blade")
  disable_r("mask")
  auto_melee()
  stance = "miniboss " + stance

/**********************
** #Weapon switching **
**********************/

var _equip_L = false
var _equip_L_type = false
func equip_L(it)
  // sets global flag, so the next `get_item()`
  // in this frame will not return the same item
  _equip_L = it
  ?is_2hander(it)
    _equip_L_type = it
  ?is_2hander(_equip_L_type)
    return aac(it)
  equipL @it@
  return it

var _equip_R = false
func equip_R(it)
  // for debug
  _equip_R = it
  equipR @it@
  return it

// range: "melee" | "ranged"
// aoe: true/false
func auto_equip_L(range, aoe)
  found = select_weapon(range, aoe)
  ?found
    _equip_L_type = found[1]
    return equip_L(found[0])
  return false

// range: "melee" | "ranged" | "shield"
// aoe: true/false
func auto_equip_R(range, aoe)
  ?range = "shield"
    found = false
    ?low_hp
      found = get_item("shield", "vigor", "mod")
    ?!found
      found = get_item("shield", _elem, purpose)
    ?!found
      found = get_item(ty, "default", "default")
    ?found
      return equip_R(found)
    return false
  found = select_weapon(range, aoe)
  ?found
    return equip_R(found[0])
  return false

// range: "melee" | "ranged"
// aoe: true/false
func auto_equip(range, aoe)
  found = select_weapon(range, aoe)
  ?!found
    return false
  equip_L(found[0])
  ?is_2hander(found[1])
    return found
  found = select_weapon(range, aoe)
  ?found
    return equip_R(found[0])
  return false

func is_2hander(ty)
  return _2h_types.Contains(ty)

func select_weapon(range, aoe)
  var types = select_types(range, aoe)
  var purpose = "stats"
  var debuff_elems = should_debuff()
  var elem
  ?debuff_elems
    ?_equip_L // one hand already with debuffer
      ?debuff_elems.Count() > 1
        purpose = "mod"
        elem = debuff_elems[1] // next debuff
      :
        elem = _elem // or foe weakness
    :
      purpose = "mod"
      elem = debuff_elems[0]
  :
    elem = _elem
  found = false
  for ty : types
    ?low_hp
      found = get_item(ty, "vigor", "mod")
    ?!found
      found = get_item(ty, elem, purpose)
    ?!found
      ?purpose = "mod"
        found = get_item(ty, elem, "stats")
    ?!found
      found = get_item(ty, "default", "default")
    ?found
      return [found, ty]
  return false

func select_types(aoe)
  var types = for_melee_single_target
  ?range = "melee"
    ?aoe
      types = for_melee_aoe
    ?foe.armor > 0
      ?aoe
        types = aa_aoe_types
      :
        types = aa_st_types
  :?range = "ranged"
    ?aoe
      types = for_aoe_ranged
    :
      types = for_ranged_single_target
  :?range = "magic"
    types = for_phys_immune
  return types

func get_item(ty, elem, purpose)
  var h
  ?elem = "default"
    h = hash([ty, "default"])
  :
    h = hash([ty, elem, purpose])
  var items = try_get(all_items, h)
  ?items = None | items.Count() = 0
    return false
  for it : items
    ?it ! _equip_L
      return it
  return false

/********************
**    #Abilities   **
********************/
func get_cd(ability)
  return get(cooldowns, ability)

func allowed(ability)
  return get(abilities, ability)

func edmg(dmg)
  return dmg - get(my_statuses, "damage_down")

func is_locked_by(tag)
  return lock & string.Equals(lock, tag)

func set_lock(tag, timer)
  ?!lock
    lock = tag
    lock_timer = timer

func clear_lock(tag)
  ?is_locked_by(tag)
    lock = false
    lock_timer = 0

func can_use(ability)
  ?!allowed(ability)
    return false
  ?lock
    return is_locked_by(ability)& lock_timer > 0
  return true

func can_qs_dash()
  return can_use("quarterstaff") & 
  ^can_activate()

func should_qs_dash()
  return (prefer_ranged & eff_dist > 28) |
  ^(eff_dist > 16 | 
  ^eff_dist < 11 & eff_dist > 5) & can_qs_dash()

func qs_dash()
  stance = "staff-dashing"
  equip_L("quarterstaff")
  ?item.CanActivate("quarterstaff")
    activate R
  return true

func can_backflip()
  return can_use("mind") & free_mind &
   // don't jump into the wall
  ^screen.FromWorldX(pos.x) > 5
  
func backflip()
  stance = "mind stone R"
  auto_equip_R("shield", false)
  return equip_L("mind")

func can_slap()
  return can_use("skeleton_arm") & 
  ^eff_dist < 7 & !phys_immune & can_activate()

func should_slap()
  return can_slap() & (!pickpocket_quest |
  ^foe_ehp <= edmg(arm_damage))

func slap()
  stance = "skeleton arm R"
  aac("arm")
  ?pickpocket_stacks >= max_pickpocket_stacks &
  ^item.CanActivate("skeleton_arm")
    activate R
  return true

func can_smite()
  return can_use("blade") & 
  ^eff_dist <= 20 & (foe ! pallas) &
  ^can_activate()

func should_smite()
  ?bfg_quest = "variety"
    ?foe_ehp<=edmg(smite_damage) & can_smite()
      for e : bfg_defeated_foes
        ?foe = e
          return false
      return true
    return false
  return (is_boss | foe.count >= smite_treshold
  ^& foe_ehp<=edmg(smite_damage)) & can_smite()

func smite()
  stance = "smite R"
  aac("blade")
  ?item.CanActivate("blade")
    activate R
  return true

func can_hammer()
  return can_use("hammer") & !phys_immune & 
  ^eff_dist <= 21 & can_activate()

func should_hammer()
  return foe.armor > 0 & 
  ^(is_boss | can_aoe & eff_dist < 10) & 
  ^can_hammer()

var hammer_frames = 15
func hammer()
  set_lock("hammer", hammer_frames)
  stance = "heavy hammer R"
  aac("heavy hammer")
  ?item.CanActivate("hammer")
    activate R
  return true

func can_bard()
  return can_use("bardiche") & eff_dist <= 9 & 
  ^!phys_immune & can_activate()

func should_bard()
  return is_boss & can_bard()

var bard_frames = 30
func bardiche()
  set_lock("bardiche", bard_frames)
  stance = "bardiche R"
  aac("bardiche")
  ?item.CanActivate("bardiche")
    activate R
  return true

func can_mask()
  return can_use("mask") &
  ^(foe ! nagaraja) & can_activate()

func should_mask()
  return (mask_quest = "simple" | 
  ^is_boss & eff_dist<=melee_range) & can_mask()

func mask()
  stance = "mask R"
  equip_R("mask")
  ?item.CanActivate("mask")
    activate R
  return true

func use_abilities()
  // prioritize quests
  ?string.Equals(mask_quest, "simple") &
  ^can_mask()
    return mask()
  ?pickpocket_quest & can_slap()
    return slap()
  // then use where needed
  ?should_hammer()
    return hammer()
  ?should_smite()
    return smite()
  ?should_bard()
    return bardiche()
  ?should_slap()
    return slap()
  // use mask right before debuffing
  ?should_mask()
    return mask()
  return false

func can_activate()
  return ai.enabled & item.CanActivate()

func aac(weapon)
  _equip_L = weapon
  equip @weapon@
  ?ai.idle
    ?lock & (is_locked_by("hammer") | 
    ^is_locked_by("bardiche"))
      return false
    equip wand
  equip @weapon@
  return weapon

/*****************
**    #Bosses   **
*****************/
  
func try_evade()
  ?can_mind
    return backflip()
  return shield_block()

func evade_at(t)
  ?foe_t = t
    return try_evade()
  ?foe_t < t & get_cd("mind") <= (t - foe_t)
    // abilities that would be interrupted
    ?foe_t > (t - bard_frames)
      disable_r("bardiche")
    ?foe_t > (t - hammer_frames)
      disable_r("hammer")
  return false

func shield_block()
  stance = "shield block"
  return equip_R(evade_shield)

func shield_block_and_halt()
  stance = "shield block and halt"
  return equip_L("quest")& equip_R(evade_shield)

func fight_scout()
  ?string.Equals(mask_quest, "prevent")
    equip_L("quest")
    ?foe_s = 32 & foe_t > 11 & can_mask()
      return mask()
    ?get_cd("mask") > 0 & 
    ^!foe_debuffs.Contains("debuff_feeble")
      return loc.Leave()
    ?have_dashing
      equip_R("dashing")
  :
    auto_melee_boss()    

func fight_dysan() // REDO
  disable_r("skeleton_arm")
  ?foe = phase1
    ?foe_s = 33 & foe_t = 24
      // block big attack
      return shield_block()
  :?foe = phase2
    auto_equip("melee", false)
  :?foe = phase3
    ?foe_s = 32 & foe_t > 90
      // prepare for attack
      return shield_block()
    :?foe_s = 115
      ?foe_t = 60
        // dodge the orb ray
        return backflip()
      :?foe_t < 80
        // don't dash into ray
        disable_r("any_dash")
    :?foe_s = 106 | foe_s = 108 |
    ^foe_s = 0
      return shield_block()
  auto_melee_boss()

func fight_xyloalgia()
  ?foe = phase1 // Xyloalgia
    return auto_melee_boss()
  // Poena
  disable_r("skeleton_arm")
  ?foe.buffs.string = "poena_mirror"
    return shield_block_and_halt() // :(
  :?foe_s = 32 & foe_t = 41
    return shield_block()
  auto_melee_boss()

func fight_bolesh()
  // Get close, debuff/use abilities, then
  // jump to ranged before the first melee bite,
  // and continue shooting and blocking.
  ?loc.stars > 5
    disable_r("skeleton_arm")
  ?foe_s = 133 & ((foe_t > 9 & foe_t < 12) | 
  ^(foe_t > 14 & foe_t < 17))
    // block bite and don't move from ranged
    return shield_block_and_halt()
  :?foe_s = 142 & foe_t = 60
    // evade melee bite
    return backflip()
  :?can_mind & 
  ^!(foe.buffs.string = "spider_buff_damage")
    return auto_melee_boss()
  :?bfg_quest & bfg_quest = "bolesh" & 
  ^(foe_ehp < edmg(smite_damage))
    ?eff_dist <= 11
      return equip_L(blade)
    return melee("def")
  :
    ranged()

func fight_mushrooms()
  disable_r("skeleton_arm")
  var chills = get(foe_debuffs, "debuff_chill")
  ?foe = phase1
    // thanks to user `fruloo` from the discord!
    big_swing = 47 + 7 * chills
    ?foe_s = 32 & evade_at(big_swing)
      return
    :?foe_s = 33 & foe_t = foe_dist + 4
      // pellets, V = 1 frame / sec
      return shield_block()
  :?foe = mushroom_boss_fat
    big_swing = 26 + 7 * chills
    ?foe_s = 32 & evade_at(big_swing)
      return
  auto_melee_boss()

func fight_pallas()
  disable_r("skeleton_arm")
  ?foe = phase1
    ?foe_s = 32 & foe_t = 68
      return shield_block()
    return auto_melee_boss()
  :?foe ! phase2
    return fight() // adds
  auto_melee_boss()

func fight_bronze_guardian()
  disable_r("skeleton_arm")
  ?foe_s = 32 & foe_t = 33 & armor < foe.damage
    return backflip() // dodge the hammer
  :?foe_s = 33 // hammer is down
    return auto_melee_boss()
  ranged()

func fight_hrimnir() // REDO
  at_boss = true
  ?is_boss & foe.armor > 0
    // initial ice block, don't debuff
    return auto_melee()
  :?loc.stars <= 5 // try to cheese
    ?foe_dist <= 2
      ?!use_abilities()
        return auto_melee() // don't debuff
    :?foe_dist <= 5
      // The shovel has an attack range of 1
      // so at white stars we can avoid
      // snowballs by getting close to boss.
      // on higher stars he blows you away
      // immediately
      equip_L("shovel")
    : // blown away, get back
      return auto_melee()
  :?foe_s = 143 | foe_s = 144 // blowing
    return ranged()
  :?foe.count > 1 // deal with adds
    ?can_smite()
      return smite()
    :?foe.count > 2
      ?can_hammer()
        return hammer()
      return elemental_aoe()
    :?eff_dist < 11
      return auto_melee()
    :?can_bard() & foe.id = ice_wall
      return bardiche()
    return auto_melee()
  :?slowed
    ranged()
  :
    auto_melee_boss()

func fight_nagaraja()
  // dodge poison balls & plink away
  disable_r("skeleton_arm")
  var x = screen.FromWorldX(pos.x)
  var y = screen.FromWorldZ(pos.z)
  ?is_poison_near(x, y)
    // dodge from ranged to melee
    ?foe_dist > 12
      ?can_qs_dash()
        return qs_dash()
      return ranged()
    :?foe_dist > melee_range
      return auto_melee_boss()
    :
      return try_evade()
  ?foe_s = 112 & foe_t = 59 & foe_dist < 10
    return try_evade()
  :?foe_dist > melee_range
    return ranged()
  return auto_melee_boss()

func is_poison_near(pos_x, pos_y)
  // long and mid range
  ?draw.GetSymbol(pos_x+2, pos_y-6) = "(" |
  // melee
  ^(draw.GetSymbol(pos_x+1, pos_y-6) = "(")
    return true
  return false

/*********************
**     #Internals   **
*********************/
var at_boss = false // to disable default fight
var big_swing = 0 // mushrooms
// player status
var stance = "unknown" // chosen combat stance
var low_hp = false // hp < (maxhp * threshold)
var can_aoe = false
var found = false
var _elem = "default"
// abilities
var lock = false
var lock_timer = false
var free_mind = false
// foe status
var foe_s = 0 // foe.state
var foe_t = 0 // foe.time
var foe_ehp = 0 // foe.armor + foe.hp
var foe_dist = 0 // foe_dist
var eff_dist = 0 // foe_dist + range_debuff
var is_boss = false // foe = boss
var phys_immune = false // immune to physical
// hit tracking
var enable_hit_tracking = false
var last_frame_dist = 0
var last_frame_armor = 0
var last_frame_hp = 0
var last_frame_foe = ""
var last_frame_dist = 0
var last_frame_state = -1
var last_frame_time = -1
var last_frame_stance = ""
var last_frame_debuffs = 
^"sl=false,st=false,d=false,r=false"

var elem_types = [
  "sword", "big sword", "wand", "shield", 
  "crossbow", "staff", "hammer",
]
var non_elem_types = ["bardiche", "arm","blade", 
"heavy hammer", "repeating", "quarterstaff"]
var _2h_types = ["bardiche", "arm", "blade", 
"heavy hammer", "repeating", "staff",
"quarterstaff", "shovel"]
var all_elems = [
  "aether", "fire", "ice", "poison", "vigor",
]
var aa_st_types = []
var aa_aoe_types = []
var all_items = [/*
hash, [weapon1, weapon2,], hash, [weapon3], ...
for example:
sword-aether-stats, [aether sword D],
hammer-fire-mod, [fire hammer dF],
wand-default, [stone wand + 10],
*/]
func _prepare_items()
   // [type, [elem, s1, sn], [elem2...]]
  for item_type : elemental_items
    ?item_type.Count() > 1
      // for each element
      for i = 1 .. item_type.Count() - 1
        var suffixes = item_type[i]
        ?suffixes.Count() > 1
          // suffixes: ["elem", "s1", "sn"]
          _categorize_item(ty, suffixes)
  for a : [
  ^[for_melee_single_target, aa_st_types],
  ^[for_melee_aoe, aa_aoe_types]]
    var source = a[0]
    var dest = a[1]
    ?source.Contains("heavy hammer")
      dest.Add("heavy hammer")
    ?source.Contains("hammer")
      dest.Add("hammer")
    for w : source
      ?w ! "hammer"
        dest.Add(w)

func _categorize_item(ty, suffixes)
  var elem = suffixes[0]
  for j = 1 .. suffixes.Count() - 1
    var suffix = suffixes[j]
    ?elem = "default"
      add_item(hash([ty, "default"]), suffix)
    :
      var full_name = string.Join(" ", 
      ^[elem, ty, suffix])
      var purpose = get_purpose(suffix)
      var h = hash([ty, elem, purpose])
      add_item(h, full_name)

func hash(parts)
  return string.Join("-", parts)

var elem_mods = ["f", "F", "i", "I", 
"p", "P", "h", "L",]
func get_purpose(suffix)
  ?string.Size(suffix) > 1 &
  ^elem_mods.Contains(string.Sub(suffix, 1, 1))
    return "mod"
  return "stats"

func add_item(hash, _name)
  var idx = all_items.IndexOf(hash)
  var arr
  ?idx = -1
    arr = [_name]
    all_items.Add(hash)
    all_items.Add(arr)
  :
    arr = all_items[idx + 1]
    ?!arr.Contains(_name)
      arr.Add(_name)

var all_statuses = [
  ["berserk", "Berserk", "+"], 
  ["smite", "Smite", "+"], 
  ["pick_pocket", "Pickpocket", "+"],
  ["vampiric", "Vamp", "+"],
  ["lucky_crit_multi", "Lucky", "+"],
  ["invisibility", "Invis", "+"],
  ["debuff_damage", "DmgDown", "-"],
  ["debuff_duration_damage", "DmgDown", "-"],
  ["spider_debuff_damage", "DmgDown", "-"],
  ["dysangelos_debuff_damage", "DmgDown", "-"],
  ["puff_debuff_damage", "DmgDown", "-"],
  ["debuff_yeti_chill", "AtkSlow", "-"],
  ["debuff_attack_speed", "AtkSlow", "-"],
  ["debuff_move_speed", "MoveSlow", "-"],
  ["debuff_chill", "Chill", "-"],
  ["stun", "Stun", "-"],
  ["pallas_phase2_debuff", "RangeDown", "-"],
  ["debuff_dot", "FireDoT", "-"],
]
var status_uids = []
func _prepare_statuses()
  for info : all_statuses
    status_uids.Add(info[0])

var my_buffs = []
var my_debuffs = []
var my_weird = []
var my_statuses = ["slow", false, "berserk", 
false, "smite", false, "stun", false, 
"range_down",0, "damage_down",0, "pickpocket",0, 
]
func _update_statuses()
  my_buffs.Clear()
  my_debuffs.Clear()
  for i = 1 .. my_statuses.Count() - 1
    ?i < 9
      my_statuses[i] = false
    :
      my_statuses[i] = 0
    i++
  for s : [buffs.string, debuffs.string]
    // format: *:name:count:duration,...
    var splt = string.Split(s, ":", ",", false)
    var arr_size = splt.Count()
    ?arr_size > 0
      // iterate over names (2nd field)
      for i = 1 .. arr_size - 3
        _parse_status(splt, i)
        i = i + 3

var ignore_statuses = [
  "quarterstaff_buff_attack_speed",
  "quarterstaff_buff_stun",
  "bardiche_buff_aoe_chance",
  "bardiche_buff_crit_chance",
  "bardiche_buff_crit_mult",
  "bardiche_buff_move_speed",
]
var dmg_debuffs = [
  "debuff_damage", "debuff_duration_damage",
  "spider_debuff_damage", "puff_debuff_damage"
]
var slow_debuffs = [
  "debuff_chill", "debuff_move_speed"
]
var range_debuffs = [
  "pallas_phase2_debuff"
]
var buff_template = "{0}({1}) {2}"
func _parse_status(splt, i)
  var uid = splt[i]
  var idx = status_uids.IndexOf(uid)
  ?idx = -1
    ?!ignore_statuses.Contains(uid) &
    ^!my_weird.Contains(uid)
      my_weird.Add(uid)
    return
  var info = all_statuses[idx] // uid, name, +/-
  var num = int.Parse(splt[i+1])
  var dur = int.Parse(splt[i+2])
  var _name = string.Format(buff_template, 
  ^info[1], num, time.FormatDigital(dur))
  ?info[2] = "+"
    my_buffs.Add(_name)
  :
    my_debuffs.Add(_name)
  var n
  ?dmg_debuffs.Contains(uid)
    n = get(my_statuses, "damage_down")
    set(my_statuses, "damage_down", n + num)
  :?range_debuffs.Contains(uid)
    n = get(my_statuses, "range_down")
    set(my_statuses, "range_down", n + num)
  :?string.Equals(uid, "pick_pocket")
    set(my_statuses, "pick_pocket", num)
  :?slow_debuffs.Contains(uid)
    set(my_statuses, "slow", true)
  :?my_statuses.Contains(uid)
    set(my_statuses, uid, true)

var foe_debuffs = ["debuff_damage", false,
"debuff_dot", false, "debuff_feeble", false, 
"buff_protection", false, "stun", false, 
"debuff_chill", 0]
func _update_foe_debuffs()
  foe_debuffs[foe_debuffs.Count() - 1] = 0
  for i = 1 .. foe_debuffs.Count() - 3
    foe_debuffs[i] = false
    i++
  var splt = string.Split(foe.debuffs.string,
  ^":", ",", false)
  var arr_size = splt.Count()
  ?arr_size = 0
    return
  for i = 1 .. arr_size - 3
    var uid = splt[i]
    var idx = foe_debuffs.IndexOf(uid)
    ?idx ! -1
      idx++
      ?string.Equals(uid, "debuff_chill")
        foe_debuffs[idx] = int.Parse(splt[i+1])
      :?string.Equals(uid, "stun")
        foe_debuffs[idx] = int.Parse(splt[i+2])
      :
        foe_debuffs[idx] = true

func can_be_debuffed(debuff_uid)
  ?(foe = "immune_to_" + debuff_uid)
    return false
  ?debuff_uid = "debuff_chill"
    return get(foe_debuffs, debuff_uid) 
    ^< max_chill_stacks
  return !get(foe_debuffs, debuff_uid)

var debuff_elems = []
func should_debuff()
  ?!is_boss | !debuff_on_smite | 
  ^!get(my_statuses, "smite")
    return false
  ?foe.buffs.string = "poena_mirror" | 
  ^foe_debuffs.Contains("buff_protection")
    return false
  debuff_elems.Clear()
  ?can_be_debuffed("debuff_damage")
    debuff_elems.Add("poison")
  ?can_be_debuffed("debuff_dot")
    debuff_elems.Add("fire")
  ?can_be_debuffed("debuff_chill")
    debuff_elems.Add("ice")
  ?debuff_elems.Count() > 0
    return debuff_elems
  return false

func get_elem()
  ?foe = aether
    return "vigor"
  ?foe = fire
    return "aether"
  ?foe = ice
    return "fire"
  ?foe = poison
    return "ice"
  ?foe = vigor
    return "poison"
  return "default"

var all_abilities = [
  "mind", "hammer", "bardiche", "blade",
  "skeleton_arm", "mask", "quarterstaff", 
  "dash", "bash",
]
var cooldowns = ["mind", 0]
var abilities = ["mind", false]
func _prepare_abilities()
  for r : useable_abilities
    ?!all_abilities.Contains(r)
      panic("Unknown ability: " + r)
    ?!abilities.Contains(r)
      set(cooldowns, r, 0)
      set(abilities, r, false)

var can_mind = false
func _update_abilities()
  for i = 0 .. abilities.Count() - 2
    var r = abilities[i]
    var cd = item.GetCooldown(r)
    set(cooldowns, r, cd)
    set(abilities, r, cd <= 0)
    ?string.Equals(r, "mind")
      can_mind = cd <= 0
    i++

var move_r = ["quarterstaff", "bash", "dash"]
func disable_r(ability)
  ?ability = "any_dash"
    for r : move_r
      set(abilities, r, false)
  :
    set(abilities, ability, false)

func get(dict, k)
  var idx = dict.IndexOf(k)
  ?idx = -1
    panic("Bad dict key: k=" + k)
  return dict[idx + 1]

var None = "~NONE~" // to distinguish from false
func try_get(dict, k)
  var idx = dict.IndexOf(k)
  ?idx = -1
    return None
  return dict[idx + 1]

func set(dict, k, v)
  var idx = dict.IndexOf(k)
  ?idx = -1
    dict.Add(k)
    dict.Add(v)
  :
    dict[idx + 1] = v

var weapon_ranges = ["sword", 5, "hammer", 5,
"quarterstaff", 5, "big sword", 6, "arm", 6, 
"heavy hammer", 7, "bardiche", 9, "staff", 10,
"blade", 11, "wand", 20, "heavy crossbow", 22,
"repeating", 22, "crossbow", 22]
var melee_range = 5
var melee_aoe_range = 5
var ranged_aoe_range = 16
func _prepare_ranges()
  var a = for_melee_single_target
  ?a.Count() > 0
    melee_range = get(weapon_ranges, a[0])
  a = for_melee_aoe
  ?a.Count() > 0
    melee_aoe_range = get(weapon_ranges, a[0])
  a = for_aoe_ranged
  ?a.Count() > 0
    ranged_aoe_range = get(weapon_ranges, a[0])

func _update_lock()
  ?get(my_statuses, "stun")
    set_lock("stun", 0)
  :
    clear_lock("stun")
  ?lock
    ?lock_timer <= 0
      lock = false
    :
      lock_timer--
  :
    lock_timer = 0

func _update_game_state()
  _equip_L_type = false
  _equip_L = false
  _equip_R = false
  found = false
  _elem = get_elem()
  stance = "unknown"
  low_hp = hp < (maxhp * low_hp_threshold)
  foe_s = foe.state
  foe_t = foe.time
  foe_ehp = foe.armor + foe.hp
  foe_dist = foe.distance  
  eff_dist = foe_dist + range_down_stacks
  is_boss = (foe = boss)
  phys_immune = (foe = immune_to_physical)
  can_aoe = (foe.count >= aoe_treshold)

func prelude()
  // reset/update dynamic global vars
  ?enable_hit_tracking
    track_hits()
  _update_statuses()
  _update_foe_debuffs()
  _update_abilities()
  _update_lock()
  _update_game_state()

var errors = []
func dbg(e)
  ?ui_show_debug
    ?!errors.Contains(e)
      errors.Add(e)

func panic(e)
  >`20,5,#red,@e@
  loc.Pause()

var debuff_hash = "sl={0},st={1},d={2},r={3}"
func track_hits()
  var hp_diff = last_frame_hp - hp
  var _debuffs = string.Format(debuff_hash,
  ^get(my_statuses, "slow"), 
  ^get(my_statuses, "stun"), 
  ^get(my_statuses, "damage_down") > 0,
  ^get(my_statuses, "range_down") > 0)
  ?hp_diff > 0 | 
  ^(last_frame_debuffs ! _debuffs)
    >`20,2,#red,Got hit!
    >`20,3,Last frame info:
    >`20,4,hp = @last_frame_hp@ (diff = 
    ^@hp_diff@), 
    ^armor = @last_frame_armor@
    >`20,5,id = @last_frame_foe@
    >`20,6,dist = @last_frame_dist@
    >`20,7,state = @last_frame_state@
    >`20,8,time = @last_frame_time@
    >`20,9,stance = @last_frame_stance@
    loc.Pause()
  last_frame_armor = armor
  last_frame_hp = hp
  last_frame_foe = foe.id
  last_frame_dist = foe_dist
  last_frame_state = foe_s
  last_frame_time = foe_t
  last_frame_stance = stance
  last_frame_debuffs = _debuffs

func _detect_poison()
  var x = screen.FromWorldX(pos.x)
  var y = screen.FromWorldZ(pos.z)
  >`0,0,x=@x@, y=@y@
  for px = pos_x .. pos_x+10
    for py = pos_y-6 .. pos_y
      ?draw.GetSymbol(px, py) = "("
        cache.Add([pos_x, pos_y, px, py])
  var arr_size = cache.Count()
  ?arr_size > 0
    for line = 1 .. arr_size
      var v = cache[line-1]
      >`0,@line@,x=@v[0]@, y=@v[1]@, 
      ^px=@v[2]@, py=@v[3]@;

var gray = "#7A8F93"
func draw_ui()
  var x = 1
  var y = 22
  ?ui_show_debug
    y = 20
  ?ui_show_statuses
    >`@x@,@y@,#00A300,
    ^+ @string.Join(", ", my_buffs)@
    >`@x@,@y+1@,#FE6800,
    ^- @string.Join(", ", my_debuffs)@
    >`@x@,@y+2@,#F008B2,
    ^? @string.Join(", ", my_weird)@
  ?ui_show_cd
    y = 6
    for r : all_abilities
      ?!move_r.Contains(r) & 
      ^abilities.Contains(r)
        var cd = get_cd(r)
        ?r = "skeleton_arm"
          r = "Arm"
        >`@x@,@y@,#@colorize(cd)@,
        ^@string.Capitalize(r)@ 
        ^@time.FormatDigital(cd)@
        y++
    >`@x@,@y@,
    ^#@colorize(get_cd("quarterstaff"))@,QS
    x = x + 2
    ?abilities.Contains("bash")
      >`@x@,@y@,@gray@,/
      x++
      >`@x@,@y@,
      ^#@colorize(get_cd("bash"))@,B
      x++
    ?abilities.Contains("dash")
      >`@x@,@y@,@gray@,/
      x++
      >`@x@,@y@,
      ^#@colorize(get_cd("dash"))@,D
      x++
  ?ui_show_debug
    x = 1
    y = 14
    ?foe
      >`@x@,@y@,@gray@,id: @foe.id@
      >`@x@,@y+1@,@gray@,State: @foe_s@
      >`@x@,@y+2@,@gray@,Time: @foe_t@
      >`@x@,@y+3@,@gray@,Dist: @foe_dist@
      >`@x@,@y+4@,@gray@,Count: @foe.count@
    y = 23
    >`@x@,@y@,#blue,Lock: @lock@ (@lock_timer@)
    >`@x@,@y+1@,#blue,Stance: @stance@
    >`@x@,@y+2@,@gray@,@loc.stars@* 
    ^@time.FormatDigital(totaltime)@ @foe@
    var _weapon = " (L)"
    x = screen.w - 10
    y = 23
    ?_equip_L
      x = x - string.Size(_equip_L)
      _weapon = _equip_L + _weapon
    >`@x@,@y@,#blue,@_weapon@
    _weapon = " (R)"
    x = screen.w - 10
    ?_equip_R
      x = x - string.Size(_equip_R)
      _weapon = _equip_R + _weapon
    >`@x@,@y+1@,#blue,@_weapon@
    
    var ey = 2
    for err : errors
      >`20,@ey@,#red,@err@
      ey++

func colorize(cd)
  // return "blue"
  ?cd > 0
    return "red"
  return "green"

func brew_pot()
  brew tar + bronze // vampiric

func reset_loop()
  lock = false
  lock_timer = 0
  at_boss = false
  cache.Clear()
  my_weird.Clear()
  enable_hit_tracking = false

?loc.begin
  _prepare_statuses()
  _prepare_items()
  _prepare_ranges()
  _prepare_abilities()
  ?item.potion = empty
    brew_pot()
  // ?loc = halls
  //   prefer_ranged = true
  //   for_ranged_single_target = ["wand"]
  // ?loc = caves
  //   prefer_ranged = true
:?loc.loop
  reset_loop()
:?ai.enabled & !ai.paused
  prelude()
  progress()
:
  idle()
draw_ui()