// "scribble"
// StoneScript automation for Stone Story RPG
// Ver. 1.2
// Project: https://github.com/livercat/scribble
// by livercat

//  *** Table of Contents ***
// You can Ctrl-F for these anchors to quickly
// go to the corresponding code
//   #Weapons - configure your weapons
//   #Settings - runtime and UI settings
//   #Progress - (verb) entry point for the rest
//               of the combat logic
//   #Combat - logic for weapon switching 
//             and ability use
//   #Abilities - granular logic and conditions
//                for abilities' prerequisites
//   #Bosses - specific boss mechanics
//   #Internals - var declarations and boring
//                internal functions
//   #Runtime - actual place where the script is 
//              executed

/***************
**  #Weapons  **
***************/
// Fill `elemental_items` with your items.
// Format:
// ["weapon type", 
//   ["element1", "suffix + enchant", ...],
//   ["element2", "suffix1", .., "suffixN"],
// ]
// Only list items that you actually want to use,
// otherwise script can grab a random *0 that
// you got from a chest. Also list suffixes by
// priority: better ones first. Multiple copies
// of the same suffix for the same item
// will be ignored.
// "default" items will be used if no suitable 
// elemental weapon is found, and against
// non-elemental enemies. They must be 
// written with their full names.
// If no "default" items are listed for 
// a category, then items from other elements
// will be used (but not the enemy's element).

var elemental_items = [
  ["warhammer", 
    ["aether", "D + 1", "D + 3"],
    ["fire", "dF", "D"],
    ["poison", "D"],
  ],
  ["wand", 
    ["fire", "D"],
    ["poison", "D"],
    ["vigor", "dL"],
  ],
  ["sword", 
    ["aether", "D"],
    ["fire", "dF", "D"],
    ["ice", "dI"],
    ["poison", "dP"],
    ["vigor", "dL"],
    ["default", "vigor sword dL"],
  ],
  ["shield", 
    ["vigor", "ah"],
    ["poison", "ap", "A"],
    ["ice", "A"],
    ["default", "vigor shield ah"],
  ],
]

// Items with special abilities.
// Supported: "dashing", "bardiche", 
// "heavy hammer"
var special_items = [
  "dashing", "bardiche", "heavy hammer",
]

// Lost Items
// Supported: bashing, blade, arm, mask
var lost_items = [
  "bashing", "blade", "arm", "mask"
]

// full name of the shield with the highest
// evade%
var evade_shield = "vigor ah"

// full name of the shield with the highest
// armor/regen
var armor_shield = "compound"

// Weapon type to prefer for melee aoe:
// "staff", "bardiche", "heavy hammer" will 2h.
// "wands", "big swords" will dual-wield 1h.
// "" will disable melee aoe and will dual-wield
// or 1h + shield.
var melee_aoe_weapon = "bardiche"

// Weapon type to prefer for ranged aoe.
// "staff" will 2h, "wands" will dual-wield 1h.
// "" will disable ranged aoe and will 
// move into melee range.
var ranged_aoe_weapon = "wands"

// Ranged single target weapon.
// "repeating" will 2h.
// "xbows", "wands" will dual-wield.
var ranged_st_weapon = "repeating"

/*********************
**     #Settings    **
*********************/
// Show ability cooldowns
var ui_show_cd = true

// Show your buffs/debuffs
var ui_show_statuses = true

// Show debug info (noisy, useful for research)
var ui_show_debug = false

// How many regular enemies are needed
// to start using AOE weapons instead of
// single target
var aoe_treshold = 4

// Low HP threshold, fraction of 1.
// When on low HP, will prioritize ah shields
// and dL weapon over matching element.
// If 1, will try to lifesteal to max (useful
// to get rid of zone cross).
// If -1, will never lifesteal.
var low_hp_threshold = 0.5

// If true, then will prefer 1h+shield in melee
// over dual-wield when on low HP.
var use_shield_on_low_hp = true

// Slower but safer, useful if you don't have 
// good melee weapons, but have a repeating xbow
var prefer_ranged = false

// Find a suitable amount based on your dI weapon
var max_chill = 6

// Set to true if you're doing Pallas quests
// for the Blade.
// Stages: "bolesh" to kill him with blade,
//         "variety" for killing unique enemies
var bfg_quest = false

// If you're on the "variety" step of the blade
// quest, fill this array with names of the
// enemies you've already defeated. You can take 
// a screenshot of your R&D journal in game with
// the defeated foes and then OCR it.
// For example, on iOS you can just select and 
// copy text in the default Photo app.
var bfg_defeated_foes = ["example", "example 2"]

// Depends on level/enchants of the Blade
var smite_damage = 85

// At least this many enemies must be present
// to trigger Smite
var smite_treshold = 7

// Set to true if you're doing Skeleton Arm
// quests. It will prioritize pickpocketing in 
// combat, and will try to only use it when 
// non-boss foes will die from the ability.
var pickpocket_quest = false

// These depend on level/enchants of the Arm
var arm_damage = 32
var max_pickpocket = 2

// if true, will always get `max_pickpocket`
// buff stacks even if the arm ability is on CD
var maintain_pickpocket = false

// Use if you're doing Cultist Mask
// quests.
// "simple" - steps 1 and 3 (uses on CD)
// "5debuffs" - step 2 (debuffs after mask). You
//    will have to stun yourself with grappling
// "prevent" - step 4: do it in Rocky. Script
// will approach the scout, use mask, get hit as
// long as the debuff lasts, and quit 
// the location. 
// It will equip `armor_shield`, I suggest
// dashing.
var mask_quest = false

/*********************
**     #Progress    **
*********************/
func progress()
  ?healwalk() // no enemies nearby
    return true
  :?foe = undamageable
    return shield_block_and_halt()
  :?foe = explode
    return avoid_explosion()
  :?!is_boss & !at_boss
    // regular enemies
    free_mind = true
    return fight()

  // Fight bosses
  stance = "boss combat"
  ?loc = rocky
    ?foe = acronian_scout
      return fight_scout()
    return fight_dysan()
  :?loc = deadwood
    return fight_xyloalgia()
  :?loc = caves
    return fight_bolesh()
    // TODO ceiling decorator
  :?loc = fungus_forest_boss
    return fight_mushrooms()
  :?loc = mushroom
    ?foe.id = "epic_snail"
      auto_melee()
    // fluff is handled in avoid_explosion()
  :?loc = undead_crypt_boss
    return fight_pallas()
  :?loc = bronze_guardian
    return fight_bronze_guardian()
  :?loc = icy_ridge
    return fight_hrimnir()
  :?loc = nagaraja
    return fight_nagajara()
  :
    // unknown boss
    dbg("Fighting unknown boss")
    auto_melee_boss()

func idle()
  stance = "out of combat"
  ?pickup.distance < 8
    equipL star
    equipR triskelion
    return
  :?can_qs_dash()
    return qs_dash()
  :?hp < maxhp
    equipL ouroboros
  :
    equipL triskelion
  found = get_equipment("shield", false)
  ?found
    equipR @found@

func healwalk()
  ?foe & eff_dist < 23
    ?hp < (maxhp / 4) & item.potion ! empty &
    ^(item.potion = "healing" | 
    ^item.potion = "vampiric")
      activate potion
    return false // start combat instead
  :?pickup.distance < 8
    equipL star
    equipR triskelion
  :
    idle()
  stance = "out of combat"
  return true // continue healwalking

func avoid_explosion()
  ?foe_dist < 5
    return try_evade()
  ?foe.id = "fluff" & foe.state = 2 & foe.time > 3
    return melee("def")

/********************
**     #Combat    **
********************/
func fight()
  // chooses general approach to the combat
  ?prefer_ranged & foe_dist < 10 & 
  ^can_backflip()
    return backflip()
  :?phys_immune
    return auto_elemental()
  :?must_melee_foe()
    return auto_melee()
  :?ranged_st_weapon & 
  ^(prefer_ranged | must_ranged_foe())
    return auto_ranged()
  :
    return auto_melee()

func auto_melee()
  ?mask_quest = "5debuffs"
    equipR mask
    ?can_mask()
      return mask()
    return debuff("def")
  ?use_abilities()
    return true
  :?melee_aoe_weapon & can_aoe & eff_dist < 8
    return melee("aoe")
  :?low_hp & use_shield_on_low_hp
    return melee("def")
  :
    return melee("dps")

// mode: "dps" | "def" | "aoe"
func melee(mode)
  ?come_closer()
    return true
  ?eff_dist > 7 // get into range
    mode = "def"
  var offhand
  ?mode = "dps"
    stance = "melee dps"
    ty = "melee"
    offhand = "melee"
  :?mode = "def"
    stance = "melee def"
    ty = "melee"
    offhand = "shield"
  :?mode = "aoe"
    stance = "melee aoe"
    equip @melee_aoe_weapon@
    return
  :
    dbg("melee(" + mode + "): unsupported mode="
    ^+ mode)
    return
  ?low_hp
    stance = stance + " vamp"
  found = maybe_healing_equipment(ty)
  ?found
    main_hand(found)
  :
    dbg("melee(" + mode + "): no weapon found")
  found = maybe_healing_equipment(offhand)
  ?found
    equipR @found@
  :
    dbg("melee(" + mode + "): no " + 
    ^ offhand + " found")  

func come_closer()
  ?should_qs_dash()
    return qs_dash()
  :?can_dash()
    return dash()
  return false  

func auto_ranged()
  ?use_abilities()
    return true
  :?ranged_aoe_weapon & can_aoe & eff_dist <= 16
    return elemental_aoe()
  :?ranged_st_weapon
    return ranged()
  :
    return auto_melee()

func ranged()
  stance = "ranged " + ranged_st_weapon
  ?ranged_st_weapon = "repeating"
    equip @ranged_st_weapon@
    return
  :?ranged_st_weapon = "xbows"
    ty = "crossbow"
  :?ranged_st_weapon = "wands"
    ty = "wand"
  :
    dbg("ranged(): unsupported ranged_st_weapon="
    ^+ ranged_st_weapon)
    return
  ?low_hp
    stance = stance + " vamp"
  found = maybe_healing_equipment(ty)
  ?found
    main_hand(found)
  :
    dbg("ranged(" + ranged_st_weapon + 
    ^"): no weapon found")
  found = maybe_healing_equipment(ty)
  ?found
    equipR @found@
  :
    dbg("ranged(" + ranged_st_weapon + 
    ^"): no offhand found")

func auto_elemental()
  ?use_abilities()
    return true
  :?ranged_aoe_weapon
    return elemental_aoe()
  :
    return auto_melee()

func elemental_aoe()
  stance = "elemental"
  ?ranged_aoe_weapon = "wands"
    ty = "wand"
  :?ranged_aoe_weapon = "staff"
    ty = "staff"
  :
    dbg("elemental_aoe(): unsupported " + 
    ^"ranged_aoe_weapon=" + ranged_aoe_weapon)
    return
  ?low_hp
    stance = stance + " vamp"
  found = maybe_healing_equipment(
  ^ranged_aoe_weapon)
  ?found
    main_hand(found)
  :
    dbg("elemental_aoe(" + ranged_aoe_weapon +  
    ^"):no weapon found")
  ?ty = "staff"
    return
  // get second wand
  found = maybe_healing_equipment(ty)
  ?found
    equipR @found@
  :
    dbg("elemental_aoe(" + ranged_aoe_weapon + 
    ^"): no offhand found")

func can_dash()
  return can("dash") & !disable_dash & 
  ^eff_dist > 10 & eff_dist < 17 &
  ^(bashCD <= 0 | dashCD <= 0) &
  ^can_activate()

func dash()
  ?!disable_bash & have_bashing & bashCD <= 0
    stance = "bashing"
    equipR bashing
  :?dashCD <= 0 & have_dashing
    stance = "dashing"
    equipR dashing
  return true

func must_ranged_foe()
  return foe = mosquito | 
  ^foe = huge_mosquito | 
  ^foe = fire_elemental | foe = ant

func must_melee_foe()
  return foe = immune_to_ranged | foe = ranged | 
  ^foe = cult_guard // poisons on being hit

func auto_melee_boss()
  ?come_closer()
    return true
  var mode
  ?low_hp
    mode = "def"
  :
    mode = "dps"
  ?!use_abilities() // if no abilities are done
    ?!debuff(mode) // and no debuffs are needed
      return melee(mode)

// mode: "dps" | "def"
func debuff(mode)
  ?foe_buffs = disable_debuff | 
  ^foe_buffs = mirror
    return false
  var consider = []
  ?!(foe_debuffs = foe_poisoned) &
  ^!(foe = immune_to_debuff_damage)
    consider.Add("poison")
  :?!(foe_debuffs = foe_on_fire) &
  ^!(foe = immune_to_debuff_dot)
    consider.Add("fire")
  :?!(foe_debuffs = max_chill_s) &
  ^!(foe = immune_to_debuff_chill)
    consider.Add("ice")
  ?consider.Count() = 0
    return false
  stance = "debuffing"
  for i = 0 .. consider.Count() - 1
    found = get_elem_equipment("melee", 
    ^consider[i], true)
    ?found
      main_hand(found)
      i = 999
  ?mask_quest = "5debuffs"
    equipR mask
    return
  found = false
  ?mode = "dps"
    // try to get debuffing weapon
    for i = 0 .. consider.Count() - 1
      found = get_elem_equipment("melee", 
      ^consider[i], true)
      ?found
        equipR @found@
        return true
    // otherwise, a regular weapon
    ?!found
      found = get_equipment("melee", false)
      ?found
        equipR @found@
        return true
  found = maybe_healing_equipment("shield")
  ?found
    equipR @found@
    return true
  return false

/********************
**    #Abilities   **
********************/

// Note on functions below:
// can_<something>() checks hard prerequisites:
//   cooldowns, statuses, etc.
// should_<something>() checks fight logic:
//   number of enemies, statuses, etc.
// <something>() actually uses trues to use
//   the ability without doing checks itself

func can(ability)
  return !ability_lock | 
  ^string.Equals(ability_lock, ability)

// quarterstaff
func can_qs_dash()
  return can("qs") & !disable_dash & 
  ^staffCD <= 0 & can_activate()

// quarterstaff
func should_qs_dash()
  return (prefer_ranged & eff_dist > 28) |
  ^eff_dist > 16 & can_qs_dash()

// quarterstaff
func qs_dash()
  stance = "staff-dashing"
  equip quarterstaff
  ?item.CanActivate("quarterstaff")
    activate R
  return true

// Mind Stone
func can_backflip()
  // don't check this condition
  // for boss mechanics (when free_mind is false)
  return can("mind") & free_mind & 
  ^mindCD <= 0 &
   // don't jump into the wall
  ^screen.FromWorldX(pos.x) > 5
  
// Mind Stone
func backflip()
  stance = "mind stone R"
  equipL mind
  found = get_equipment("shield", false)
  ?found
    equipR @found@
  :
    dbg("backflip(): no shield found")

// skeleton arm
func can_slap()
  ?!can("arm") | !have_arm | eff_dist > 6 |
  ^phys_immune
    return false
  ?(pickpocket_quest | maintain_pickpocket) &
  ^(pickpocket_stacks < max_pickpocket) & 
  ^!slowed & !low_hp
    return true // get to max buffs
  return have_arm & armCD <= 0 & !disable_steal &
  ^pickpocket_stacks >= max_pickpocket &
  ^can_activate()

// skeleton arm
func should_slap()
  return can_slap() & (!pickpocket_quest |
  ^foe_ehp <= edmg(arm_damage))

// skeleton arm
func slap()
  stance = "skeleton arm R"
  aac("skeleton arm")
  ?pickpocket_stacks >= max_pickpocket &
  ^item.CanActivate("skeleton_arm")
    activate R
  return true

// blade of the fallen god
func can_smite()
  return can("smite") & 
  ^have_blade & smiteCD <= 0 &
  ^!disable_smite & 
  ^eff_dist <= 20 & (foe ! pallas) & // immune
  ^can_activate()

// blade of the fallen god
func should_smite()
  ?bfg_quest = "variety"
    ?foe_ehp<=edmg(smite_damage) & can_smite()
      for e : bfg_defeated_foes
        ?foe = e
          return false
      return true
    return false
  :
    return (is_boss | foe.count >= smite_treshold
    ^& foe_ehp<=edmg(smite_damage)) & can_smite()

// blade of the fallen god
func smite()
  stance = "smite R"
  aac("blade")
  ?item.CanActivate("blade")
    activate R
  return true

// heavy hammer
func can_hammer()
  return can("hammer") & have_ham & 
  ^!phys_immune & eff_dist <= 7 &
  ^(hammerCD <= 0 | hammerCD >= 647) &
  ^can_activate()

// heavy hammer
func should_hammer()
  return foe.armor > 0 & (is_boss | can_aoe) & 
  ^can_hammer()

// heavy hammer
func hammer()
  ability_lock = "hammer"
  stance = "heavy hammer R"
  aac("heavy hammer")
  ?item.CanActivate("hammer")
    activate R
  return true

// bardiche
func can_bard()
  return can("bardiche") & have_bard & 
  ^eff_dist <= 9 & !phys_immune &
  ^(bardCD <= 0 | bardCD >= 870) &
  ^can_activate()

// bardiche
func should_bard()
  return is_boss & can_bard()

// bardiche
func bardiche()
  ability_lock = "bardiche"
  stance = "bardiche R"
  aac("bardiche")
  ?item.CanActivate("bardiche")
    activate R
  return true

// mask
func can_mask()
  return can("mask") & have_mask & 
  ^maskCD <= 0 & can_activate()

// mask
func should_mask()
  return is_boss & mask_quest = "prevent" &
  ^can_mask()

// mask
func mask()
  stance = "mask R"
  equipR mask
  ?item.CanActivate("mask")
    activate R
  return true

func use_abilities()
  // prioritize quests
  ?mask_quest = "simple" & can_mask()
    return mask()
  ?pickpocket_quest & can_slap()
    return slap()
  // then use where needed
  ?should_hammer()
    return hammer()
  ?should_smite()
    return smite()
  ?should_bard()
    return bardiche()
  ?should_slap()
    return slap()
  ?should_mask()
    return mask()
  return false

func can_activate()
  return ai.enabled & item.CanActivate()

func aac(weapon)
  // attack animation cancelling:
  // equipping a different weapon
  // right after the attack cancels
  // the backswing animation,
  // effectively increasing your
  // attack speed
  equip @weapon@
  ?!berserk & !slowed & ai.idle
    // sometimes dashing/bashing seem to have
    // weird behavior: after dash/bash ai.idle
    // will not become false even after using
    // other abilities. it interrupts hammer R,
    // bardiche R, and some weapon attacks
    // i have no idea what really causes it,
    // but at least don't interrupt R's
    ?string.Equals(weapon, "heavy hammer") &
    ^hammer_swing
      return false
    :?string.Equals(weapon, "bardiche") &
    ^bardiche_swing
      return false
    equip wand
  equip @weapon@
  return true

/*****************
**    #Bosses   **
*****************/

func lock_abilities(source)
  // doesn't interrupt the ability that's
  // already in progres, but prevents
  // new ones from starting
  ?!ability_lock
    ability_lock = source

func shield_block()
  stance = "shield block"
  equipR @evade_shield@

func shield_block_and_halt()
  stance = "shield block and halt"
  equipL quest
  equipR @evade_shield@

func fight_scout()
  ?mask_quest = "prevent"
    equipL quest
    ?foe.state = 32 & foe.time > 11 & can_mask()
      mask()
    :?maskCD > 0 & 
    ^foe_debuffs ! "debuff_feeble"
      loc.Pause()
    :
      equipR @armor_shield@
  :
    auto_melee_boss()    

func fight_dysan()
  ?foe = phase1
    disable_steal = true
    ?foe.state = 33 & foe.time = 24
      // block big attack
      shield_block()
    auto_melee_boss()
  :?foe = phase2
    // just match elements
    disable_steal = true
    auto_melee_boss()
  :?foe = phase3
    ?foe.state = 32 & foe.time > 90
      // prepare for attack
      shield_block()
    :?foe.state = 115
      ?foe.time = 60
        // dodge the orb ray
        return backflip()
      :?foe.time < 80
        // don't dash into ray
        disable_dash = true
    :?foe.state = 106 | foe.state = 108 |
    ^foe.state = 0
      shield_block()
    :?foe.state = 107 | foe.state = 32
      disable_steal = true
    auto_melee_boss()

func fight_xyloalgia()
  ?foe = phase1
    // Xyloalgia
    return auto_melee_boss()
  // Poena
  disable_steal = true
  ?foe_buffs = mirror
    shield_block_and_halt()
  :?foe.state = 32 & foe.time = 41
    shield_block()
  :
    auto_melee_boss()

func fight_bolesh()
  // Get close, debuff/use abilities, then
  // jump to ranged before the first melee bite,
  // and continue shooting and blocking.
  ?loc.stars > 5
    disable_steal = true
  ?foe.state = 133 &
  ^(foe.time > 12 & foe.time < 18)
    // block bite and don't move from ranged
    return shield_block_and_halt()
  :?foe.state = 142 & foe.time > 53
    // evade melee bite
    return backflip()
  :?bfg_quest = "bolesh" & 
  ^(foe_ehp < edmg(smite_damage))
    ?come_closer()
      return true
    :
      equip @blade@
  :?mindCD <= 0 &
  ^foe_buffs ! "spider_buff_damage"
    return auto_melee_boss()
  :?mindCD <= 0 & foe_dist < 10
    return backflip()
  ranged()
  
func try_evade()
  ?mindCD <= 0
    return backflip()
  return shield_block()

func fight_mushrooms()
  disable_steal = true
  ?ability_lock = "shrooms"
    ability_lock = false
  ?foe = phase1
    ?foe.state = 32 & foe.time = 48
      // only the first swing is accurate,
      // then its timing is affected by chill
      return try_evade()
    :?foe.state = 32 & foe.time > (48 - 15)
      // prevent interrupts
      lock_abilities("shrooms")
    :?foe.state = 33
      // V = 1 frame / sec
      ?foe.time = foe_dist + 4
        // pellets
        return shield_block()
      :
        // prevent interrupts
        lock_abilities("shrooms")
  :?foe = mushroom_boss_fat
    ?loc.stars < 11
      big_swing = 56
    :
      big_swing = 59
    ?foe.state = 32
      ?foe.time = big_swing
        // only accurate for the first punch
        // then it's affected by chill/stun
        return try_evade()
      :?foe.time > (big_swing - 15)
        // prevent interrupts
        lock_abilities("shrooms")
    :
      auto_melee_boss()
    // TODO detect pellets
  : // Enoki themself
    ?eff_dist > 6
      ?!come_closer()
        melee("def")
    :
      auto_melee_boss()
    // TODO detect pellets
  auto_melee_boss()

func fight_pallas()
  at_boss = true
  disable_steal = true
  ?foe.count > 2
    ?foe_dist < 15 & mindCD <= 0
      backflip()
    :
      elemental_aoe()
  :
    auto_melee_boss()

func fight_bronze_guardian()
  disable_steal = true
  ?foe.state = 32 & foe.time = 30
    backflip() // dodge the hammer
  :?foe.state = 33
    // hammer is down
    ?!use_abilities()
      melee("dps") // don't bother debuffing
  :?foe_dist > 15 & foe.state = 2
    ranged()

func fight_hrimnir()
  at_boss = true
  ?is_boss & foe.armor > 0
    // initial ice block
    ?should_slap()
      slap() // get free evade stacks
    :
      melee("dps") // don't debuff
  :?loc.stars <= 5 // try to cheese
    ?foe_dist <= 2
      ?!use_abilities()
        melee("dps") // don't debuff
    :?foe_dist <= 5
      // The shovel has an attack range of 1
      // so at white stars we can avoid
      // snowballs by getting close to boss.
      // on higher stars he blows you away
      // immediately
      equip shovel
    : // blown away, get back
      auto_melee()
  :?foe.state = 143 | foe.state = 144 // blowing
    ranged()
  :?foe.count > 1 // deal with adds
    ?slowed // don't waste time on movement
      ?eff_dist < 7
        auto_melee()
      :?foe.count > 2
        elemental_aoe()
      :
        ranged()
    :?can_smite()
      smite()
    :?can_bard() & foe = ice_wall
      bardiche()
    :?foe.count > 2 // elementals
      melee("aoe")
    :
      auto_melee() // ice wall
  :?slowed
    // don't waste time on movement
    ranged()
  :
    auto_melee_boss()

func fight_nagajara()
  disable_steal = true
  // goal is to dodge poison balls
  var x = screen.FromWorldX(pos.x)
  var y = screen.FromWorldZ(pos.z)
  // _detect_poison(x, y) // debug and research

  ?is_poison_near(x, y)
    naga_step++

  ?naga_step = 0
    // start at the xbow range
    ranged()
  :?naga_step = 1
    // staff 1st poison
    qs_dash()
    naga_step++
  :?naga_step = 2
    // and continue to shoot
    ranged()
  :?naga_step = 3
    // dash into melee
    auto_melee_boss()
  :?naga_step >= 4
    ?mindCD <= 0
      // dodge back and repeat
      backflip()
      naga_step = 0
    :
      // mind stone on CD, try to def
      melee("def")

func is_poison_near(pos_x, pos_y)
  // long and mid range
  ?draw.GetSymbol(pos_x+2, pos_y-6) = "(" |
  // melee
  ^(draw.GetSymbol(pos_x+1, pos_y-6) = "(")
    return true
  return false

func _detect_poison()
  var x = screen.FromWorldX(pos.x)
  var y = screen.FromWorldZ(pos.z)
  >`0,0,x=@x@, y=@y@
  for px = pos_x .. pos_x+10
    for py = pos_y-6 .. pos_y
      ?draw.GetSymbol(px, py) = "("
        cache.Add([pos_x, pos_y, px, py])
  var arr_size = cache.Count()
  ?arr_size > 0
    for line = 1 .. arr_size
      var v = cache[line-1]
      >`0,@line@,x=@v[0]@, y=@v[1]@, 
      ^px=@v[2]@, py=@v[3]@;

/*********************
**     #Internals   **
*********************/
// `var`s are only initialized once per zone
// and don't reset between loops.
// We can use this to cache some calculations
// so we don't redo them every frame.
// Arrays are especially important, because 
// they're costly to initialize. 
// Use `array.Clear()` instead of `array = []`
// to reset it.

// constants
var ignore_st = [ // irrelevant statuses
  "quarterstaff_buff_attack_speed",
  "quarterstaff_buff_stun",
  "bardiche_buff_aoe_chance",
  "bardiche_buff_crit_chance",
  "bardiche_buff_crit_mult",
  "bardiche_buff_move_speed",
]
var statuses = [
  ["smite", "Smite", "+"], 
  ["pick_pocket", "Pickpocket", "+"],
  ["vampiric", "Vamp", "+"],
  ["lucky_crit_multi", "Lucky", "+"],
  ["invisibility", "Invis", "+"],
  ["debuff_damage", "DmgDown", "-"],
  ["debuff_duration_damage", "DmgDown", "-"],
  ["spider_debuff_damage", "DmgDown", "-"],
  ["dysangelos_debuff_damage", "DmgDown", "-"],
  ["puff_debuff_damage", "DmgDown", "-"],
  ["debuff_yeti_chill", "AtkSlow", "-"],
  ["debuff_attack_speed", "AtkSlow", "-"],
  ["debuff_move_speed", "MoveSlow", "-"],
  ["debuff_chill", "Chill", "-"],
  ["stun", "Stun", "-"],
  ["pallas_phase2_debuff", "RangeDown", "-"],
  ["debuff_dot", "FireDoT", "-"],
]
var dmg_debuffs = [
  "debuff_damage", "debuff_duration_damage",
  "spider_debuff_damage", "puff_debuff_damage"
]
var slow_debuffs = [
  "debuff_chill", "debuff_move_speed"
]
var stun_debuff = "stun"
var max_chill_s = "❄:debuff_chill:" + 
^max_chill + ":"
var foe_poisoned = "∞:debuff_damage:1:"
var foe_on_fire = "φ:debuff_dot:1:"
var disable_debuff = "buff_protection"
var mirror = "poena_mirror"
var pickpocket_buff = "pick_pocket"

// global vars below
// misc
var at_boss = false // to deal with adds
var naga_step = 0 // nagaraja fight
var big_swing = 0 // mushrooms
// player status
var stance = "unknown" // chosen combat stance
var low_hp = false // hp < (maxhp * threshold)
var dmg_down_stacks = 0 // poison
var range_down_stacks = 0
var pickpocket_stacks = 0 // pickpocket buff
var slowed = false // is player slowed
var stunned = false // is player stunned
var berserk = false // berserk potion TODO
var can_aoe = false // foe.count >= aoe_treshold
// abilities
var ability_lock = false // prevent interruption
var free_mind = false
var disable_steal = false
var disable_dash = false
var disable_bash = false
var disable_smite = false
// foe status
var foe_ehp = 0 // foe.armor + foe.hp
var foe_dist = 0 // foe_dist
var eff_dist = 0 // foe_dist + range_debuff
var foe_buffs = "" // foe.buffs.string
var foe_debuffs = "" // foe.debuffs.string
var is_boss = false // foe = boss
var phys_immune = false // immune to physical
// cooldowns
var mindCD = 0
var staffCD = 0
var bashCD = 0
var dashCD = 0
var armCD = 0
var hammerCD = 0
var smiteCD = 0
var bardCD = 0
var maskCD = 0
var bardiche_swing = 0
var hammer_swing = 0

// Pre-define vars for internal functions.
var found = false
var ty = false
var _main_hand = false
var _elems = []
var st_good = [] // current buffs
var st_bad = [] // current debuffs
var st_x = [] // unknown status effects
var status_uids = []
var errors = []
var cache = []

var have_bard = 
^special_items.IndexOf("bardiche") ! -1
var have_ham = 
^special_items.IndexOf("heavy hammer") ! -1
var have_dashing = 
^special_items.IndexOf("dashing") ! -1
var have_bashing = 
^lost_items.IndexOf("bashing") ! -1
var have_arm = 
^lost_items.IndexOf("arm") ! -1
var have_blade = 
^lost_items.IndexOf("blade") ! -1
var have_mask = 
^lost_items.IndexOf("mask") ! -1

var type_offsets = [
  "sword", "big sword", "wand",
  "shield", "crossbow", "staff", 
  "warhammer",
  ]
var elem_offsets = [
  "aether", "fire", "ice", "poison", "vigor",
  "default",
  ]
var equipment = [
  // Each element of this array is
  // [[damage/armor items], [debuff items]]
  // they're placed by equip offset, then by
  // elem offset.
  // For example: first element is aether swords, 
  // seconds is fire swords, sixth is aether 
  // big swords.
  // See also: get_item()
]
// "{element} {type} {suffix + enchant}"
var name_template = "{0} {1} {2}"
func _fill_items_cache()
  // add placeholders for every type+element pair
  var total_types = type_offsets.Count()
  var total_elems = elem_offsets.Count()
  for i = 0 .. (total_types * total_elems) - 1
    equipment.Add([[], []])
   // `it` is 
   // ["type": ["elem", "s1", "sn"], [elem2...]]
  for it : elemental_items
    ?it.Count() > 1
      for i = 1 .. it.Count() - 1
        //`el_it` is ["elem", "s1", "sn"]
        var el_it = it[i]
        ?el_it.Count() < 2
          i++ // continue
        ty = it[0] // item type
        var elem = el_it[0] // item element
        var offset = 
        ^type_offsets.IndexOf(ty) * total_elems +
        ^elem_offsets.IndexOf(elem)
        // for every suffix in list
        for j = 1 .. el_it.Count() - 1
          var suffix = el_it[j]
          // `slot` is 
          // [[dmg items], [debuff items]]
          var slot = equipment[offset]
          var full_name
          ?elem = "default"
            full_name = suffix
            ?slot[0].IndexOf(full_name) = -1
              slot[0].Add(full_name)
          :
            full_name = string.Format(
            ^name_template, elem, ty, suffix)
            ?is_debuff(suffix) & 
              ^slot[1].IndexOf(full_name) = -1
              slot[1].Add(full_name)
            :?slot[0].IndexOf(full_name) = -1
              slot[0].Add(full_name)

var debuff_suffixes = "fFiIpPhL"
func is_debuff(suffix)
  ?string.Size(suffix) < 2
    return false
  // check second symbol of the suffix
  return string.IndexOf(debuff_suffixes,
  ^string.Sub(suffix, 1, 1)) ! -1

// ty: "melee" | "wand" | "crossbow" | "shield"
// debuff: bool
func get_equipment(ty, debuff)
  // first try the preferred element
  found = get_elem_equipment(ty, _elems[0],
  ^debuff)
  ?found
    return found
  // they try the default (need the concrete
  // item type instead of generic "melee")
  found = get_item(disambiguate_type(ty, true),
  ^"default", debuff)
  ?found
    return found
  // they try the rest of the elements
  for i = 1 .. _elems.Count() - 1
    var elem = _elems[i]
    found = get_elem_equipment(ty, elem, debuff)
    ?found
      return found
  return false

func disambiguate_type(ty, only_one)
  ?ty = "melee"
    var arr
    ?foe.armor > 0
      arr = melee_aa_weapons
    :
      arr = melee_1h_weapons
    ?only_one
      return arr[0]
    return arr
  return ty

var melee_1h_weapons = [
  "sword", "big sword", "warhammer"
]
var melee_aa_weapons = [
  "warhammer", "sword", "big sword"
]
func get_elem_equipment(ty, elem, debuff)
  found = false
  var arr
  ?ty = "melee"
    for tt : disambiguate_type("melee", false)
      found = get_item(tt, elem, debuff)
      ?found
        return found
  :?ty = "wand"
    return get_item("wand", elem, debuff)
  :?ty = "crossbow"
    return get_item("crossbow", elem, debuff)
  :?ty = "shield"
    return get_item("shield", elem, debuff)
  :?ty = "staff"
    return get_item("staff", elem, debuff)
  :
    dbg("get_elem_equipment(): unsupported type="
    ^+ ty)
  return false

// ty: "melee" | "wand" | "crossbow" | shield
// debuff: bool
func maybe_healing_equipment(ty)
  found = false
  ?low_hp
    found = get_elem_equipment(ty, "vigor", true)
  ?!found
    found = get_equipment(ty, false)
  return found

// ty: wand, sword, etc
// element: aether, fire, etc
// debuff: bool (true/false)
func get_item(ty, element, debuff)
  var total_elems = elem_offsets.Count()
  var offset = 
  ^type_offsets.IndexOf(ty) * total_elems + 
  ^elem_offsets.IndexOf(element)
  var slot = equipment[offset]
  ?!debuff
    found = _find_first(slot[0], _main_hand)
    // if D item not found, try to find dX item
  ?debuff | !found
    found = _find_first(slot[1], _main_hand)
  return found

func _find_first(arr, exclude)
  ?arr.Count() > 0
    for it : arr
      ?!exclude | !string.Equals(exclude, it)
        return it
  return false  

func main_hand(it)
  equipL @it@
  _main_hand = it

func _fill_status_uids()
  for st_info : statuses
    status_uids.Add(st_info[0])

func edmg(dmg)
  // effective damage after considering debuffs
  return dmg - dmg_down_stacks

func parse_statuses()
  st_good.Clear()
  st_bad.Clear()
  dmg_down_stacks = 0
  range_down_stacks = 0
  pickpocket_stacks = 0
  slowed = false
  berserk = false
  stunned = false
  for s : [buffs.string, debuffs.string]
    // format: *:name:count:duration,...
    var splt = string.Split(s, ":", ",", false)
    var arr_size = splt.Count()
    ?arr_size > 0
      // iterate over names (2nd field)
      for i = 1 .. arr_size - 3
        var st_uid = splt[i]
        var st_amount = int.Parse(splt[i+1])

        // flags for combat logic
        ?dmg_debuffs.IndexOf(st_uid) ! -1
          dmg_down_stacks = dmg_down_stacks + 
          ^st_amount
        :?string.Equals(st_uid, range_debuff)
          range_down_stacks = st_amount
        :?slow_debuffs.IndexOf(st_uid) ! -1
          slowed = true
        :?string.Equals(st_uid, stun_debuff)
          stunned = true
        :?string.Equals(st_uid, pickpocket_buff)
          pickpocket_stacks = st_amount

        var idx = status_uids.IndexOf(st_uid)
        ?idx ! -1
          var st_info = statuses[idx]
          var st_dur = int.Parse(splt[i+2])

          var st_s = string.Format("{0}({1}) " + 
          ^"{2}", st_info[1], st_amount,
          ^time.FormatDigital(st_dur))

          ?st_info[2] = "+"
            st_good.Add(st_s)
          :
            st_bad.Add(st_s)

        :?ignore_st.IndexOf(st_uid) = -1 &
        ^st_x.IndexOf(st_uid) = -1
          // log unknown statuses for debug
          st_x.Add(st_uid)

        i = i + 3

func prelude()
  parse_statuses()
  // reset/update dynamic global vars
  disable_steal = false
  disable_dash = false
  disable_bash = false
  disable_smite = false
  free_mind = false

  mindCD = item.GetCooldown("mind")
  staffCD = item.GetCooldown("quarterstaff")
  bashCD = item.GetCooldown("bash")
  dashCD = item.GetCooldown("dash")
  armCD = item.GetCooldown("skeleton_arm")
  hammerCD = item.GetCooldown("hammer")
  smiteCD = item.GetCooldown("blade")
  bardCD = item.GetCooldown("bardiche")
  maskCD = item.GetCooldown("mask")

  hammer_swing = hammerCD >= 647
  bardiche_swing = bardCD >= 870

  ?stunned
    ability_lock = "stun"
  :?ability_lock
    // clear the locks after they're done
    ?(ability_lock = "stun") |

    ^(ability_lock = "bardiche" & 
    ^!bardiche_swing) |

    ^(ability_lock = "hammer" &
    ^!hammer_swing)
      ability_lock = false
  
  _main_hand = false
  stance = "unknown"
  low_hp = hp < (maxhp * low_hp_threshold)
  foe_ehp = foe.armor + foe.hp
  foe_dist = foe.distance  
  eff_dist = foe_dist + range_down_stacks
  foe_buffs = foe.buffs.string
  foe_debuffs = foe.debuffs.string
  is_boss = (foe = boss)
  phys_immune = (foe = immune_to_physical)
  can_aoe = (foe.count >= aoe_treshold) & !low_hp

  ?loc = halls | foe = aether
    _elems = ["vigor", "fire", "ice", "poison"]
  :?loc = mine | foe = fire
    _elems = ["aether", "ice", "poison", "vigor"]
  :?loc = ridge | foe = ice
    _elems = ["fire", "aether", 
    "poison", "vigor"]
  :?loc = caves | loc = temple | foe = poison
    _elems = ["ice", "aether", "fire", "vigor"]
  :?loc = mushroom | foe = vigor
    _elems = ["poison", "aether", "fire", "ice"]
  :
    _elems = ["default", "vigor", "aether", 
    "fire", "ice", "poison"]

func dbg(e)
  ?ui_show_debug
    ?errors.IndexOf(e) = -1
      errors.Add(e)

func draw_ui()
  var sy = 22
  ?ui_show_debug
    sy = 20
  ?ui_show_statuses
    >`1,@sy@,#00A300,
    ^+ @string.Join(", ", st_good)@
    >`1,@sy+1@,#FE6800,
    ^- @string.Join(", ", st_bad)@
    >`1,@sy+2@,#F008B2,
    ^? @string.Join(", ", st_x)@

  ?ui_show_cd
    var cd_ui_y = 6
    >`1,@cd_ui_y@,#@colorize(mindCD, true)@,
    ^Mind @time.FormatDigital(mindCD)@
    ?have_ham
      cd_ui_y++
      >`1,@cd_ui_y@,#@colorize(hammerCD, true)@,
      ^Hammer @time.FormatDigital(hammerCD)@
    ?have_bard
      cd_ui_y++
      >`1,@cd_ui_y@,#@colorize(bardCD, true)@,
      ^Bard @time.FormatDigital(bardCD)@
    ?have_blade
      cd_ui_y++
      >`1,@cd_ui_y@,#@colorize(smiteCD, true)@,
      ^Blade @time.FormatDigital(smiteCD)@
    ?have_arm
      cd_ui_y++
      >`1,@cd_ui_y@,#@colorize(armCD, true)@,
      ^Arm @time.FormatDigital(armCD)@
    ?have_mask
      cd_ui_y++
      >`1,@cd_ui_y@,#@colorize(maskCD, true)@,
      ^Mask @time.FormatDigital(maskCD)@

  ?ui_show_debug
    cd_ui_y++
    var cd_ui_x = 1
    >`@cd_ui_x@,@cd_ui_y@,#@colorize(staffCD, 
    ^can_qs_dash())@,QS
    cd_ui_x = cd_ui_x + 2
    ?have_bashing
      >`@cd_ui_x@,@cd_ui_y@,#7A8F93,/
      cd_ui_x++
      >`@cd_ui_x@,@cd_ui_y@,#@colorize(bashCD,
      ^(!disable_bash & can_dash()))@,B
      cd_ui_x++
    ?have_dashing
      >`@cd_ui_x@,@cd_ui_y@,#7A8F93,/
      cd_ui_x++
      >`@cd_ui_x@,@cd_ui_y@,#@colorize(dashCD,
      ^can_dash())@,D

    >`1,24,#blue,Stance: @stance@
    ?foe
      >`1,14,#7A8F93,id: @foe.id@
      >`1,15,#7A8F93,State: @foe.state@
      >`1,16,#7A8F93,Time: @foe.time@
      >`1,17,#7A8F93,Dist: @foe_dist@
      >`1,18,#7A8F93,Count: @foe.count@
    >`1,25,#7A8F93,@loc.stars@* 
    ^@time.FormatDigital(totaltime)@ @foe@

    var ey = 2
    for err : errors
      >`20,@ey@,#red,@err@
      ey++

func colorize(cd, allowed)
  ?cd > 0
    return "red"
  ?!allowed
    return "FE6800"
  return "green"

func brew_pot()
  brew tar + bronze // vampiric

func reset_loop()
  ability_lock = false
  at_boss = false
  naga_step = 0
  cache.Clear()
  st_x.Clear()

?loc.begin
  // ?loc = caves | loc = halls
  //   prefer_ranged = true
  _fill_status_uids()
  _fill_items_cache()
  // ?item.potion = empty
  //   brew_pot()
:?loc.loop
  reset_loop()
:?ai.enabled & !ai.paused
  prelude()
  progress()
:
  idle()

draw_ui()
