// "scribble"
// StoneScript automation for Stone Story RPG
// Ver. 1.1
// Project: https://github.com/livercat/scribble
// by livercat

/***************
**  #Intro    **
***************/
// Some variable names are shorter
// than I would prefer for readability,
// but Mindstone has line limit of 49 chars

// I use a mix of function arguments and
// global variables for various pieces of logic.
// I would prefer not to use global vars at all
// to make it harder to miss something and easier
// to follow the logic, but since we don't
// have optional or default arguments,
// functions would have very ugly signatures.
// So func argument are used for weapon switching
// where it's important to make sure everything
// lines up correctly.

// I also use a mix of conditional branching (:?)
// and early return from functions. Early returns
// reduce line lenght and make funcs more 
// readable. They are neat!

// Main logic is in following functions:
// draw_ui() - draws UI :)
// prelude() - collects info from game state
//   into global vars
// progress() - entry point for combat logic
//   and boss handling
// fight() - main logic for choosing range and
//   type of weapons/abilities
// melee(), ranged(), aoe(), elem() - equip
//   appropriate weapons

//  *** Table of Contents ***
// You can Ctrl-F for these anchors to quickly
// go to the corresponding code
//   #Weapons - configure your weapons
//   #Settings - runtime and UI settings
//   #Progress - (verb) entry point for the rest
//               of the combat logic
//   #Combat - logic for weapon switching 
//             and ability use
//   #Abilities - granular logic and conditions
//                for abilities' prerequisites
//   #Bosses - specific boss mechanics
//   #Internals - var declarations and boring
//                internal functions
//   #Runtime - actual place where the script is 
//              executed


/***************
**  #Weapons  **
***************/
// Each elemental weapon aside from staffs
// and warhammers has two variants: "D" or "dX",
// where "X" is the elemental modifier
// ("A" and "ax" for shields).
// Staffs and warhammers instead have six! 
// "A", "D", "ax", "aX", "dx", "dX".
// You can mutate between them using moondial.

// Meaning of letters in suffix:
// "A": get armor on egage for each foe
// "D": attack bonus vs correct element
// "x": on being hit, chance to: unmake (aether),
//      fire dot, chill (ice), +attack (poison),
//      heal (vigor)
// "X": on attack, chance to: unmake (aether),
//      fire dot, chill (ice), lifesteal (vigor),
//      reduce foe attack (poison)

// Full list of suffixes:
// Defensive: staffs, warhammers, shields
//   "au", "af", "ai", "ap", "ah", "A"
// Offensive: staffs, warhammers, swords, xbows
//   "dU", "dF", "dI", "dP", "dL", "D"
// Exclusive to staffs and warhammers:
//   "aU", "aF", "aI", "aP", "aL",
//   "du", "df", "di", "dp", "dh"

// Note that vigor has 2 different letters:
// "L" for offensive lifesteal and "h" for
// defensive "heal on being hit".
// There are no "l" or "H" modifiers.

// Fill `elemental_items` with your items.
// Format:
// ["weapon type", 
//   ["element1", "suffix1", .., "suffixN"],
//   ["element2", "suffix1", .., "suffixN"],
// ]
// Only list items that you actually want to use,
// otherwise script can grab a random *0 that
// you got from a chest. Also list suffixes by
// priority: better ones first. Multiple copies
// of the same suffix for the same item
// will be ignored.
var elemental_items = [
  ["warhammer", 
    ["aether", "D"],
  ],
  ["wand", 
    ["fire", "D"],
    ["poison", "D"],
    ["vigor", "D"],
  ],
  ["sword", 
    ["aether", "D"],
    ["fire", "dF", "D"],
    ["ice", "dI"],
    ["poison", "dP"],
    ["vigor", "dL"],
  ],
  ["shield", 
    ["vigor", "ah"],
    ["poison", "ap"],
  ],
]
// Items with special abilities.
// Supported: "dashing", "bardiche", 
// "heavy hammer"
var special_items = [
  "dashing", "bardiche", "heavy hammer",
]
// Lost Items
// Supported: bashing, blade, arm
var lost_items = [
  "bashing", "blade", "arm",
]
// Weapon type to prefer for melee aoe:
// "staff", "bardiche", "heavy hammer" will 2h.
// "wands", "big swords" will dual-wield 1h.
// "" will disable melee aoe and will dual-wield
// or 1h + shield.
var melee_aoe_weapon = "bardiche"
// Weapon type to prefer for ranged aoe.
// "staff" will 2h, "wands" will dual-wield 1h.
// "" will disable ranged aoe and will 
// use `ranged_st_weapon` instead.
var ranged_aoe_weapon = "wands"
// Ranged single target weapon.
// "repeating" will 2h.
// "xbows", "wands" will dual-wield.
// "" will disable single-target ranged.
var ranged_st_weapon = "repeating"

/*********************
**     #Settings    **
*********************/
// Show ability cooldowns
var ui_show_cd = true
// Show your buffs/debuffs
var ui_show_statuses = true
// Show debug info (noisy, useful for research)
var ui_show_debug = true
// How many regular enemies are needed
// to start using AOE weapons instead of
// single target
var aoe_treshold = 4
// Low HP threshold, fraction of 1.
// When on low HP, will prioritize ah shields
// and dL weapon over matching element.
// If 1, will try to lifesteal to max (useful
// to get rid of zone cross).
// If -1, will never lifesteal.
var low_hp_threshold = 0.5
// Slower but safer, useful if you don't have 
// good melee weapons, but have a repeating xbow
var prefer_ranged = false
// Find a suitable amount based on your dI weapon
var max_chill = 6
// Set to true if you're doing Pallas quests
// for the Blade.
// Stages: "bolesh"
var smite_quest = "bolesh"
// Depends on level/enchants of the Blade
var smite_damage = 85
// At least this many enemies must be present
// to trigger Smite
var smite_treshold = 7
// Set to true if you're doing Skeleton Arm
// quests. It will prioritize pickpocketing in 
// combat, and will try to only use it when 
// non-boss foes will die from the ability.
var pickpocket_quest = false
// These depend on level/enchants of the Arm
var arm_damage = 32
var max_pickpocket = 2

/*********************
**     #Progress    **
*********************/
func progress()
  ?healwalk() // no enemies nearby
    return true
  :?foe = undamageable
    return shield_block(true)
  :?!is_boss & !at_boss
    // regular enemies
    free_mind = true
    return fight()

  // Fight bosses
  stance = "boss combat"
  ?loc = rocky
    ?loc.stars < 11
      fight_dysan()
    // TODO handle courier boss
  :?loc = deadwood
    fight_xyloalgia()
  :?loc = caves
    ?loc.stars < 11
      fight_bolesh()
    // TODO ceiling decorator
  :?loc = fungus_forest_boss
    fight_mushroom()
  :?loc = undead_crypt_boss
    fight_pallas()
  :?loc = bronze_guardian
    fight_bronze_guardian()
  :?loc = icy_ridge
    fight_hrimnir()
  :?loc = nagaraja
    fight_nagajara()
  :
    // unknown boss
    auto_melee_boss("auto")

func idle()
  stance = "out of combat"
  ?pickup.distance < 8
    equipL star
    equipR triskelion
  :?hp < maxhp
    equipL ouroboros
    equipR triskelion
  :
    equipL triskelion
    shield()
  return true

func healwalk()
  ?foe & foe_dist < 23
    ?hp < (maxhp / 4) & item.potion ! empty &
    ^(item.potion = "healing" | 
    ^item.potion = "vampiric")
      activate potion
    return false // start combat instead
  :?pickup.distance < 8
    equipL star
    equipR triskelion
  :?can_qs_dash()
    qs_dash()
  :
    idle()
  stance = "out of combat"
  return true // continue healwalking

/********************
**     #Combat    **
********************/
func fight()
  // chooses general approach to the combat
  ?foe_dist < 10 & mindCD <= 0 & foe = explode
    return backflip()
  :?phys_immune
    return auto_elemental()
  :?must_melee_foe()
    return auto_melee()
  :?ranged_st_weapon & 
  ^(prefer_ranged | must_ranged_foe())
    return auto_ranged()
  :
    return auto_melee()

func auto_melee()
  ?use_abilities()
    return true
  :?melee_aoe_weapon & can_aoe & foe_dist < 8
    return aoe("melee")
  :
    return melee("dps")

// mode: "dps" | "def"
func melee(mode)
  ?foe_dist > 16 & can_qs_dash()
    return qs_dash()
  found = get_1h_weapon("melee", false)
  ?found
    main_hand(found)
  :
    dbg("melee(" + mode +"): no weapon found")
  ?mode = "def"
    stance = "melee def"
    found = get_shield()
    ?found
      equipR @found@
    :
      dbg("melee(" + mode +"): no shield found")
  :?mode = "dps"
    stance = "melee dps"
    found = get_1h_weapon("melee", false)
    ?found
      equipR @found@
    :
      dbg("melee(" + mode +"): no offhand found")
  :
    dbg("melee(): unsupported mode=" + mode)

func auto_ranged()
  ?use_abilities()
    return true
  :?foe_dist < 10 & prefer_ranged & 
  ^can_backflip()
    return backflip()
  :?ranged_aoe_weapon & can_aoe
    return aoe("ranged")
  :
    return ranged()

func ranged()
  // "repeating" will 2h.
  // "xbows", "wands" will dual-wield.
  stance = "ranged " + ranged_st_weapon
  ?ranged_st_weapon = "repeating"
    equip @ranged_st_weapon@
    return
  :?ranged_st_weapon = "xbows"
    ty = "crossbow"
  :?ranged_st_weapon = "wands"
    ty = "wand"
  :
    dbg("ranged(): unsupported ranged_st_weapon="
    ^+ ranged_st_weapon)
    return
  found = get_1h_weapon(ty, false)
  ?found
    main_hand(found)
    found = get_1h_weapon(ty, false)
    ?found
      equipL @found@
    :
      dbg("ranged(" + ranged_st_weapon + 
      ^"): no offhand found")
  :
    dbg("ranged(" + ranged_st_weapon + 
    ^"): no weapon found")

func auto_elemental()
  ?use_abilities()
    return true
  :?foe_dist < 10 & prefer_ranged & 
  ^can_backflip()
    return backflip()
  :?low_hp
    return elemental("def")
  :
    return elemental("dps")

// mode: "dps" | "def"
func elemental(mode)
  found = get_1h_weapon("ranged")
  ?!found
    dbg("can't find elemental wand for mode=" + 
    ^mode)
    found = "wand"
  left_hand(found)
  ?mode = "def"
    stance = "elemental def"
    return offhand(mode, "shield")
  :?mode = "dps"
    stance = "elemental dps"
    return offhand(mode, "ranged")
  :
    dbg("unsupported mode for elemental(): " +
    ^mode)
    return false

// mode: "melee" | "ranged"
func aoe(mode)
  ?mode = "ranged"
    stance = "ranged aoe"
    found = get_1h_weapon("ranged")
    ?!found
      dbg("can't find aoe wand for mode=" + 
      ^mode)
      found = "wand"
    return left_hand(found) & 
    ^offhand("dps", "ranged")
  :?mode = "melee"
    ?best_wpns[t_best_2h_m]
      equip @best_wpns[t_best_2h_m]@
      return true
    :
      return melee("def")
  :
    dbg("unsupported mode for aoe(): " +
    ^mode)
    return false

func left_hand(weapon)
  _used = weapon
  equipL @weapon@
  return true

// mode: "dps" | "def"
// type: "ranged" | "melee" | "shield"
func offhand(mode, type)
  ?type ! "ranged" & dash()
    return true
  :?mode = "def"
    shield()
  :?mode = "dps"
    found = get_1h_weapon(type)
    ?found
      equipR @found@
    :
      dbg("can't find offhand for mode=" + 
      ^mode + ", type=" + type)
      shield()
  :
    dbg("unsupported mode for " +
    ^"offhand(): " + mode)
    return false
  return true

func shield()
  found = get_1h_weapon("shield")
  ?found
    equipR @found@
  :
    dbg("can't find shield")
    equipR shield
  return true

func dash()
  ?!disable_dash & 
  ^foe_dist >= 10 & foe_dist <= 16 &
  ^(bashCD <= 0 | dashCD <= 0) &
  ^can_activate()
    ?ability_wpns[bash_idx] & bashCD <= 0 &
    ^!disable_bash
      equipR @bashing@
      return true
    :?ability_wpns[dash_idx] & dashCD <= 0
      equipR @dashing@
      return true
  return false

func shield_block(stay_still)
  stance = "shield block"
  ?stay_still
    equipL quest
  shield()

func must_ranged_foe()
  return foe = mosquito | 
  ^foe = huge_mosquito | 
  ^foe = fire_elemental | foe = ant

func must_melee_foe()
  return foe = immune_to_ranged | foe = ranged | 
  ^foe = cult_guard // poisons on being hit

// mode: "dps" | "def" | "auto"
func auto_melee_boss(mode)
  ?mode = "auto"
    ?low_hp
      mode = "def"
    :
      mode = "dps"
  ?!use_abilities() // if no abilities are done
    ?!debuff(mode) // and no debuffs are needed
      return melee(mode)

// mode: "dps" | "def"
func debuff(mode)
  // note: don't bother debuffing
  // regular eneimes, it's faster to kill them
  ?foe_buffs = disable_debuff | 
  ^foe_buffs = mirror
    return false
  found = false
  ?!(foe_debuffs = foe_poisoned) &
  ^!(foe = immune_to_debuff_damage)
    found = poison_1h
  :?!(foe_debuffs = foe_on_fire) &
  ^!(foe = immune_to_debuff_dot)
    found = fire_1h
  :?!(foe_debuffs = max_chill_s) &
  ^!(foe = immune_to_debuff_chill)
    found = ice_1h
  ?found
    stance = "debuffing"
    left_hand(found)
    ?mode = "def"
      offhand(mode, "shield")
    :?mode = "dps"
      offhand(mode, "melee")
    :
      dbg("unsupported mode for " +
      ^"debuff(): " + mode)
    return true
  :
    return false

func aac(weapon)
  // attack animation cancelling:
  // equipping a different weapon
  // right after the attack cancels
  // the backswing animation,
  // effectively increasing your
  // attack speed
  ?weapon = heavy_ham
    // clips itself too much
    equip @weapon@
    return
  ?ai.idle & !berserk & !slowed
    equip wand
  equip @weapon@
  return true

/********************
**    #Abilities   **
********************/

// Note on functions below:
// can_<something>() checks hard prerequisites:
//   cooldowns, statuses, etc.
// should_<something>() checks fight logic:
//   number of enemies, statuses, etc.
// <something>() actually uses trues to use
//   the ability without doing checks itself

// quarterstaff
func can_qs_dash()
  return !dash_disabled & staffCD <= 0 & 
  ^can_activate()

// quarterstaff
func qs_dash()
  stance = "staff-dashing"
  equip quarterstaff
  ?item.CanActivate("quarterstaff")
    activate R

// Mind Stone
func can_backflip()
  // don't check this condition
  // for boss mechanics (when free_mind is false)
  return free_mind & mindCD <= 0 &
   // don't jump into the wall
  ^screen.FromWorldX(pos.x) > 5
  
// Mind Stone
func backflip()
  stance = "mind stone R"
  equipL mind
  shield()

// skeleton arm
func can_slap()
  ?!ability_wpns[arm_idx] | foe_dist > 6 |
  ^phys_immune | disable_abilities |
  ^!can_activate()
    return false
  ?pickpocket_stacks < max_pickpocket & !slowed & !low_hp
    return true // get to max buffs
  return armCD > 0 & !disable_steal &
  ^pickpocket_stacks >= max_pickpocket

// skeleton arm
func should_slap()
  return can_slap() & (!pickpocket_quest |
  ^foe_ehp <= edmg(arm_damage))

// skeleton arm
func slap()
  stance = "skeleton arm R"
  aac(arm)
  ?pickpocket_stacks >= max_pickpocket &
  ^item.CanActivate("skeleton_arm")
    activate R
  return true

// blade of the fallen god
func can_smite()
  return ability_wpns[blade_idx] & smiteCD <= 0 &
  ^!disable_abilities &
  ^foe ! pallas & // immune?
  ^can_activate()

// blade of the fallen god
func should_smite()
  return (is_boss | foe.count >= smite_treshold &
  ^foe_ehp<=edmg(smite_damage)) & can_smite()

// blade of the fallen god
func smite()
  stance = "smite R"
  aac(blade)
  ?item.CanActivate("blade")
    activate R
  return true

// heavy hammer
func can_hammer()
  return ability_wpns[ham_idx] & !phys_immune & 
  ^!disable_abilities & foe_dist <= 7 &
  ^(hammerCD <= 0 | hammerCD >= 647) &
  ^can_activate()

// heavy hammer
func should_hammer()
  return foe.armor > 0 & (is_boss | can_aoe) & 
  ^can_hammer()

// heavy hammer
func hammer()
  stance = "heavy hammer R"
  aac(heavy_ham)
  ?item.CanActivate("hammer")
    activate R
  return true

// bardiche
func can_bard()
  return ability_wpns[bard_idx] & foe_dist <= 9 &
  ^(bardCD <= 0 | bardCD >= 870) &
  ^!disable_abilities & !phys_immune &
  ^can_activate()

// bardiche
func should_bard()
  return is_boss & can_bard()

// bardiche
func bardiche()
  stance = "bardiche R"
  aac(bard)
  ?item.CanActivate("bardiche")
    activate R
  return true

func use_abilities()
  ?disable_abilities
    return false
  ?pickpocket_quest & should_slap()
    return slap() // prioritize skeleton quest
  ?should_hammer()
    return hammer()
  ?should_smite()
    return smite()
  ?should_bard()
    return bardiche()
  ?should_slap()
    return slap()
  return false

func can_activate()
  return ai.enabled & item.CanActivate()

/*****************
**    #Bosses   **
*****************/

func fight_dysan()
  ?foe = phase1
    disable_steal = true
    ?foe.state = 33 & 
    ^foe.time > 23 & foe.time < 26
      // evade big attack
      return melee("def")
    auto_melee_boss("auto")
  :?foe = phase2
    // just match elements
    disable_steal = true
    auto_melee_boss("auto")
  :?foe = phase3
    ?foe.state = 32 & foe.time > 90 |
    ^foe.state = 33 & foe.time < 2
      // prepare for attack
      return melee("def")
    :?foe.state = 115
      ?foe.time = 60
        // dodge the orb ray
        return backflip()
      :?foe.time < 80
        // don't dash into ray
        disable_dash = true
    :?foe.state = 106 | foe.state = 108 |
    ^foe.state = 0
      // transitions
      disable_abilities = true
    :?foe.state = 107 | foe.state = 32
      disable_steal = true
    auto_melee_boss("dps")

func fight_xyloalgia()
  ?foe = phase1
    // Xyloalgia
    return auto_melee_boss("auto")
  // Poena
  disable_steal = true
  ?foe.state = 32 & foe.time > 40
    shield_block(false)
  :?foe_buffs = mirror
    // try to avoid debuffing yourself
    disable_bash = true
    ?use_abilities()
      return
    ?vigor_wpns[t_1h]
      left_hand(vigor_wpns[t_1h])
      shield()
    :?aether_wpns[t_1h]
      left_hand(aether_wpns[t_1h])
      shield()
    :?best_wpns[t_1h]
      left_hand(best_wpns[t_1h])
      shield()
    :
      melee("def")
  :
    auto_melee_boss("auto")

func fight_bolesh()
  ?loc.stars > 5
    disable_steal = true
  ?foe.state = 133 &
  ^(foe.time > 12 & foe.time < 18)
    // try to evade bites
    shield_block(true)
  :?(bardCD <= 0 | bardCD >= 870) &
  ^mindCD <= 0
    auto_melee_boss("auto")
  :?mindCD <= 0 & foe_dist < 10
    backflip()
  :
    ranged("single")

func fight_mushroom()
  ?loc.stars > 5 & foe = phase1
    disable_steal = true
  auto_melee_boss("auto")

func fight_pallas()
  at_boss = true
  disable_steal = true
  ?foe.count > 4
    ?foe_dist < 15 & mindCD <= 0
      backflip()
    :
      elemental("dps")
  :
    auto_melee_boss("auto")

func fight_bronze_guardian()
  disable_steal = true
  ?foe.state = 32 & foe.time = 30
    backflip() // dodge the hammer
  :?foe.state = 33
    // hammer is down
    ?!use_abilities()
      melee("dps") // don't bother debuffing
  :?foe_dist > 15 & foe.state = 2
    ranged("single")

func fight_hrimnir()
  at_boss = true
  ?is_boss & foe.armor > 0
    // initial ice block
    ?should_slap()
      slap() // get free evade stacks
    :
      melee("dps") // don't debuff
  :?loc.stars <= 5 // try to cheese
    ?foe_dist <= 2
      ?!use_abilities()
        melee("dps") // don't debuff
    :?foe_dist <= 5
      // The shovel has an attack range of 1
      // so at white stars we can avoid
      // snowballs by getting close to boss.
      // on higher stars he blows you away
      // immediately
      equip shovel
    : // blown away
      ?slowed
        ranged("single")
      :
        auto_melee()
  :?foe.state = 143 | foe.state = 144 // blowing
    ranged("single")
  :?foe.count > 1 // deal with adds
    ?slowed // don't waste time on movement
      ?foe_dist < 7
        auto_melee()
      :?foe.count > 2
        aoe("ranged")
      :
        ranged("single")
    :?can_smite()
      smite()
    :?can_bard() & foe = ice_wall
      bardiche()
    :?foe.count > 2 // elementals
      aoe("melee")
    :
      auto_melee() // ice wall
  :?slowed
    // don't waste time on movement
    ranged("single")
  :
    auto_melee_boss("auto")

func fight_nagajara()
  disable_steal = true
  // goal is to dodge poison balls
  var x = screen.FromWorldX(pos.x)
  var y = screen.FromWorldZ(pos.z)
  // _detect_poison(x, y) // debug and research

  ?is_poison_near(x, y)
    naga_step++

  ?naga_step = 0
    // start at the xbow range
    ranged("single")
  :?naga_step = 1
    // staff 1st poison
    qs_dash()
    naga_step++
  :?naga_step = 2
    // and continue to shoot
    ranged("single")
  :?naga_step = 3
    // dash into melee
    auto_melee_boss("dps")
  :?naga_step >= 4
    ?mindCD <= 0
      // dodge back and repeat
      backflip()
      naga_step = 0
    :
      // mind stone on CD, try to def
      auto_melee_boss("def")

func is_poison_near(pos_x, pos_y)
  // long and mid range
  ?draw.GetSymbol(pos_x+2, pos_y-6) = "(" |
  // melee
  ^(draw.GetSymbol(pos_x+1, pos_y-6) = "(")
    return true
  return false

func _detect_poison(pos_x, pos_y)
  >`0,0,x=@x@, y=@y@
  for px = pos_x .. pos_x+10
    for py = pos_y-6 .. pos_y
      ?draw.GetSymbol(px, py) = "("
        cache.Add([pos_x, pos_y, px, py])
  arr_size = cache.Count()
  ?arr_size > 0
    for line = 1 .. arr_size
      var v = cache[line-1]
      >`0,@line@,x=@v[0]@, y=@v[1]@, 
      ^px=@v[2]@, py=@v[3]@;

/*********************
**     #Internals   **
*********************/
// `var`s are only initialized once per zone
// and don't reset between loops.
// We can use this to cache some calculations
// so we don't redo them every frame.
// Arrays are especially important, because 
// they're costly to initialize. 
// Use `array.Clear()` instead of `array = []`
// to reset it.

// constants
var ignore_st = [ // irrelevant statuses
  "quarterstaff_buff_attack_speed",
  "quarterstaff_buff_stun",
  "bardiche_buff_aoe_chance",
  "bardiche_buff_crit_chance",
  "bardiche_buff_crit_mult",
  "bardiche_buff_move_speed",
]
var statuses = [
^["smite", "Smite", "+"], 
^["pick_pocket", "Pickpocket", "+"],
^["vampiric", "Vamp", "+"],
^["lucky_crit_multi", "Lucky", "+"],
^["debuff_damage", "DmgDown", "-"],
^["debuff_duration_damage", "DmgDown", "-"],
^["spider_debuff_damage", "DmgDown", "-"],
^["dysangelos_debuff_damage", "DmgDown", "-"],
^["debuff_yeti_chill", "AtkSlow", "-"],
^["debuff_attack_speed", "AtkSlow", "-"],
^["debuff_move_speed", "MoveSlow", "-"],
^["debuff_chill", "Chill", "-"],
^["stun", "Stun", "-"],
^["pallas_phase2_debuff", "RangeDown", "-"],
^["debuff_dot", "FireDoT", "-"],
]
var dmg_debuffs = [
^"debuff_damage", "debuff_duration_damage",
^"spider_debuff_damage",
]
var slow_debuffs = [
^"debuff_chill", "debuff_move_speed"
]
var stun_debuff = "stun"
var max_chill_s = "❄:debuff_chill:" + 
^max_chill + ":"
var foe_poisoned = "∞:debuff_damage:1:"
var foe_on_fire = "φ:debuff_dot:1:"
var disable_debuff = "buff_protection"
var mirror = "poena_mirror"
var pickpocket_buff = "pick_pocket"

// global vars below
// misc
var at_boss = false // to deal with adds
var naga_step = 0 // nagaraja fight
// player status
var stance = "unknown" // chosen combat stance
var low_hp = false // hp < (maxhp * threshold)
var dmg_down_stacks = 0 // poison
var range_down_stacks = 0
var pickpocket_stacks = 0 // pickpocket buff
var slowed = false // is player slowed
var stunned = false // is player stunned
var berserk = false // berserk potion TODO
var can_aoe = false // foe.count >= aoe_treshold
// abilities
var free_mind = false
var disable_abilities = false
var disable_steal = false
var disable_dash = false
var disable_bash = false
// foe status
var foe_ehp = 0 // foe.armor + foe.hp
var foe_dist = 0 // foe.distance
var foe_buffs = "" // foe.buffs.string
var foe_debuffs = "" // foe.debuffs.string
var is_boss = false // foe = boss
var phys_immune = false // immune to physical
var mlem = "physical" // enemy weakness element
// cooldowns
var mindCD = 0
var staffCD = 0
var bashCD = 0
var dashCD = 0
var armCD = 0
var hammerCD = 0
var smiteCD = 0
var bardCD = 0
var maskCD = 0

// Pre-define vars for internal functions.
var found = false
var ty = false
// status handling
var splt = [] // splitted buff/debuff string
var st_uid = ""
var st_amount = 0
var st_info = []
var st_dur = 0
var st_s = ""
var st_good = [] // current buffs
var st_bad = [] // current debuffs
var st_x = [] // unknown status effects
var status_uids = []
var arr_size = 0
var idx = 0
var errors = []
var cache = []

func _fill_status_uids()
  for st_info : statuses
    status_uids.Add(st_info[0])

func some(s)
  // true if string is not empty
  return ! string.Equals(s, "")

func edmg(dmg)
  // effective damage after considering debuffs
  return dmg - dmg_down_stacks

func parse_statuses()
  st_good.Clear()
  st_bad.Clear()
  dmg_down_stacks = 0
  range_down_stacks = 0
  pickpocket_stacks = 0
  slowed = false
  berserk = false
  stunned = false
  for s : [buffs.string, debuffs.string]
    // format: *:name:count:duration,...
    splt = string.Split(s, ":", ",", false)
    arr_size = splt.Count()
    ?arr_size > 0
      // iterate over names (2nd field)
      for i = 1 .. arr_size - 3
        st_uid = splt[i]
        st_amount = int.Parse(splt[i+1])

        // flags for combat logic
        ?dmg_debuffs.IndexOf(st_uid) ! -1
          dmg_down_stacks = dmg_down_stacks + 
          ^st_amount
        :?st_uid = range_debuff
          range_down_stacks = st_amount
        :?slow_debuffs.IndexOf(st_uid) ! -1
          slowed = true
        :?st_uid = stun_debuff
          stunned = true
        :?st_uid = pickpocket_buff
          pickpocket_stacks = st_amount

        idx = status_uids.IndexOf(st_uid)
        ?idx ! -1
          st_info = statuses[idx]
          st_dur = int.Parse(splt[i+2])

          st_s = string.Format("{0}({1}) {2}",
          ^st_info[1], st_amount,
          ^time.FormatDigital(st_dur))

          ?st_info[2] = "+"
            st_good.Add(st_s)
          :
            st_bad.Add(st_s)

        :?ignore_st.IndexOf(st_uid) = -1 &
        ^st_x.IndexOf(st_uid) = -1
          // log unknown statuses for debug
          st_x.Add(st_uid)

        i = i + 3

func prelude()
  parse_statuses()

  // reset/update dynamic global vars
  disable_steal = false
  disable_dash = false
  disable_bash = false
  free_mind = false
  ?stunned
    disable_abilities = true
  :
    disable_abilities = false
  _main_hand = false
  stance = "unknown"
  low_hp = hp < (maxhp * low_hp_threshold)
  foe_ehp = foe.armor + foe.hp
  foe_dist = foe.distance - range_down_stacks
  foe_buffs = foe.buffs.string
  foe_debuffs = foe.debuffs.string
  is_boss = (foe = boss)
  phys_immune = (foe = immune_to_physical)
  can_aoe = (foe.count >= aoe_treshold) & !low_hp

  ?low_hp | foe = aether
    mlem = "vigor"
  :?foe = fire
    mlem = "aether"
  :?foe = ice
    mlem = "fire"
  :?foe = poison
    mlem = "ice"
  :?foe = vigor
    mlem = "poison"
  :
    mlem = "physical"

  mindCD = item.GetCooldown("mind")
  staffCD = item.GetCooldown("quarterstaff")
  bashCD = item.GetCooldown("bash")
  dashCD = item.GetCooldown("dash")
  armCD = item.GetCooldown("skeleton_arm")
  hammerCD = item.GetCooldown("hammer")
  smiteCD = item.GetCooldown("blade")
  bardCD = item.GetCooldown("bardiche")
  maskCD = item.GetCooldown("mask")

func dbg(e)
  ?ui_show_debug
    ?errors.IndexOf(e) = -1
      errors.Add(e)

func draw_ui()
  ?ui_show_statuses
    >`1,22,#00A300,+ @string.Join(", ", st_good)@
    >`1,23,#FE6800,- @string.Join(", ", st_bad)@
    >`1,24,#F008B2,? @string.Join(", ", st_x)@

  ?ui_show_cd
    var cd_ui_y = 6
    >`1,@cd_ui_y@,#@colorize(mindCD)@,Mind 
    ^@time.FormatDigital(mindCD)@
    ?have_hammer
      cd_ui_y++
      >`1,@cd_ui_y@,#@colorize(hammerCD)@,
      ^Hammer @time.FormatDigital(hammerCD)@
    ?have_bard
      cd_ui_y++
      >`1,@cd_ui_y@,#@colorize(bardCD)@,
      ^Bard @time.FormatDigital(bardCD)@
    ?have_blade
      cd_ui_y++
      >`1,@cd_ui_y@,#@colorize(smiteCD)@,
      ^Blade @time.FormatDigital(smiteCD)@
    ?have_arm
      cd_ui_y++
      >`1,@cd_ui_y@,#@colorize(armCD)@,
      ^Arm @time.FormatDigital(armCD)@
    ?have_mask
      cd_ui_y++
      >`1,@cd_ui_y@,#@colorize(maskCD)@,
      ^Mask @time.FormatDigital(maskCD)@

  ?ui_show_debug
    >`1,21,#blue,Stance: @stance@
    ?foe
      >`1,13,#7A8F93,+ @foe_buffs@
      >`1,14,#7A8F93,id: @foe.id@
      >`1,15,#7A8F93,State: @foe.state@
      >`1,16,#7A8F93,Time: @foe.time@
      >`1,17,#7A8F93,Dist: @foe_dist@
      >`1,18,#7A8F93,Count: @foe.count@
      >`1,25,#7A8F93,@foe@
    var ey = 2
    for err : errors
      >`15,@ey@,#red,@err@
      ey++

func colorize(cd)
  ?cd > 0 | disable_abilities
    return "red"
  return "green" // ready

func brew_pot()
  brew tar + bronze // vampiric

func reset_loop()
  at_boss = false
  naga_step = 0
  cache.Clear()
  st_x.Clear()



var type_offsets = [
  "sword", "big sword", "wand",
  "shield", "crossbow", "staff", 
  "warhammer"
  ]
var elem_offsets = [
  "aether", "fire", "ice", "poison", "vigor"
  ]
var equipment = [
  // Each element of this array is
  // [[damage/armor items], [debuff items]]
  // they're placed by equip offset, then by
  // elem offset.
  // For example: first element is aether swords, 
  // seconds is fire swords, sixth is aether 
  // big swords.
  // See also: get_item()
]
// template: "<element> <type> <suffix>"
var name_template = "{0} {1} {2}"
func _fill_items_cache()
  // add placeholders for every type+element pair
  for i = 0 .. (type_offsets.Count() * 
    ^elem_offsets.Count())
    equipment.Add([[], []])
   // `it` is 
   // ["type": ["elem", "s1", "sn"], [elem2...]]
  for it : elemental_items
    ?it.Count() > 1
      for i = 1 .. it.Count() - 1
        //`el_it` is ["elem", "s1", "sn"]
        var el_it = it[i]
        ?el_it.Count() < 2
          i++ // continue
        ty = it[0] // item type
        var elem = el_it[0] // item element
        var offset = type_offsets.IndexOf(ty) *
        ^ 5 + elem_offsets.IndexOf(elem)
        // for every suffix in list
        for j = 1 .. el_it.Count() - 1
          var suffix = el_it[j]
          // `slot` is 
          // [[dmg items], [debuff items]]
          var slot = equipment[offset]
          var full_name = string.Format(
            ^name_template, elem, ty, suffix)
          ?is_debuff(suffix) & 
            ^slot[1].IndexOf(full_name) = -1
            slot[1].Add(full_name)
          :?slot[0].IndexOf(full_name) = -1
            slot[0].Add(full_name)

var debuff_suffixes = "fFiIpPhL"
func is_debuff(suffix)
  ?string.Size(suffix) < 2
    return false
  // check second letter of the suffix
  return string.IndexOf(debuff_suffixes,
  ^string.Sub(suffix, 1, 1)) ! -1

var melee_1h_weapons = [
  "sword", "big sword", "warhammer"
]
// range: "melee" | "wand" | "crossbow"
func get_1h_weapon(range, debuff)
  ?range = "melee"
    ?foe.armor > 0
      found = get_item("warhammer", mlem, debuff)
    ?found
      return found
    :
      for ty : melee_1h_weapons
        found = get_item(ty, mlem, debuff)
        ?found
          return found
  :?range = "wand"
    return get_item("wand", mlem, debuff)
  :?range = "crossbow"
    return get_item("crossbow", mlem, debuff)
  :
    dbg("get_1h_weapon(): unsupported range="
    ^+ range)
  return false

// discriminator: "aether", "fire", "ice",
// "poison", "vigor", "armor"
func get_shield(discriminator)
  ?range = ??????
  return false

// ty: wand, sword, etc
// element: aether, fire, etc
// debuff: bool (true/false)
func get_item(ty, element, debuff)
  var offset = type_offsets.IndexOf(ty) * 5 + 
  ^elem_offsets.IndexOf(element)
  var slot = equipment[offset]
  ?!debuff
    found = _find_first(slot[0], _main_hand)
    // if D item not found, try to find dX item
  ?debuff | !found
    found = _find_first(slot[1], _main_hand)
  return found

func _find_first(arr, exclude)
  ?arr.Count() > 0
    for it : arr
      ?!exclude | !string.Equals(exclude, it)
        return it
  return false  

func main_hand(it)
  equipL @it@
  _main_hand = it

func test()
  var L = get_item("sword", "ice", false)
  dbg1(L)
  main_hand(L)
  var R = get_item("sword", "poison", true)
  dbg1(R)
  equipR @R@

_fill_items_cache()
test()
show_ui()
loc.Pause()

/****************
**   #Runtime  **
****************/
// ?loc.begin
//   _cache_ability_weapons()
//   _cache_best_weapons()
//   _cache_aether_weapons()
//   _cache_fire_weapons()
//   _cache_ice_weapons()
//   _cache_poison_weapons()
//   _cache_vigor_weapons()
//   _fill_status_uids()
//   ?item.potion = empty
//     brew_pot()
// :?loc.loop
//   reset_loop()
// :?ai.enabled & !ai.paused
//   prelude()
//   progress()
//   draw_ui()
// :
//   idle()