/* Set up your elemental and default items.
Format is:
["weapon type", 
  ["element", "item1 mods", "item2 mods"], etc]
Mods should be written exactly as in game, so
they will be equipped correctly.
Default items are used if you don't have a 
correct element against the foe, or if it's a 
non-elemental foe. Default items should be 
written as full names.
List items for the particular element in the 
order from the best to the worst. You can omit
whole elements and weapon types if you don't 
want the script to use them. */
var elemental_items = [
  ["hammer",
    ["poison", "D+8", "D+7"], // dP*9
    ["aether", "D+10", "D+8"],
    ["fire", "dF"],
    ["ice", "D+7", "dI"], // D
    // ["vigor", "dL"],
    ["default",
     "aether hammer D+10", "poison hammer D+8",
     "ice hammer D+7"],
  ],
  ["wand",
    ["poison", "dP"],
    ["vigor", "D+8", "D+7", "dL+9"],
    ["fire", "dF"], // D, *6dF
    ["ice", "dI"],
    ["default", 
    "vigor wand dL", "poison wand dP"],
  ],
  ["staff", 
    ["aether", "dU"] // *9
  ],
  ["crossbow",
    ["poison", "dP"],
    // ["aether", "D"],
    ["fire", "dF"],
    ["ice", "dI"], // D
  ],
  ["sword",
    ["poison", "D+10", "D+9", "dP"],
    ["vigor", "D+11", "D+10", "dL+10", "dL+9"],
    ["aether", "D+10", "D+9", "dU+9","dU+8"],
    ["fire", "D+11", "D+8", "dF"],
    ["ice", "D+9", "D+7", "dI"],
    ["default", 
     "fire sword D+11", "aether sword D+10",
     "ice sword D+9", "poison sword D+7"],
  ],
  ["shield",
    ["vigor", "A"],
    ["poison", "A"],
    ["ice", "A"],
    ["aether", "A"],
    ["fire", "A"],
    ["default", "compound"],
  ],
]
/* These non-elemental items can be used as
weapon types in the lists below. */
var special_weapons = ["bardiche", "blade",
"heavy hammer", "repeater", "arm"]

/* Weapon type priority for single targets:
1. First type + foe's weak element.
2. Default weapon of the first type.
3. Second type + foe's weak element.
4. Continue 1-3 until a weapon is found.
If a weapon type isn't listed here, it will not
be used. */
var for_melee_single_target = [
  "sword", "hammer",
]

/* If true, then script can use dX weapons for 
dps purposes if you don't have a D weapon of 
that element. */
var use_mods_for_dmg = false

/* How many regular enemies are needed to start
using AoE weapons instead of single target. */
var aoe_treshold = 4

/* Weapons to use for melee AoE, same priority
logic as the regular melee. */
var for_melee_aoe = ["arm"]

/* If this is set to `true`, script will prefer
to use ranged items from lists below instead of
melee. */
var prefer_ranged = false

/* Will prefer ranged weapons only for these 
enemies, but will try to get in melee if they
are near */
var prefer_ranged_foes = []

/* Will exclusively use single-target ranged
against these enemies */
var must_ranged_foes = ["wasp", "wasp nest",
"mosquito", "huge mosquito"]

/* Used for scripted bosses, for `ranged_foes`,
or when `prefer_ranged` is true. */
var for_ranged_single_target = ["crossbow", 
"repeating","wand", ]

/* Enable this _only_ if you have 10* repeating
crossbow without attack speed enchant.
Increases effective attack speed. */
var enable_repeating_aac = true

/* Weapons to use for ranged AoE. Ranged AoE is
triggered by the same threshold as melee AoE.*/
var for_ranged_aoe = ["wand", "staff"]

/* Weapons to use against `immune_to_physical`
enemies. */
var for_phys_immune = ["wand", "staff"]

/* Full name of the shield with the highest
evade%, will be used to block big boss attacks
*/
var evade_shield = "vigor shield ah"

/* Script will try to stunlock these enemies
instead of using any other tactics. Supported:
poena, ceiling decorator, ice elemental. */
var do_stunlock = [
  "poena", "ceiling decorator", "ice elemental"
]

// Full names of weapons to use for stunlocking
var stunlock_weapons = [
  "ice hammer D+7", "fire hammer dF",
  "poison hammer D", "aether hammer D"]

/* How much HP a non-boss enemy must have 
to use dU weapons on it instead of other 
tactics. If 0, will not specifically unmake. */
var unmaking_threshold = 600

/* When to debuff bosses:
"never", "always", or "smite" (only if Smite
buff is active). */
var debuff_bosses = "smite"

/* When to debuff regular enemies:
"never", "always", or "smite" (only if Smite
buff is active). */
var debuff_non_bosses = "smite"

/* If item is not listed here, its `R` ability
won't be used. Supported: dash, bash, 
bardiche, hammer, blade, skeleton_arm, mask,
quarterstaff, fire_talisman, cinderwisp. */
var useable_abilities = ["dash", "bash", 
"skeleton_arm", "mask", "blade", "hammer", 
"fire_talisman", "bardiche", "quarterstaff",
// "cinderwisp" // will spend your fire runes
]

/* Advanced: these are default values, change 
them accordingly if you have speed enchants on 
these weapons. */
var hammer_frames = 15
var bardiche_frames = 30

/* `dmg * (crit_mult + base_crit_mult)`,
script won't use the bardiche ability if 
non-boss's HP is lower than twice this damage*/
var bardiche_dmg = 52 * (7.6 + 2)

/* Use scripted potions for bosses. */
var use_potions_for_bosses = true

/* Drink crit/speed potion right at the start
of phase1 of these boss fights. Overrides 
default logic that prefers to drink during the
"hardest" phase. Supported: xylo, 
mushrooms, pallas, bronze, naga. The rest 
already drink the potion in phase1. */
var fast_potion_bosses = [
  "mushrooms", "pallas",
]

/* Fraction of HP to consider low. When on low 
HP, will prioritize `ah` shield and `dL` weapon 
over foe's elemental weakness.
If 1, will always try to lifesteal to max 
  (useful for clearing zones with full HP).
If 0, will never force lifesteal. */
var low_hp_threshold = 1

/* Switch to 1h+shield against non-boss foes
when `low_hp_threshold` is reached */
var use_shield_on_low_hp = false

// Choose amount based on your `dI` weapon
var max_chill_stacks = 6

/* When to use Cinder ability (if listed in
`useable_abilities`). Will use at max_stacks,
or if boss's HP is lower than stacks * dmg. */
var max_ignition_stacks = 10
var cinderwisp_dmg = 24

/* At least this many enemies must be present
to use Smite ability. */
var smite_treshold = 7

// Depends on level/enchants of your BFG.
var smite_damage = 90

// Enable smiting two screens at once
var long_long_smite = true

/* If you're doing the "kill unique
foes" step of the Blade of the Fallen God quest, 
fill this array with names of the
enemies you've already defeated. */
var bfg_defeated_foes = []

/* Set to true if you're doing Skeleton Arm
quests. Prioritizes last-hitting foes with the 
Arm ability */
var pickpocket_quest = false

// These depend on level/enchants of the Arm
var arm_damage = 44
var max_pickpocket_stacks = 3

/* Cultist Mask quests.
"simple" - steps 1 and 3 (uses on CD)
"prevent" - step 4: do it in Rocky. Script
will approach the scout, use mask, get hit as
long as the debuff lasts, and quit the zone. */
var mask_quest = false

// Show ability cooldowns in UI
var ui_show_cd = true

// Show your buffs/debuffs in UI
var ui_show_statuses = true

// Debug (noisy, useful for research)
var ui_show_debug = true
var enable_tracing = false
var enable_hit_tracking = false

/*********************
**     #Progress    **
*********************/
func progress()
  ?pickup.distance < 9
    // pick resources from the ground
    return equip_L("star") & equip_R("trisk")

  ?long_long_smite & smite_two_screens()
    return true
  
  ?healwalk()
    // no enemies nearby
    return true

  ?foe = explode
    return avoid_explosion()

  ?loc = caves
    check_stunlock()
  
  ?!is_boss & !at_boss
    // regular enemies
    free_mind = true
    return regular_fight()

  // Now handle bosses and minibosses

  trace("boss")
  ?loc.stars > 5 & !pickpocket_quest
    /* don't use Arm on bosses unless
    absolutely necessary */
    disable_r("skeleton_arm")

  ?loc = rocky
    ?foe.id = "acronian_scout"
      trace("miniboss")
      return fight_scout()
    return fight_dysan()

  :?loc = deadwood
    return fight_xyloalgia()

  :?loc = caves
    ?is(foe.id, "cool_bat")
      trace("miniboss")
      ?can_stunlock & 
      ^do_stunlock.Contains("ceiling decorator")
        disable_r("mask")
        disable_r("blade")
        disable_r("bardiche")
        return stunlock()
      return auto_melee_miniboss()
    :
      return fight_bolesh()
  
  :?loc = fungus_forest_boss
    return fight_mushrooms()
  
  :?loc = mushroom & is(foe.id, "epic_snail")
    return disable_r("hammer") & 
    ^disable_r("bash") & auto_melee_miniboss()

  :?loc = undead_crypt_boss
    return fight_pallas()
  
  :?loc = halls
    trace("miniboss")
    return ranged("aoe")

  :?loc = bronze_guardian
    return fight_bronze_guardian()

  :?loc = icy_ridge
    ?foe.id = "ice_elemental_elite"
      ?!at_boss
        trace("miniboss")
        ?can_stunlock & 
        ^do_stunlock.Contains("ice elemental")
          disable_r("mask")
          disable_r("blade")
          disable_r("hammer")
          return stunlock()
        :
        return auto_melee_miniboss()
      :
        return ranged("aoe")
    return fight_hrimnir()

  :?loc = temple & 
  ^is(foe.id, "acronian_cultist")
    trace("miniboss")
    excluded_items = "vigor"
    return auto_melee_miniboss()

  :?loc = nagaraja
    return fight_nagaraja()

  :
    dbg("Fighting unknown boss: " + foe.id)
    auto_melee_boss()

func healwalk()
  trace("healwalk")
  ?foe & (foe.distance < 23)
    ?hp < (maxhp / 4) & item.potion ! empty &
    ^(item.potion = "healing" | 
    ^item.potion = "vampiric")
      activate potion
    return false // start combat instead
  :?should_summon()
    return equip_L("trisk") & summon()
  :?can_qs_dash()
    return qs_dash()
  auto_equip_shield()
  ?hp < maxhp
    return equip_L("ouroboros")
  return equip_L("trisk")

func avoid_explosion()
  trace("explode")
  ?foe.distance < 5
    return try_evade()
  return auto_equip_L("melee", false) & 
  ^equip_R("dashing")

var scrolling = 0
func smite_two_screens()
  var cd_ok = get_cd("blade") <= 0
  ?cd_ok & foe.count > 3
    scrolling++
    screen.Next()
  :
    scrolling = 0
    screen.ResetOffset()
  ?foe_ehp < 600 & foe_ehp > 0 & cd_ok & 
  ^foe.distance < 25 & 
  ^(foe.count > 5 | scrolling > 15)
    return smite()
  return scrolling > 0

/*****************
**    #Bosses   **
*****************/
  
func try_evade()
  trace("try_evade")
  ?can_mind
    set_lock("mind", 2)
    return backflip()
  return hard_block()

func hard_block()
  trace("hard_block")
  return equip_L("quest") & 
  ^equip_R(evade_shield)

func evade_at(t)
  trace("evade_at")
  ?foe.time >= t
    return try_evade()
  ?foe.time < t & get_cd("mind")<=(t-foe.time)
    // abilities that would be interrupted
    ?foe.time > (t - bardiche_frames)
      disable_r("bardiche")
    ?foe.time > (t - hammer_frames)
      disable_r("hammer")
  return false

func soft_block()
  trace("soft_block")
  ?lock // don't interrupt abilities
    return false
  return equip_R(evade_shield)

func around(t)
  return foe.time > (t-2) & foe.time < (t+2)

func fight_scout()
  ?is(mask_quest, "prevent")
    equip_L("trisk")
    ?foe.state = 32 & foe.time>11 & can_mask()
      return mask()
    ?get_cd("mask") > 0 & 
    ^!foe_debuff("debuff_feeble")
      return loc.Leave()
    ?have_dashing
      equip_R("dashing")
    return
  :
    auto_melee_miniboss()

var last_state = 0
var dysan_step = -1
func fight_dysan()
  disable_r("skeleton_arm")
  var delay = chill_delay()
  var hit = 28
  ?loc.stars > 10
    hit = 22
  ?foe = phase1
    disable_r("blade")
    maybe_drink()
    ?(foe.state = 33 & foe.time = 23) |
    ^(foe.state = 32 & around(hit + delay))
      return soft_block()
  :?foe = phase2
    ?smite_at_exact() | dash_closer() |
    ^(foe.state = 33 & use_abilities())
      return true
    trace("match_element")
    found = find_weapon("melee",false,
    ^weak_elem,"stats","false")
    ?found
      equip_L(found)
    ?foe.state = 32 & around(58 + delay)
      return soft_block()
    found = false
    ?should_debuff()
      found = find_debuff_weapon("melee",
      ^false, debuff_elems[0], false)
    ?found
      return equip_R(found)
    return auto_equip_R("melee", false)
  :?foe = phase3
    weak_elem = "default"
    hit = 20 + math.Max(0, delay-6)
    // hammer him right as he gets armor
    ?foe.state=32 & foe.time>hit & dysan_step=0
    ^& foe.distance > 10 & can_hammer()
      return hammer()
    // don't use element he's guarding against
    var resist = foe_buff("adaptive_defense")
    ?!(low_hp & is(resist, "vigor"))
      excluded_items = resist
    /* his attack order is cyclical, so we can
    dodge both the stun and the ray */
    ?(last_state = 32 & foe.state = 33) |
    ^(last_state = 33 & foe.state = 2) |
    ^(last_state = 2 & foe.state = 32)
      dysan_step++
    :?(foe.state!32) & (foe.state!33) &
    ^(foe.state!2)
      dysan_step = 0
    last_state = foe.state
    ?foe.state = 32 & dysan_step >= 6 & 
    ^evade_at(hit)
      // dodge the stun
      dysan_step = 0
      return 
    :?foe.state=115 & foe.time<=70 & 
    ^evade_at(70)
      // dodge the ray, don't dash back into it
      return set_lock("boss", 7)
    :?foe.state = 32 & (dysan_step < 7) & 
    ^around(48 + delay)
      return soft_block()
  auto_melee_boss()

func fight_xyloalgia()
  disable_r("skeleton_arm")
  var stunlock_poena = loc.stars > 5 &
  ^can_stunlock & do_stunlock.Contains("poena")
  ?foe = phase1
    ?fast_potion_bosses.Contains("xylo")
      maybe_drink()
    ?stunlock_poena
      // save abilities for poena
      disable_r("mask")
      disable_r("hammer")
      disable_r("blade")
      disable_r("bardiche")
    
    ?foe.state = 32 & 
    ^evade_at(31 + chill_delay())
      return

    auto_melee_boss()
  :?foe = phase2
    ?unsummon()
      return
    ?disable_debuffs
      excluded_items = "dU"
    ?stunlock_poena
      stunlock()

    // no stunlocking, avoid hitting the mirror
    :?(disable_debuffs & foe.hp>(foe.maxhp/4))|
    ^(foe.state = 32 & foe.time = 41)
      hard_block()
    :
      auto_melee_boss()

func fight_bolesh()
  /* Get close, debuff/use abilities, then
  jump to ranged before the first melee bite,
  and continue shooting and blocking. */
  ?foe.state = 133 & (around(11) | around(16))
    //block the bite and don't move from ranged
    hard_block()

  :?foe.state = 142 & evade_at(60)
    // evade melee bite
    return

  :?can_mind &
  ^!foe_buff("spider_buff_damage")
    maybe_drink()
    return use_abilities() |
    ^auto_melee_boss()
  :
    ?for_ranged_single_target.
    ^Contains("repeating")
      return equip_L("repeating")
    ranged("single")

func fight_mushrooms()
  // thanks to user `fruloo` from the discord!
  var delay = chill_delay()
  ?foe = phase1
    ?fast_potion_bosses.Contains("mushrooms")
      maybe_drink()
    disable_r("skeleton_arm")
    ?foe.state = 32 & evade_at(46 + delay)
      return
    :?foe.state = 33 & foe.time=foe.distance+4
      return soft_block() // pellets
  :?foe = mushroom_boss_fat
    maybe_drink()
    ?foe.state = 32 & evade_at(26 + delay)
      return
  auto_melee_boss()

func fight_pallas()
  disable_r("skeleton_arm")
  ?foe = phase1
    ?fast_potion_bosses.Contains("pallas")
      maybe_drink()
    ?foe.state = 32 & foe.time = 68
      soft_block()
    :
      auto_melee_boss()
  :?foe = phase2
    maybe_drink()
    ?foe.count > 2
      return ranged("aoe") // deal with ghosts
    auto_melee_boss()

func fight_bronze_guardian()
  ?fast_potion_bosses.Contains("bronze")
    maybe_drink()
  ?foe.state = 32 & foe.time = 33 &
  ^armor < foe.damage
    backflip() // dodge the hammer
  :?foe.state = 33 // hammer is down
    maybe_drink()
    auto_melee_boss()
  :
    ranged("single")

func fight_hrimnir()
  at_boss = true
  ?is_snowball_near() | 
  ^(is_boss & foe.distance <= 6 & 
  ^foe.state = 32 & around(23 + chill_delay()))
    // snowballs
    ?useable_abilities.Contains("fire_talisman")
      equip_L("fire talisman")
    soft_block()
  :?draw.GetSymbol(56, 13) = "o" | is_boss & 
  ^foe.state = 133 // blowing
    ?foe.count > 1
      ranged("aoe")
    :
      ranged("single")
  :?is_boss & foe.state = 132 & foe.time > 24
    set_lock("boss", 2) // preparing to blow
    auto_melee_boss()
  :?is_boss & foe.state = 142 & foe.time > 83
    set_lock("boss", 2) // blowing + summons
    ?foe.count > 1
      ranged("aoe")
    :
      ranged("single")
  :?is_boss & foe.count = 1
    ?foe.armor > 0
      ?can_hammer()
        return hammer()
      return melee("dps")
    maybe_drink()
    auto_melee_boss()
  :?foe.distance < 8
    auto_melee()
  :
    auto_melee_boss()

var dists = [3, 4]
func is_snowball_near()
  var x = screen.FromWorldX(pos.x)
  var y = screen.FromWorldZ(pos.z)
  for dist : dists
    ?draw.GetSymbol(x+dist, y-3) = "(" &
    ^draw.GetSymbol(x+dist+1, y-3) = "_" & 
    ^draw.GetSymbol(x+dist+2, y-3) = ")"
      return true
  return false

var naga_step = 0
func fight_nagaraja()
  ?fast_potion_bosses.Contains("naga")
    maybe_drink()
  var to_dodge = 1
  ?loc.stars > 10
    to_dodge = 4
  :?loc.stars > 5
    to_dodge = 2
  // dodge poison balls & plink away
  ?is_poison_near()
    ?naga_step <= to_dodge
      // we're still at range, use qs
      ?can_mind & foe.distance < 12
        naga_step = 0
        maybe_drink()
        auto_melee_boss()
      :
        naga_step++
        qs_dash()
    :
      // now we're in melee
      evade_naga()
  // boulder
  :?foe.state = 112 & foe.time = 59 & 
  ^foe.distance < 10
    evade_naga()
  :?naga_step <= to_dodge
    /* to split-frame dash with quarterstaff,
    we need to be equipped with a 2h weapon the
    frame before. So we try not to use wands if
    possible. */
    ?use_abilities()
      return
    ?foe.state = 32 | foe.state = 33 | 
    ^((foe.state = 101 | foe.state = 112) 
    ^& foe.time < 20)
      excluded_items = "wand"
      found =find_dps_weapon("ranged",false,true)
      ?found
        return equip_L(found)
      excluded_items = false
    ranged("single")
  :
    maybe_drink()
    auto_melee_boss()

func evade_naga()
  ?can_mind
    naga_step = 0
    return backflip() // dodge back
  :
    return soft_block() // try to block

func is_poison_near()
  var x = screen.FromWorldX(pos.x)
  var y = screen.FromWorldZ(pos.z)
  // long and mid range
  return draw.GetSymbol(x+2, y-6) = "(" |
  // melee
  ^(draw.GetSymbol(x+1, y-6) = "(")

/********************
**     #Combat    **
********************/

func regular_fight()
  trace("fight")

  ?must_ranged_foe()
    return ranged("single")

  ?foe = immune_to_ranged | foe = ranged
    return auto_melee()

  ?prefer_ranged_foe() & can_aoe & 
  ^foe.distance > melee_aoe_range
    return auto_ranged()

  ?prefer_ranged
    return (can_backflip() & backflip()) |
    ^auto_ranged()

  // by default, use melee
  return auto_melee()

func must_ranged_foe()
  for enemy: must_ranged_foes
    ?foe = enemy
      return true

func prefer_ranged_foe()
  for enemy: prefer_ranged_foes
    ?foe = enemy
      return true

func auto_melee()
  trace("auto_m")
  ?use_abilities()
    return true
  :?can_aoe & foe.distance <= melee_aoe_range
    return melee("aoe")
  :?low_hp & use_shield_on_low_hp
    return melee("def")
  return melee("dps")

// mode: "dps" | "def" | "aoe"
func melee(mode)
  trace("m_" + mode)
  ?dash_closer()
    return true
  var aoe = is(mode, "aoe")
  ?should_unmake()
    ?try_equip_unmake("melee", aoe)
      trace("unmaking")
      mode = "unmake"
      return approach()
  :?should_debuff()
    ?try_equip_debuff("melee", aoe)
      trace("debuff")
      mode = "debuff"
      return approach()
  ?is(mode, "def")
    auto_equip_L("melee", false)
    ?use_shield_on_low_hp
      auto_equip_shield()
    auto_equip_R("melee", false)
  :
    auto_equip_dps("melee", aoe)
  return approach()

func approach()
  var range = 6
  ?found_type
    range = get(weapon_ranges, found_type) + 1
  ?foe.distance > range
    trace("approach")
    // use a shield while walking closer
    ?!is_2hander(found_type)
      auto_equip_shield()
  return true

func dash_closer()
  trace("dash_closer")
  ?can_dash()
    return dash()
  :?should_qs_dash()
    return qs_dash()
  return false  

func auto_ranged()
  trace("auto_r")
  ?use_abilities()
    return true
  :?can_aoe & for_ranged_aoe.Count() > 0 & 
  ^foe.distance <= ranged_range
    return ranged("aoe")
  :?for_ranged_single_target.Count() > 0
    return ranged("single")
  return auto_melee()

// mode: aoe | single
func ranged(mode)
  trace("r_" + mode)
  var aoe = is(mode, "aoe")
  ?!aoe & must_ranged_foe() & 
  ^for_ranged_single_target.
  ^Contains("repeating")
    return equip_L("repeating")
  ?should_unmake()
    ?try_equip_unmake("melee", aoe)
      trace("unmaking")
      mode = "unmake"
  :?should_debuff()
    ?try_equip_debuff("ranged", aoe)
      return
  return auto_equip_dps("ranged", aoe)

func auto_melee_boss()
  trace("auto_m_boss")
  ?use_abilities() | dash_closer()
    return true
  ?should_unmake() & 
  ^try_equip_unmake("melee", false)
    trace("unmaking")
    return approach()
  :?should_debuff()
    ?try_equip_debuff("melee", false)
      trace("debuff")
      return approach()
  auto_equip_dps("melee", false)
  return approach()

func auto_melee_miniboss()
  trace("auto_m_miniboss")
  return disable_r("blade") & 
  ^disable_r("mask")&disable_r("cinderwisp") &
  ^auto_melee()

var can_stunlock = do_stunlock.Count() > 0 &
^stunlock_weapons.Count() > 0

func check_stunlock()
  ?can_stunlock & foe.id ! "cool_bat" & 
  ^do_stunlock.Contains("ceiling decorator")
    // save the stun for the bat
    disable_r("hammer")

func stunlock()
  trace("stunlock")
  disable_r("skeleton_arm")
  ?dash_closer()
    return true
  ?disable_debuffs
    return maybe_drink() & melee("dps")
  /* Now stunlock, and use abilities when
  it's safe */
  var stunned = foe_debuff("stun")
  ?(can_hammer() & foe.distance <= 17) |
  ^is(lock, "hammer")
    return hammer() // long stun
  :?(stunned > bardiche_frames + 10) &
  ^should_bard() | is(lock, "bardiche")
    return bardiche()
  :?stunned > 10
    ?should_cinder()
      return cinder()
    ?should_smite()
      return smite()
    ?should_mask()
      return mask()
  :?stunned <= 3
    ?get_cd("bash") <= 0 & foe.distance < 10 &
    ^foe_ehp > 100 & can_backflip() 
      return backflip()
    ?can_qs_dash()
      return qs_dash()
  // default stunlock action
  found = false
  for it : stunlock_weapons
    ?!found & !(it = excluded_items) &
    ^!(it = foe_elem)
      found = it
  ?found
    equip_L(found)
  :
    equip_L(stunlock_weapons[0])
  found = false
  ?should_unmake()
    found = find_unmake_weapon("melee", 
    ^false, false)
  :?should_debuff()
    found = find_debuff_weapon("melee",
    ^false, debuff_elems[0], false)
  ?found
    equip_R(found)
  :
    auto_equip_R("melee", false)

/**********************
** #Weapon switching **
**********************/

var _equip_L = false
func equip_L(it)
  // sets global flag, so the next `get_item()`
  // in this frame won't return the same item
  _equip_L = it
  ?is_2hander(it) | is_2hander(found_type)
    return aac(it)
  equipL @it@
  return it

var _equip_R = false
func equip_R(it)
  // for debug
  _equip_R = it
  ?is_2hander(it) | is_2hander(found_type)
    return aac(it)
  equipR @it@
  return it

func is_2hander(ty)
  return ty & all_2h_types.Contains(ty)

// range: "melee" | "ranged"
// aoe: true/false
func auto_equip_L(range, aoe)
  trace("auto_eq_L")
  found = find_dps_weapon(range, aoe, true)
  ?found
    return equip_L(found)
  return false

// range: "melee" | "ranged"
// aoe: true/false
func auto_equip_R(range, aoe)
  trace("auto_eq_R")
  found = find_dps_weapon(range, aoe, false)
  ?found
    return equip_R(found)
  return auto_equip_shield()

func auto_equip_shield()
  trace("auto_eq_sh")
  found = false
  found_type = false
  ?low_hp
    found=get_item("shield", "vigor", "mod")
  ?!found
    found=get_item("shield",weak_elem,"stats")
  ?!found
    found=get_item("shield", "default", "")
  ?found
    return equip_R(found)
  return false
  
// range: "melee" | "ranged"
// aoe: true/false
func auto_equip_dps(range, aoe)
  trace("auto_eq_dps")
  found = find_dps_weapon(range, aoe, true)
  ?!found
    return false
  equip_L(found)
  ?is_2hander(found_type)
    return found
  found = find_dps_weapon(range, aoe, false)
  ?found
    return equip_R(found)
  return false

func find_dps_weapon(range, aoe, allow_2h)
  trace("find_dps_weapon")
  found = false
  ?low_hp
    // heal on low hp
    found = find_weapon(range, aoe, 
    ^"vigor", "mod", allow_2h)
  ?!found
    // default case: match element
    found = find_weapon(range, aoe, 
    ^weak_elem, "stats", allow_2h)
  trace(""+found)
  return found

func try_equip_debuff(range, aoe)
  trace("try_eq_debuff")
  found = false
  for elem:debuff_elems
    found = find_debuff_weapon(range, aoe,
    ^elem, !_equip_L)
    ?found
      ?!_equip_L
        equip_L(found)
        ?is_2hander(found_type)
          return true
      :?!_equip_R
        ?low_hp
          return auto_equip_R(range, aoe)
        return equip_R(found)
  ?_equip_L
    ?!_equip_R
      return auto_equip_R(range, aoe)
  :
    trace("no_debuff_weapon")
    return false
  return true

func find_debuff_weapon(range, aoe, 
^elem, allow_2h)
  trace("find_debuff_wep")
  found = find_weapon(range, aoe, 
  ^elem, "mod", allow_2h)
  ?!found & range = "melee" & 
  ^!(foe = immune_to_ranged | foe = ranged)
    found = find_weapon("ranged", aoe, elem, 
    ^"mod", allow_2h)
  return found

func try_equip_unmake(range, aoe)
  trace("try_eq_unmake")
  ?prefer_ranged & foe.distance > melee_range
    range = "ranged"
  found = find_unmake_weapon(range,aoe,true)
  ?!found
    trace("no_unmake_weapon")
    return false
  equip_L(found)
  ?is_2hander(found_type)
    return true
  ?low_hp
    return auto_equip_R(range, aoe)
  found = find_unmake_weapon(range,aoe,false)
  ?found
    return equip_R(found)
  return auto_equip_R()

func find_unmake_weapon(range, aoe, allow_2h)
  trace("find_unmake_wep")
  found = find_weapon(range, aoe, 
  ^"aether", "mod", allow_2h)
  ?!found & range = "melee"
    found = find_weapon("ranged", aoe, 
    ^"aether", "mod", allow_2h)
  return found

func find_weapon(range, aoe, elem, 
^purpose, allow_2h)
  found = false
  found_type = false
  var types = get_preferred_types(range, aoe)
  for ty : types
    ?allow_2h | !is_2hander(ty)
      ?!elem_types.Contains(ty) & 
      ^!is(purpose, "mod")
        found_type = ty
        return ty
      found = get_item(ty, elem, purpose)
      ?!found & purpose = "stats"
        ?use_mods_for_dmg
          found = get_item(ty, elem, "mod")
        ?!found
          found = get_item(ty, "default", "")
      ?found
        found_type = ty
        return found
  return false

func get_preferred_types(range, aoe)
  ?phys_immune | 
  ^(can_aoe & foe = magic_vulnerability)
    return for_phys_immune
  var types = for_melee_single_target
  ?is(range, "melee")
    ?foe.armor > 0
      ?aoe
        types = aa_aoe_types
      :
        types = aa_st_types
    :?aoe
      types = for_melee_aoe
  :
    ?aoe
      types = for_ranged_aoe
    :
      types = for_ranged_single_target
  return types

var excluded_items = ""
func get_item(ty, elem, purpose)
  var h
  ?is(elem, "default")
    h = hash([ty, "default"])
  :
    h = hash([ty, elem, purpose])
  var items = try_get(all_items, h, false)
  ?!items | items.Count() = 0
    return false
  for it : items
    ?(!_equip_L | !is(it, _equip_L)) &
    ^(!excluded_items | !(it = excluded_items))
      return it
  return false

func should_unmake()
  return unmaking_threshold > 0 & !is_boss & 
  ^foe.maxhp >= unmaking_threshold

var only_dot = false
func can_debuff()
  only_dot = false
  ?disable_debuffs
    return false
  ?is_boss
    ?is(debuff_bosses, "never")
      return false
    ?is(debuff_bosses,"smite") & smite_stacks=0
      ?loc = Rocky // always debuff Scout&Dysan
        return true
      ?can_be_debuffed("debuff_dot")
        only_dot = true // keep up the dot
        return true
      return false
  ?!is_boss & (is(debuff_non_bosses, "never") |
  ^is(debuff_non_bosses,"smite")&smite_stacks=0)
    return false
  return true

var disable_debuffs = false
var debuff_elems = []

func should_debuff()
  ?!can_debuff()
    return false
  debuff_elems.Clear()
  ?can_be_debuffed("debuff_dot")
    debuff_elems.Add("fire")
    ?only_dot
      return true
  ?can_be_debuffed("debuff_chill")
    debuff_elems.Add("ice")
  ?can_be_debuffed("debuff_damage")
    debuff_elems.Add("poison")
  var c = debuff_elems.Count()
  ?c > 1 & 
  ^foe = debuff_elems[0]
    var move = debuff_elems[0]
    debuff_elems.Emplace(0, debuff_elems[c-1])
    debuff_elems.Emplace(c-1, move)
  return c > 0

func can_be_debuffed(debuff_uid)
  ?(foe = "immune_to_" + debuff_uid)
    return false
  ?is(debuff_uid, "debuff_chill")
    var c = foe_debuff("debuff_chill")
    return c < max_chill_stacks
  return !foe_debuff(debuff_uid)

/********************
**    #Abilities   **
********************/

func get_cd(ability)
  return try_get(cooldowns, ability, 9999)

func allowed(ability)
  return try_get(abilities, ability, false)

func set_lock(tag, timer)
  ?!lock | (is(tag,"boss") & lock_timer<timer)
    lock = tag
    lock_timer = timer
  return true

func can_use(ability)
  ?lock
    return is(lock, ability)
  return allowed(ability)

func can_activate()
  return ai.enabled & item.CanActivate()

func use(ability)
  ?item.CanActivate(ability)
    activate R
  return true

func maybe_drink()
  ?use_potions_for_bosses & 
  ^(item.potion="berserk"|item.potion="lucky")
  ^& foe.distance<=melee_range
    trace("drink")
    activate potion
  return true

func can_dash()
  return can_activate() & (can_use("dash") | 
  ^can_use("bash") & !disable_debuffs)
  ^& foe.distance > 10 & foe.distance < 17

func dash()
  trace("dash")
  ?!disable_debuffs & can_use("bash")
    trace("bashing")
    return equip_R("bashing")
  :?can_use("dash")
    trace("dashing")
    return equip_R("dashing")
  return false

func can_qs_dash()
  return can_use("quarterstaff") & 
  ^can_activate()

func should_qs_dash()
  return (prefer_ranged & foe.distance > 28) |
  ^(foe.distance > 16 | 
  ^foe.distance < 11 & foe.distance > 5) & 
  ^can_qs_dash()

func qs_dash()
  trace("qs_dash")
  equip_L("quarterstaff")
  return use("quarterstaff")
    
func can_backflip()
  return can_use("mind") & free_mind &
   // don't jump into the wall
  ^screen.FromWorldX(pos.x) > 5
  
func backflip()
  trace("backflip")
  auto_equip_shield()
  return equip_L("mind")

func can_slap()
  return can_use("skeleton_arm") & 
  ^!(foe.id = "ice_pillar") &
  ^foe.distance < 7 & !phys_immune &
  ^can_activate()

func should_slap()
  return can_slap() & (!pickpocket_quest |
  ^foe_ehp <= arm_damage)

func slap()
  trace("slap")
  ?pickpocket_stacks < max_pickpocket_stacks
    return aac("arm")
  equip_L("arm")
  return use("skeleton_arm")

func can_smite()
  return can_use("blade") & 
  ^foe.distance <= 20 & (foe ! pallas) &
  ^can_activate()

func should_smite()
  ?bfg_defeated_foes.Count() > 0
    ?foe_ehp<=smite_damage & can_smite()
      for e : bfg_defeated_foes
        ?foe = e
          return false
      return true
    return false
  return (is_boss | foe.count >= smite_treshold
  ^& foe_ehp <= smite_damage) & can_smite()

func smite()
  trace("smite")
  equip_L("blade")
  return use("blade")

func smite_at_exact()
  disable_r("blade")
  ?foe.hp<=smite_damage & get_cd("blade")<=0
    return smite()
  return false

func can_hammer()
  return can_use("hammer") & !phys_immune & 
  ^foe.distance <= 21 & can_activate()

func should_hammer()
  ?!can_hammer()
    return false
  return is(lock, "hammer") | 
  ^(is_boss | can_aoe & foe.distance<15)
  ^& (foe.armor > 0 | foe = spawner | 
  ^can_debuff() & 
  ^!(foe = immune_to_stun))

func hammer()
  trace("hammer")
  set_lock("hammer", hammer_frames)
  equip_L("heavy hammer")
  return use("hammer")

func can_bard()
  return can_use("bardiche") & 
  ^foe.distance <= 9 & !phys_immune &
  ^can_activate()

func should_bard()
  return is(lock, "bardiche") | is_boss &
  ^!aspd_down & (foe_ehp >= (bardiche_dmg * 2)|
  ^foe_ehp < bardiche_dmg) & can_bard()

func bardiche()
  trace("bardiche")
  set_lock("bardiche", bardiche_frames)
  equip_L("bardiche")
  return use("bardiche")

func can_mask()
  return can_use("mask") &
  ^(foe ! nagaraja) & can_activate()

func should_mask()
  return can_mask() & (is(mask_quest,"simple")|
  ^is_boss & foe.distance <= melee_range) &
  ^!disable_debuffs & can_debuff()

func mask()
  trace("mask")
  equip_R("mask")
  return use("mask")

func can_summon()
  return (summon.GetId() ! "cinderwisp" |
  ^lock="fire_talisman") &
  ^can_use("fire_talisman") & can_activate()

func should_summon()
  return (foe.id ! "poena") & can_summon()

var fire_frames = 20

func summon()
  trace("summon")
  set_lock("fire_talisman", fire_frames)
  equip_R("fire talisman")
  return use("fire_talisman")

func unsummon()
  trace("unsummon")
  ?summon.count > 0
    equip_R("fire talisman")
    return use("fire_talisman")
  return false

func can_cinder()
  return summon.GetId() = "cinderwisp" &
  ^can_use("cinderwisp") & can_activate()

func should_cinder()
  return is_boss & can_cinder() & 
  ^(summon.GetVar("ignition", 0) >= 
  ^max_ignition_stacks | foe_ehp <=
  ^max_ignition_stacks * cinderwisp_dmg)

func cinder()
  trace("cinder")
  activate cinderwisp
  return true

func use_abilities()
  trace("use_abilities")
  // prioritize quests
  ?is(mask_quest,"simple") & can_mask()
    return mask()
  ?pickpocket_quest & can_slap()
    return slap()
  // then use where needed
  ?should_cinder()
    return cinder()
  ?should_mask()
    return mask()
  ?should_hammer()
    return hammer()
  ?should_smite()
    return smite()
  ?should_bard()
    return bardiche()
  ?should_slap()
    return slap()
  return false

var aac_tick = 1

func aac(weapon)
  _equip_L = weapon
  equip @weapon@
  ?!ai.idle
    return true
  ?is(lock, "hammer") | 
  ^is(lock, "bardiche")
    return true
  ?weapon = "repeating"
    ?!enable_repeating_aac
      return weapon
    aac_tick--
    ?aac_tick = 0
      aac_tick = 2
      equip blade
      equip @weapon@
    return weapon
  // TODO
  ?weapon = "wand" | weapon = "staff"
    return true
  equip wand
  equip @weapon@
  return weapon

/*********************
**     #Internals   **
*********************/
var elem_types = ["sword", "big sword", "wand",
"shield", "crossbow", "staff", "hammer"]
var all_2h_types = ["bardiche", "arm", "blade",
"heavy hammer", "repeating", "staff",
"quarterstaff", "shovel", "crossbow"]
var ranged_2h_types = ["repeating", "crossbow",
"staff"]
var al_elems = ["aether", "fire", "ice", 
"poison", "vigor"]
var aa_st_types = []
var aa_aoe_types = []
var all_items = [/*
hash, [weapon1, weapon2,], hash, [weapon3], ...
for example:
sword-aether-stats, [aether sword D],
hammer-fire-mod, [fire hammer dF],
wand-default, [stone wand + 10],
*/]

func _prepare_items()
   // [type, [elem, s1, sn], [elem2...]]
  for item_type : elemental_items
    ?item_type.Count() > 1
      var ty = item_type[0]
      // for each element
      for i = 1 .. item_type.Count() - 1
        var suffixes = item_type[i]
        ?suffixes.Count() > 1
          // suffixes: ["elem", "s1", "sn"]
          _categorize_item(ty, suffixes)
  for a : [
  ^[for_melee_single_target, aa_st_types],
  ^[for_melee_aoe, aa_aoe_types]]
    var source = a[0]
    var dest = a[1]
    ?source.Contains("heavy hammer")
      dest.Add("heavy hammer")
    ?source.Contains("hammer")
      dest.Add("hammer")
    for w : source
      ?!(w = "hammer")
        dest.Add(w)

func _categorize_item(ty, suffixes)
  var elem = suffixes[0]
  for j = 1 .. suffixes.Count() - 1
    var suffix = suffixes[j]
    ?is(elem, "default")
      add_item(hash([ty, "default"]), suffix)
    :
      var purpose = get_purpose(suffix)
      // remove extra spaces from the suffix
      suffix = string.Join("", 
      ^string.Split(suffix))
      var full_name = string.Join(" ", 
      ^[elem, ty, suffix])
      var h = hash([ty, elem, purpose])
      add_item(h, full_name)

func hash(parts)
  return string.Join("-", parts)

var elem_mods = ["f", "F", "i", "I", 
"p", "P", "h", "L", "u", "U"]

func get_purpose(suffix)
  ?string.Size(suffix) > 1 &
  ^elem_mods.Contains(string.Sub(suffix, 1, 1))
    return "mod"
  return "stats"

func add_item(hash, _name)
  var idx = all_items.IndexOf(hash)
  var arr
  ?idx = -1
    arr = [_name]
    all_items.Add(hash)
    all_items.Add(arr)
  :
    arr = all_items[idx + 1]
    ?!arr.Contains(_name)
      arr.Add(_name)

var all_statuses = [
  ["berserk", "Berserk", "+"], 
  ["smite", "Smite", "+"], 
  ["pick_pocket", "Pickpocket", "+"],
  ["vampiric", "Vamp", "+"],
  ["lucky_crit", "CritUp", "+"],
  ["lucky_mult", "CritMultUp", "+"],
  ["invisibility", "Invis", "+"],
  ["debuff_damage", "DmgDown", "-"],
  ["debuff_duration_damage", "DmgDown", "-"],
  ["spider_debuff_damage", "DmgDown", "-"],
  ["dysangelos_debuff_damage", "DmgDown", "-"],
  ["puff_debuff_damage", "DmgDown", "-"],
  ["debuff_yeti_chill", "AtkSlow", "-"],
  ["debuff_attack_speed", "AtkSlow", "-"],
  ["debuff_move_speed", "MoveSlow", "-"],
  ["debuff_chill", "Chill", "-"],
  ["stun", "Stun", "-"],
  ["pallas_phase2_debuff", "RangeDown", "-"],
  ["debuff_dot", "FireDoT", "-"],
  ["ignition", "Ignition", "-"]
]
var status_uids = []

func _prepare_statuses()
  for info : all_statuses
    status_uids.Add(info[0])

var my_buffs = []
var my_debuffs = []
var unk_effects = []
var pickpocket_stacks = 0
var smite_stacks = 0
var stunned = false
var aspd_down = false

func _update_my_effects()
  my_buffs.Clear()
  my_debuffs.Clear()
  // unk.effects are cleared at the end of loop
  pickpocket_stacks = 0
  smite_stacks = 0
  stunned = false
  aspd_down = false
  for s : [buffs.string, debuffs.string]
    // format: *:name:count:duration,...
    var splt = string.Split(s, ":", ",", false)
    var arr_size = splt.Count()
    ?arr_size > 0
      // iterate over names (2nd field)
      for i = 1 .. arr_size - 3
        _parse_status(splt, i)
        i = i + 3

var ignore_statuses = [
  "quarterstaff_buff_attack_speed",
  "quarterstaff_buff_stun",
  "bardiche_buff_aoe_chance",
  "bardiche_buff_crit_chance",
  "bardiche_buff_crit_mult",
  "bardiche_buff_move_speed",
]
var aspd_debuffs = [
  "debuff_chill", "debuff_attack_speed",
  "debuff_yeti_chill",
]
var buff_template = "{0}({1}) {2}"

func _parse_status(splt, i)
  var uid = splt[i]
  var idx = status_uids.IndexOf(uid)
  ?idx = -1
    ?!ignore_statuses.Contains(uid) &
    ^!unk_effects.Contains(uid)
      unk_effects.Add(uid)
    return
  var info = all_statuses[idx] // uid,name,+/-
  var num = int.Parse(splt[i+1])
  var dur = int.Parse(splt[i+2])
  var _name = string.Format(buff_template, 
  ^info[1], num, time.FormatDigital(dur))
  ?info[2] = "+"
    my_buffs.Add(_name)
  :
    my_debuffs.Add(_name)
  ?is(uid, "stun")
    stunned = true
  :?is(uid, "pick_pocket")
    pickpocket_stacks = num
  :?is(uid, "smite")
    smite_stacks = num
  :?aspd_debuffs.Contains(uid)
    aspd_down = true

func foe_buff(uid)
  return get_foe_effect(foe.buffs.string, uid)

func foe_debuff(uid)
  return get_foe_effect(foe.debuffs.string,uid)

func chill_delay()
  return 7 * foe_debuff("debuff_chill")

func get_foe_effect(str, uid)
  ?!(str = uid)
    return 0
  ?is(uid, "adaptive_defense")
    for s:string.Split(str, ":", ",", false)
      // fuzzy match to get which defense it is
      ?s = "adaptive_defense"
        return string.Split(s, "_", false)[2]
  // icon:uid:stacks:duration,...
  var splt = string.Split(str, ":", ",", false)
  var i = splt.IndexOf(uid)
  ?is(uid, "stun")
    // duration
    return int.Parse(splt[i+2])
  // stacks
  return int.Parse(splt[i+1])

var foe_elem = "default"

func get_foe_weak_elem()
  ?foe = aether
    foe_elem = "aether"
    return "vigor"
  ?foe = fire
    foe_elem = "fire"
    return "aether"
  ?foe = ice
    foe_elem = "ice"
    return "fire"
  ?foe = poison
    foe_elem = "poison"
    return "ice"
  ?foe = vigor
    foe_elem = "vigor"
    return "poison"
  foe_elem = "default"
  return "default"

var all_abilities = [
  "mind", "hammer", "bardiche", "blade",
  "skeleton_arm", "mask", "fire_talisman",
  "cinderwisp", "quarterstaff", "dash", "bash",
]
var move_r = ["quarterstaff", "bash", "dash"]
var cooldowns = ["mind", 0]
var abilities = ["mind", false]
func _prepare_abilities()
  for r : useable_abilities
    ?!all_abilities.Contains(r)
      panic("Unknown ability: " + r)
    ?!abilities.Contains(r)
      set(cooldowns, r, 0)
      set(abilities, r, false)

var can_mind = false
func _update_abilities()
  for i = 0 .. abilities.Count() - 2
    var r = abilities[i]
    var cd = item.GetCooldown(r)
    set(cooldowns, r, cd)
    set(abilities, r, cd <= 0)
    ?is(r, "mind")
      can_mind = cd <= 0
    i++

func disable_r(ability)
  ?useable_abilities.Contains(ability)
    set(abilities, ability, false)
  return true

func get(dict, k)
  var idx = dict.IndexOf(k)
  ?idx = -1
    panic("Bad dict key: k=" + k)
  return dict[idx + 1]

func try_get(dict, k, default)
  var idx = dict.IndexOf(k)
  ?idx = -1
    return default
  return dict[idx + 1]

func set(dict, k, v)
  var idx = dict.IndexOf(k)
  ?idx = -1
    dict.Add(k)
    dict.Add(v)
  :
    dict[idx + 1] = v
  return true

func is(s1, s2)
  ?!s1 | !s2
    return false
  return string.Equals(s1, s2)

var weapon_ranges = ["sword", 5, "hammer", 5,
"quarterstaff", 5, "big sword", 6, "arm", 6, 
"heavy hammer", 7, "bardiche", 9, "staff", 10,
"blade", 11, "wand", 20, "heavy crossbow", 22,
"repeating", 22, "crossbow", 22]
var melee_range = 5
var melee_aoe_range = 5
var ranged_range = 20
func _prepare_ranges()
  var a = for_melee_single_target
  ?a.Count() > 0
    melee_range = get(weapon_ranges, a[0])+1
  a = for_melee_aoe
  ?a.Count() > 0
    melee_aoe_range = get(weapon_ranges,a[0])+1
  a = for_ranged_aoe
  ?a.Count() > 0
    ranged_range = get(weapon_ranges, a[0])+1

func _update_lock()
  ?stunned
    set_lock("stun", 0)
  :?lock
    ?is(lock, "stun") | lock_timer <= 0
      lock = false
    :
      lock_timer--
  :
    lock_timer = 0

var at_boss = false // to disable default fight
// player status
var low_hp = false // hp < (maxhp * threshold)
var can_aoe = false
var found = false
var found_type = false
var weak_elem = "default"
// abilities
var lock = false
var lock_timer = false
var free_mind = false
// foe status
var foe_ehp = 0 // foe.armor + foe.hp
var is_boss = false // foe = boss
var phys_immune = false // immune to physical

func _update_game_state()
  _equip_L = false
  _equip_R = false
  found = false
  found_type = false
  excluded_items = false
  weak_elem = get_foe_weak_elem()
  disable_debuffs = foe.buffs.count > 0 &
  ^(foe_buff("poena_mirror") |
  ^foe_buff("buff_protection"))
  low_hp = hp < (maxhp * low_hp_threshold)
  foe_ehp = foe.armor + foe.hp
  is_boss = (foe = boss)
  phys_immune = (foe = immune_to_physical)
  can_aoe = (foe.count >= aoe_treshold)
  // %start_dev%
  traces.Clear()
  // %end_dev%

func prelude()
  // reset/update dynamic global vars
  _update_game_state()
  _update_my_effects()
  _update_abilities()
  _update_lock()

func panic(e)
  >`20,5,#red,@e@
  loc.Pause()

// %start_dev%
var errors = []
func dbg(e)
  ?ui_show_debug
    ?!errors.Contains(e)
      errors.Add(e)

var traces = []
func trace(tag)
  ?enable_tracing & ui_show_debug
    traces.Add(tag)
// %end_dev%

var gray = "#7A8F93"
func draw_ui()
  var x = 1
  var y = 23
  ?ui_show_debug
    y = 21
  ?ui_show_statuses
    ?ui_show_debug
      >`@x@,@y@,#F008B2,
      ^? @string.Join(", ", unk_effects)@
      y++
    >`@x@,@y@,#FE6800,
    ^- @string.Join(", ", my_debuffs)@
    >`@x@,@y+1@,#00A300,
    ^+ @string.Join(", ", my_buffs)@
    ?!ui_show_debug
      >`@x@,@y+2@,@gray@,@loc.stars@*
      ^ @time.FormatDigital(totaltime)@
      ^/@time.FormatDigital(loc.averageTime)@
  ?ui_show_cd
    y = 6
    for r : all_abilities
      ?!move_r.Contains(r) & r!"fire_talisman"&
      ^abilities.Contains(r)
        var cd = get_cd(r)
        ?is(r, "skeleton_arm")
          r = "arm"
        :?is(r, "cinderwisp")
          r = "cinder"
        >`@x@,@y@,#@colorize(cd)@,
        ^@string.Capitalize(r)@
        ^ @time.FormatDigital(cd)@
        y++
    >`@x@,@y@,
    ^#@colorize(get_cd("quarterstaff"))@,QS
    ?abilities.Contains("bash")
      >`@x+2@,@y@,@gray@,/
      >`@x+3@,@y@,
      ^#@colorize(get_cd("bash"))@,B
    ?abilities.Contains("dash")
      >`@x+4@,@y@,@gray@,/
      >`@x+5@,@y@,
      ^#@colorize(get_cd("dash"))@,D
  ?ui_show_debug
    x = 1
    y = 15
    ?foe
      ?string.Size(foe.buffs.string) > 0
        >`@x@,@y@,@gray@,@foe.buffs.string@
      >`@x@,@y+1@,@gray@,id: @foe.id@
      >`@x@,@y+2@,@gray@,S: @foe.state@,
      ^ T: @foe.time@
      var c = foe_debuff("debuff_chill")
      >`@x@,@y+3@,@gray@,Chill: @c@/@c*7@
      >`@x@,@y+4@,@gray@,Dist: @foe.distance@
      >`@x@,@y+5@,@gray@,Count: @foe.count@
    y = 24
    // %start_dev%
    var frame_time = 0
    for ft:frame_times
      frame_time = frame_time + ft
    var info = "ms: " + frame_time / 
    ^frame_times.Count()
    ?lock
      info = info + ", L: " + lock + 
      ^" (" + lock_timer + ")"
    >`@x@,@y@,#blue,@info@
    // %end_dev%
    >`@x@,@y+1@,@gray@,@loc.stars@*
    ^ @time.FormatDigital(totaltime)@
    ^/@time.FormatDigital(loc.averageTime)@
    ^ @foe@
    var _weapon = " (L)"
    x = screen.w - 10
    y = 23
    ?_equip_L
      x = x - string.Size(_equip_L)
      _weapon = _equip_L + _weapon
    >`@x@,@y@,#blue,@_weapon@
    _weapon = " (R)"
    x = screen.w - 10
    ?_equip_R
      x = x - string.Size(_equip_R)
      _weapon = _equip_R + _weapon
    >`@x@,@y+1@,#blue,@_weapon@
    
    // %start_dev%
    var ey = 2
    for err : errors
      >`20,@ey@,#red,@err@
      ey++
    
    ?enable_tracing
      var tr = string.Break(string.Join(
      ^",", traces), 50)
      ey = 2
      for t : tr
        >`20,@ey@,#blue,@t@
        ey++
    // %end_dev%

func colorize(cd)
  ?cd > 0
    return "red"
  return "green"

// %start_dev%
// hp, state, time, chill, dist, L, R
var tracked = [-1, -1, -1, -1, -1, "", ""]
func track_hits()
  var hp_diff = tracked[0] - hp
  ?hp_diff > 0
    var y = 14
    var x = 55
    >`@x@,@y@,#red,Got hit!
    >`@x@,@y+1@,Last frame info:
    >`@x@,@y+2@,hp=@tracked[0]@ (diff=
    ^@hp_diff@)
    >`@x@,@y+3@,state=@tracked[1]@
    >`@x@,@y+4@,time=@tracked[2]@
    >`@x@,@y+5@,chill=@tracked[3]@
    >`@x@,@y+6@,dist=@tracked[4]@
    >`@x@,@y+7@,L=@tracked[5]@
    >`@x@,@y+8@,R=@tracked[6]@
    loc.Pause()
  tracked[0] = hp
  tracked[1] = foe.state
  tracked[2] = foe.time
  var chill = foe_debuff("debuff_chill")
  tracked[3] = chill+"/"+ 7*chill
  tracked[4] = foe.distance
  tracked[5] = _equip_L
  tracked[6] = _equip_R
// %end_dev%

func brew_pot()
  ?loc = Mushroom | loc = mine |
  ^loc = halls | loc = rocky | loc = deadwood |
  ^loc = icy_ridge
    brew wood + bronze // berserk
  :?loc = caves | loc = temple
    brew stone + bronze // lucky

func reset_loop()
  lock = false
  lock_timer = 0
  unk_effects.Clear()
  enable_hit_tracking = false
  at_boss = false
  naga_step = 0
  last_state = 0
  dysan_step = -1

// %start_dev%
var start_t = 0
var frame_times = []
var index = 0
start_t = time.ms
// %end_dev%
?loc.begin
  equip_L("quest")
  auto_equip_shield()
  _prepare_statuses()
  _prepare_items()
  _prepare_ranges()
  _prepare_abilities()
  ?use_potions_for_bosses
    brew_pot()
  :?item.potion = empty
    brew tar + bronze // vampiric
:?loc.loop
  ?use_potions_for_bosses
    brew_pot()
  reset_loop()
prelude()
?ai.enabled & !ai.paused
  progress()
:
  healwalk()
draw_ui()
// %start_dev%
?enable_hit_tracking
  track_hits()
?frame_times.Count() < 30
  frame_times.Add(time.ms-start_t)
:
  frame_times.Emplace(index, time.ms-start_t)
  index++
  ?index = frame_times.Count()
    index = 0
// %end_dev%