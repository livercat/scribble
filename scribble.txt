// hammer, war hammer, warhammer are the same
var elemental_items = [
  ["warhammer", 
    ["aether", "D"],
    ["poison", "D"],
    ["ice", "D"],
  ],
  ["wand", 
    ["fire", "D"],
    ["poison", "D"],
    ["vigor", "D", "dL"],
  ],
  ["sword", 
    ["aether", "D"],
    ["fire", "dF"],
    ["ice", "dI"],
    ["poison", "dP", "D"],
    ["vigor", "dL"],
    ["default", "vigor sword dL"],
  ],
  ["shield", 
    ["vigor", "ah", "A"],
    ["poison", "A"],
    ["ice", "A"],
    ["aether", "A"],
    ["default", "vigor shield ah"],
  ],
]

/* Listed item types will be used to find
a weapon for specific range when 
`foe.count < aoe_treshold`. Any weapon types
are supported in both lists. Script will search:
1) type1 + foe_weakness_element
2) type1 + default
If still nothing is found, type2 is checked 
the same way, and so on. If still nothing is
found, then repeat all these steps for each
element except foe's strong element. If foe
has armor, "war hammer" and "heavy hammer" will 
be used for melee first if they're listed. */
var melee_types = [
  "sword", "big sword", "war hammer",]
var ranged_types = [
  "repeating", "wand", "staff", "crossbow",]
/* same but for `foe.count >= aoe_treshold`. If
empty, then will use lists above */
var melee_aoe_types = [
  "bardiche", "big sword", "heavy hammer",]
var ranged_aoe_types = [
  "wand", "staff", "crossbow", "repeating",]

/* full name of the shield with the highest
evade%, will be used to block big boss attacks*/
var evade_shield = "vigor ah"

/* If item is not listed here, its R ability
won't be used. Supported: dash, bash, 
bardiche, hammer, blade, skeleton_arm, mask,
quarterstaff */
var can_use_abilities = ["dash", "bash", 
"skeleton_arm", "mask", "blade", "hammer", 
"bardiche", "quarterstaff"]

/*********************
**     #Settings    **
*********************/
// Show ability cooldowns
var ui_show_cd = true

// Show your buffs/debuffs
var ui_show_statuses = true

// Show debug info (noisy, useful for research)
var ui_show_debug = true

/* How many regular enemies are needed to start 
using AOE weapons instead of single target */
var aoe_treshold = 4

/* Low HP threshold, fraction of 1. When on low 
HP, will prioritize `ah` shield and `dL` weapon 
over foe_weakness_element.
If 1, will always try to lifesteal to max.
If -1, will never force lifesteal. */
var low_hp_threshold = 0.5

// switch to 1h + shield when on Low HP
var use_shield_on_low_hp = true

// Usually script prefers melee, this changes it
var prefer_ranged = false

// Choose amount based on your `dI` weapon
var max_chill = 6

/* Blade of the Fallen God quests.
"bolesh" to kill him with the blade,
"variety" for killing unique enemies */
var bfg_quest = false

/* If you're on the "variety" step of the blade
quest, fill this array with names of the
enemies you've already defeated. */
var bfg_defeated_foes = ["ant", "mosquito"]

// Depends on level/enchants of the Blade
var smite_damage = 85

/* At least this many enemies must be present
to use Smite */
var smite_treshold = 7

/* if true, will debuff even regular enemies
when you have the Smite buff active */
var debuff_on_smite = true

/* Set to true if you're doing Skeleton Arm
quests. Prioritizes last-hitting foes with the 
Arm ability */
var pickpocket_quest = false

// These depend on level/enchants of the Arm
var arm_damage = 32
var max_pickpocket = 2

/* Cultist Mask quests.
"simple" - steps 1 and 3 (uses on CD)
"prevent" - step 4: do it in Rocky. Script
will approach the scout, use mask, get hit as
long as the debuff lasts, and quit the zone. */
var mask_quest = "prevent"

/*********************
**     #Progress    **
*********************/
func progress()
  ?healwalk() // no enemies nearby
    return true
  :?foe = explode
    return avoid_explosion()
  :?!is_boss & !at_boss
    /* Add your non-boss zone logic here */
    free_mind = true
    return fight()
  stance = "boss combat"
  // enable_hit_tracking = true
  ?loc = rocky
    ?foe.id = "acronian_scout"
      return fight_scout()
    return fight_dysan()
  :?loc = deadwood
    return fight_xyloalgia()
  :?loc = caves
    ?foe.id = "cool_bat" // ceiling decorator
      return auto_melee_miniboss()
    return fight_bolesh()
  :?loc = fungus_forest_boss
    return fight_mushrooms()
  :?loc = mushroom
    ?foe.id = "epic_snail"
      return auto_melee_miniboss()
  :?loc = undead_crypt_boss
    return fight_pallas()
  :?loc = bronze_guardian
    return fight_bronze_guardian()
  :?loc = icy_ridge
    return fight_hrimnir()
  :?loc = nagaraja
    return fight_nagaraja()
  :
    dbg("Fighting unknown boss")
    auto_melee_boss()

func idle()
  ?pickup.distance < 9
    return equip_L("star") & equip_R("trisk")
  :?can_qs_dash()
    return qs_dash()
  stance = "idle"
  found = auto_equip_R("shield", false)
  ?!found
    return equip_L("ouroboros") & 
    ^equip_R("trisk")
  ?hp < maxhp
    return equip_L("ouroboros")
  return equip_L("trisk")

func healwalk()
  stance = "healwalk"
  ?foe & (foe_dist < 23)
    ?hp < (maxhp / 4) & item.potion ! empty &
    ^(item.potion = "healing" | 
    ^item.potion = "vampiric")
      activate potion
    return false // start combat instead
  return idle()

func avoid_explosion()
  stance = "avoiding explosion"
  ?foe_dist < 5
    disable_r("all_dash")
    return try_evade()
  return melee("def")

/********************
**     #Combat    **
********************/
func fight()
  ?phys_immune | foe = magic_vulnerability
    return auto_elemental()
  :?must_melee_foe()
    return auto_melee()
  :?must_ranged_foe()&foe_dist > melee_aoe_range
    return auto_ranged()
  :?prefer_ranged
    ?foe_dist < 8
      ?can_backflip()
        return backflip()
      return auto_melee()
    return auto_ranged()
  :
    return auto_melee()

func auto_melee()
  ?use_abilities()
    return true
  :?can_aoe & eff_dist <= melee_aoe_range
    return melee("aoe")
  :?low_hp & use_shield_on_low_hp
    return melee("def")
  :?smitten & debuff_on_smite & 
  ^eff_dist <= melee_range & debuff()
    return true
  :
    return melee("dps")

// mode: "dps" | "def" | "aoe"
func melee(mode)
  ?come_closer()
    return true
  ?mode = "dps"
    stance = "melee dps"
    auto_equip("melee", false)
  :?mode = "aoe"
    stance = "melee aoe"
    auto_equip("melee", true)
  ?mode = "def" | 
  ^eff_dist > _weapon_range(_equip_L)
    stance = "melee def"
    found = auto_equip_L("melee", false)
    ?!is_2hander(found)
      found = auto_equip_R("shield", false)
      ?!found
        auto_equip_R("melee", false)
  ?low_hp
    stance = "low_hp " + stance

func come_closer()
  ?can_dash()
    return dash()
  :?should_qs_dash()
    return qs_dash()
  return false  

func auto_ranged()
  ?use_abilities()
    return true
  :?can_aoe & eff_dist <= ranged_aoe_range
    return ranged_aoe()
  :?can_ranged
    return ranged()
  :
    return auto_melee()

func ranged()
  stance = "ranged"
  ?low_hp
    stance = "low_hp ranged"
  return auto_equip("ranged", false)

func ranged_aoe()
  stance = "ranged aoe"
  ?low_hp
    stance = "low_hp ranged aoe"
  return auto_equip("ranged", true)

func auto_elemental()
  ?use_abilities()
    return true
  :?elemental()
    return true
  :
    return auto_equip("ranged", true)

func elemental()
  stance = "elemental"
  ?auto_equip("elemental", true)
    return true
  return false

func can_dash()
  return (available("dash") | available("bash"))
  ^& eff_dist > 10 & eff_dist < 17 &
  ^can_activate()

func dash()
  ?available("bash")
    stance = "bashing"
    return equip_R("bashing")
  :?available("dash")
    stance = "dashing"
    return equip_R("dashing")
  return false

var ranged_foes = ["mosquito", "huge_mosquito",
"wasp", "ant"]
func must_ranged_foe()
  return ranged_foes.Contains(foe.id) 

func must_melee_foe()
  return foe = immune_to_ranged | foe = ranged | 
  ^foe.id = "cult_guard" // poisons on being hit

func auto_melee_boss()
  ?!come_closer()
    ?!use_abilities()
      ?eff_dist > melee_range
        melee("def") // approach
      :?!debuff()
        auto_melee()
  stance = "boss " + stance

func auto_melee_miniboss()
  disable_r("blade")
  disable_r("mask")
  auto_melee()
  stance = "miniboss " + stance

/**********************
** #Weapon switching **
**********************/
func debuff()
  ?foe_buffs = "buff_protection" | 
  ^foe_buffs = mirror
    return false
  cache.Clear()
  ?!(foe_debuffs = "∞:debuff_damage:") &
  ^!(foe = immune_to_debuff_damage)
    cache.Add("poison")
  ?!(foe_debuffs = "φ:debuff_dot:") &
  ^!(foe = immune_to_debuff_dot)
    cache.Add("fire")
  ?!dont_chill & 
  ^!(foe_debuffs = "❄:debuff_chill:" + 
  ^max_chill + ":") &
  ^!(foe = immune_to_debuff_chill)
    cache.Add("ice")
  var amount = cache.Count()
  ?amount = 0
    return false
  stance = "debuffing"
  var types = get_weapon_candidates(
  ^"melee", false)
  var equipped_one = false
  for ty : types
    ?!equipped_one
      found = get_item(ty, cache[0], true)
      ?found
        ?is_2hander(equip_L(found))
          return true
        equipped_one = true // to exit the loop
  ?!found
    auto_equip_L("melee", false)
  ?amount = 1
    ?low_hp
      found = auto_equip_R("shield", false)
      ?found
        return found
    return auto_equip_R("melee", false)
  :
    for ty : types
      found = get_item(ty, cache[1], true)
      ?found
        return equip_R(found)
  return false

func equip_L(it)
  // sets global flag, so the next `get_item()`
  // in this frame will not return the same item
  _equip_L = it
  ?is_2hander(it)
    return aac(it)
  equipL @it@
  return it

func equip_R(it)
  // for debug
  _equip_R = it
  ?is_2hander(it)
    return aac(it)
  equipR @it@
  return it

// ty: any weapon type | "melee" | "ranged"
// aoe: true/false
func auto_equip_L(ty, aoe)
  ?non_elem_types.Contains(ty)
    return equip_L(ty)
  var types = get_weapon_candidates(ty, aoe)
  found = select_weapon(types)
  ?found
    return equip_L(found)
  return false

// ty: any weapon type | "melee" | "ranged"
// aoe: true/false
func auto_equip_R(ty, aoe)
  var types = get_weapon_candidates(ty, aoe)
  found = select_weapon(types)
  ?found
    return equip_R(found)
  return false

// ty: any weapon type | "melee" | "ranged"
// aoe: true/false
func auto_equip(ty, aoe)
  ?non_elem_types.Contains(ty)
    return equip_L(ty)
  var types = get_weapon_candidates(ty, aoe)
  found = select_weapon(types)
  ?!found
    return false
  equip_L(found)
  ?is_2hander(found)
    return found
  found = select_weapon(types)
  ?found
    return equip_R(found)
  return false

func get_weapon_candidates(ty, aoe)
  ?all_elem_types.Contains(ty)
    return [ty]
  var types = melee_types
  ?ty = "melee"
    ?aoe
      types = melee_aoe_types
    ?foe.armor > 0
      ?aoe
        types = aa_aoe_types
      :
        types = aa_melee_types
  :?ty = "ranged"
    ?aoe
      types = ranged_aoe_types
    :
      types = ranged_types
  :?ty = "elemental"
    types = magic_types
  return types

func is_2hander(it)
  return _2h_types.Contains(it)

func select_weapon(types)
  found = get_item(types[0], _elems[0], false)
  ?found
    return found
  found = get_item(types[0], "default", false)
  ?found
    return found
  for el : _elems
    for ty : types
      found = get_item(ty, el, false)
      ?found
        return found
  return false

/********************
**    #Abilities   **
********************/

func edmg(dmg)
  return dmg - dmg_down_stacks

func set_lock(tag, timer)
  ?!lock
    lock = tag
    lock_timer = timer

func clear_lock(tag)
  ?lock & string.Equals(lock, tag)
    lock = false
    lock_timer = 0

func available(ability)
  ?lock
    ?string.Equals(lock, ability)
      return lock_timer > 0 // animation
    :
      return false
  return can_use[
  ^can_use_abilities.IndexOf(ability)]

func can_qs_dash()
  return available("quarterstaff") & 
  ^can_activate()

func should_qs_dash()
  return (prefer_ranged & eff_dist > 28) |
  ^(eff_dist > 16 | 
  ^eff_dist < 11 & eff_dist > 5) & can_qs_dash()

func qs_dash()
  stance = "staff-dashing"
  equip_L("staff")
  ?item.CanActivate("quarterstaff")
    activate R
  return true

func can_backflip()
  return available("mind") & free_mind &
   // don't jump into the wall
  ^screen.FromWorldX(pos.x) > 5
  
func backflip()
  stance = "mind stone R"
  auto_equip_R("shield", false)
  return equip_L("mind")

func can_slap()
  return available("skeleton_arm") & 
  ^eff_dist < 7 & !phys_immune & can_activate()

func should_slap()
  return can_slap() & (!pickpocket_quest |
  ^foe_ehp <= edmg(arm_damage))

func slap()
  stance = "skeleton arm R"
  aac("arm")
  ?pickpocket_stacks >= max_pickpocket &
  ^item.CanActivate("skeleton_arm")
    activate R
  return true

func can_smite()
  return available("blade") & 
  ^eff_dist <= 20 & (foe ! pallas) & // immune
  ^can_activate()

func should_smite()
  ?bfg_quest = "variety"
    ?foe_ehp<=edmg(smite_damage) & can_smite()
      for e : bfg_defeated_foes
        ?foe = e
          return false
      return true
    return false
  return (is_boss | foe.count >= smite_treshold
  ^& foe_ehp<=edmg(smite_damage)) & can_smite()

func smite()
  stance = "smite R"
  aac("blade")
  ?item.CanActivate("blade")
    activate R
  return true

func can_hammer()
  return available("hammer") & !phys_immune & 
  ^eff_dist <= 21 & can_activate()

func should_hammer()
  return foe.armor > 0 & 
  ^(is_boss | can_aoe & eff_dist < 10) & 
  ^can_hammer()

var hammer_frames = 15
func hammer()
  set_lock("hammer", hammer_frames)
  stance = "heavy hammer R"
  aac("heavy hammer")
  ?item.CanActivate("hammer")
    activate R
  return true

func can_bard()
  return available("bardiche") & eff_dist <= 9 & 
  ^!phys_immune & can_activate()

func should_bard()
  return is_boss & can_bard()

var bard_frames = 20
func bardiche()
  set_lock("bardiche", bard_frames)
  stance = "bardiche R"
  aac("bardiche")
  ?item.CanActivate("bardiche")
    activate R
  return true

func can_mask()
  return available("mask") &
  ^(foe ! nagaraja) & can_activate()

func should_mask()
  return (mask_quest = "simple" | 
  ^is_boss & eff_dist<=melee_range) & can_mask()

func mask()
  stance = "mask R"
  equip_R("mask")
  ?item.CanActivate("mask")
    activate R
  return true

func use_abilities()
  // prioritize quests
  ?string.Equals(mask_quest, "simple") &
  ^can_mask()
    return mask()
  ?pickpocket_quest & can_slap()
    return slap()
  // then use where needed
  ?should_hammer()
    return hammer()
  ?should_smite()
    return smite()
  ?should_bard()
    return bardiche()
  ?should_slap()
    return slap()
  // use mask right before debuffing
  ?should_mask()
    return mask()
  return false

func can_activate()
  return ai.enabled & item.CanActivate()

func aac(weapon)
  _equip_L = weapon
  equip @weapon@
  ?ai.idle
    ?lock & (string.Equals(lock, "hammer") | 
    ^string.Equals(lock, "bardiche"))
      return false
    equip wand
  equip @weapon@
  return weapon

/*****************
**    #Bosses   **
*****************/
  
func try_evade()
  ?can_mind
    return backflip()
  return shield_block()

func evade_at(t)
  ?foe_t = t
    return try_evade()
  ?foe_t < t & get_cd("mind") <= (t - foe_t)
    // abilities that would be interrupted
    ?foe_t > (t - bard_frames)
      disable_r("bardiche")
    ?foe_t > (t - hammer_frames)
      disable_r("hammer")
  return false

func shield_block()
  stance = "shield block"
  return equip_R(evade_shield)

func shield_block_and_halt()
  stance = "shield block and halt"
  equip_R(evade_shield)
  return equip_L("quest")

func fight_scout()
  ?string.Equals(mask_quest, "prevent")
    equip_L("quest")
    ?foe_s = 32 & foe_t > 11 & can_mask()
      return mask()
    ?get_cd("mask") > 0 &
    ^foe_debuffs ! "debuff_feeble"
      return loc.Leave()
    ?have_dashing
      equip_R("dashing")
  :
    auto_melee_boss()    

func fight_dysan() // REDO
  disable_r("skeleton_arm")
  ?foe = phase1
    ?foe_s = 33 & foe_t = 24
      // block big attack
      return shield_block()
  :?foe = phase2
    auto_equip("melee", false)
  :?foe = phase3
    ?foe_s = 32 & foe_t > 90
      // prepare for attack
      return shield_block()
    :?foe_s = 115
      ?foe_t = 60
        // dodge the orb ray
        return backflip()
      :?foe_t < 80
        // don't dash into ray
        disable_r("all_dash")
    :?foe_s = 106 | foe_s = 108 |
    ^foe_s = 0
      return shield_block()
  auto_melee_boss()

func fight_xyloalgia()
  ?foe = phase1 // Xyloalgia
    return auto_melee_boss()
  // Poena
  disable_r("skeleton_arm")
  ?foe_buffs = mirror
    return shield_block_and_halt() // :(
  :?foe_s = 32 & foe_t = 41
    return shield_block()
  auto_melee_boss()

func fight_bolesh()
  // Get close, debuff/use abilities, then
  // jump to ranged before the first melee bite,
  // and continue shooting and blocking.
  ?loc.stars > 5
    disable_r("skeleton_arm")
  ?foe_s = 133 & ((foe_t > 9 & foe_t < 12) | 
  ^(foe_t > 14 & foe_t < 17))
    // block bite and don't move from ranged
    return shield_block_and_halt()
  :?foe_s = 142 & foe_t = 60
    // evade melee bite
    return backflip()
  :?can_mind & foe_buffs ! "spider_buff_damage"
    return auto_melee_boss()
  :?bfg_quest & bfg_quest = "bolesh" & 
  ^(foe_ehp < edmg(smite_damage))
    ?eff_dist <= 11
      return equip_L(blade)
    return melee("def")
  :
    ranged()

func fight_mushrooms()
  /* big swing timings are affected by chill,
  so don't chill before the 1st swing, and nuke
  and chill after that */
  disable_r("skeleton_arm")
  dont_chill = false
  ?foe = phase1
    big_swing = 48
    ?!swing_evaded
      dont_chill = true
    ?foe.hp < 100
      swing_evaded = false //reset before phase2
    ?!swing_evaded & foe_s = 32 &
    ^evade_at(big_swing)
      swing_evaded = true
      return
    :?foe_s = 33 & foe_t = foe_dist + 4
      // pellets, V = 1 frame / sec
      return shield_block()
  :?foe = mushroom_boss_fat
    big_swing = 27
    ?!swing_evaded
      dont_chill = true
    ?foe_s = 32 & evade_at(big_swing)
      swing_evaded = true
      return
  auto_melee_boss()

func fight_pallas()
  disable_r("skeleton_arm")
  ?foe = phase1
    ?foe_s = 32 & foe_t = 68
      return shield_block()
    return auto_melee_boss()
  :?foe ! phase2
    return fight() // adds
  auto_melee_boss()

func fight_bronze_guardian()
  disable_r("skeleton_arm")
  ?foe_s = 32 & foe_t = 33 & armor < foe.damage
    return backflip() // dodge the hammer
  :?foe_s = 33 // hammer is down
    ?smitten
      return auto_melee_boss()
    ?!come_closer() & !use_abilities()
      return melee("dps") // don't debuff
  :
    ranged()

func fight_hrimnir() // REDO
  at_boss = true
  ?is_boss & foe.armor > 0
    // initial ice block, don't debuff
    return auto_melee()
  :?loc.stars <= 5 // try to cheese
    ?foe_dist <= 2
      ?!use_abilities()
        return auto_melee() // don't debuff
    :?foe_dist <= 5
      // The shovel has an attack range of 1
      // so at white stars we can avoid
      // snowballs by getting close to boss.
      // on higher stars he blows you away
      // immediately
      equip_L("shovel")
    : // blown away, get back
      return auto_melee()
  :?foe_s = 143 | foe_s = 144 // blowing
    return ranged()
  :?foe.count > 1 // deal with adds
    ?can_smite()
      return smite()
    :?foe.count > 2
      ?can_hammer()
        return hammer()
      return elemental_aoe()
    :?eff_dist < 11
      return auto_melee()
    :?can_bard() & foe.id = ice_wall
      return bardiche()
    return auto_melee()
  :?slowed
    ranged()
  :
    auto_melee_boss()

func fight_nagaraja()
  // dodge poison balls & plink away
  disable_r("skeleton_arm")
  var x = screen.FromWorldX(pos.x)
  var y = screen.FromWorldZ(pos.z)
  ?is_poison_near(x, y)
    // dodge from ranged to melee
    ?foe_dist > 12
      ?can_qs_dash()
        return qs_dash()
      return ranged()
    :?foe_dist > melee_range
      return auto_melee_boss()
    :
      return try_evade()
  ?foe_s = 112 & foe_t = 59 & foe_dist < 10
    return try_evade()
  :?foe_dist > melee_range
    return ranged()
  return auto_melee_boss()

func is_poison_near(pos_x, pos_y)
  // long and mid range
  ?draw.GetSymbol(pos_x+2, pos_y-6) = "(" |
  // melee
  ^(draw.GetSymbol(pos_x+1, pos_y-6) = "(")
    return true
  return false

func _detect_poison()
  var x = screen.FromWorldX(pos.x)
  var y = screen.FromWorldZ(pos.z)
  >`0,0,x=@x@, y=@y@
  for px = pos_x .. pos_x+10
    for py = pos_y-6 .. pos_y
      ?draw.GetSymbol(px, py) = "("
        cache.Add([pos_x, pos_y, px, py])
  var arr_size = cache.Count()
  ?arr_size > 0
    for line = 1 .. arr_size
      var v = cache[line-1]
      >`0,@line@,x=@v[0]@, y=@v[1]@, 
      ^px=@v[2]@, py=@v[3]@;

/*********************
**     #Internals   **
*********************/
var at_boss = false // to disable default fight
 // mushrooms
var big_swing = 0
var swing_evaded = false
var dont_chill = false
// player status
var stance = "unknown" // chosen combat stance
var low_hp = false // hp < (maxhp * threshold)
var dmg_down_stacks = 0 // poison
var range_down_stacks = 0 // pallas?
var pickpocket_stacks = 0 // pickpocket buff
var smitten = false // have smite buff
var slowed = false // is player slowed
var stunned = false // is player stunned
var berserk = false // potion
var can_aoe = false
// abilities
var lock = false
var lock_timer = false
var free_mind = false
var all_abilities = [
  "mind", "hammer", "bardiche", "blade",
  "skeleton_arm", "dash", "bash", "mask", 
  "quarterstaff", 
]
// foe status
var foe_s = 0 // foe.state
var foe_t = 0 // foe.time
var foe_ehp = 0 // foe.armor + foe.hp
var foe_dist = 0 // foe_dist
var eff_dist = 0 // foe_dist + range_debuff
var foe_buffs = "" // foe.buffs.string
var foe_debuffs = "" // foe.debuffs.string
var is_boss = false // foe = boss
var phys_immune = false // immune to physical
// hit tracking
var enable_hit_tracking = false
var last_frame_dist = 0
var last_frame_armor = 0
var last_frame_hp = 0
var last_frame_foe = ""
var last_frame_dist = 0
var last_frame_state = -1
var last_frame_time = -1
var last_frame_stance = ""
var last_frame_debuffs = 
^"sl=false,st=false,d=false,r=false"

// Pre-define vars for internal functions.
var found = false
var ty = false
var _equip_L = false
var _equip_R = false
var _elems = ["default"]
var st_good = [] // current buffs
var st_bad = [] // current debuffs
var st_x = [] // unknown status effects
var status_uids = []
var errors = []
var cache = []
var gray = "#7A8F93"

var non_elem_types = ["bardiche", "arm","blade", 
"heavy hammer", "repeating", "quarterstaff"]
var _2h_types = ["bardiche", "arm", "blade", 
"heavy hammer", "repeating", "staff",
"quarterstaff"]
var magic_types = []
var all_elem_types = [
  "sword", "big sword", "wand", "shield", 
  "crossbow", "staff", "hammer",
]
var type_c = all_elem_types.Count()
var all_elems = [
  "aether", "fire", "ice", "poison", "vigor",
  "default",
]
var elem_c = all_elems.Count()
var equipment = [
  // The items cache, consists of subarrays:
  // [[damage/armor items], [buff/debuff items]]
  // Each item type gets a subarray for each
  // element, and the types are placed in
  // sequence. For example: first 6 subarrays 
  // belong to "sword", the next 6 to 
  // "big sword", and so on. See also get_item()
]
// "{element} {type} {suffix + enchant}"
var name_template = "{0} {1} {2}"
func _prepare_items()
  // add placeholders for every subarray
  for i = 0 .. (type_c * elem_c) - 1
    equipment.Add([[], []])
   // `it` is [type, [elem, s1, sn], [elem2...]]
  for it : elemental_items
    ?it.Count() > 1
      for i = 1 .. it.Count() - 1
        //`el_it` is ["elem", "s1", "sn"]
        var el_it = it[i]
        ?el_it.Count() > 1
          ty = it[0] // item type
          ?ty = "warhammer" | ty = "war hammer"
            ty = "hammer"
          var elem = el_it[0] // item element
          var offset = _get_offset(ty, elem)
          // for every suffix in list
          for j = 1 .. el_it.Count() - 1
            var suffix = el_it[j]
            // `slot` is [[dmg], [effect]]
            var slot = equipment[offset]
            var full_name
            ?elem = "default"
              full_name = suffix
              ?!slot[0].Contains(full_name)
                slot[0].Add(full_name)
            :
              full_name = string.Format(
              ^name_template, elem, ty, suffix)
              ?_is_elem_effect(suffix) & 
              ^!slot[1].Contains(full_name)
                slot[1].Add(full_name)
              :?!slot[0].Contains(full_name)
                slot[0].Add(full_name)
  for w : ["warhammer", "war hammer"]
    for a : [melee_types, melee_aoe_types]
      var idx = a.IndexOf(w)
      ?idx ! -1
        a.Emplace(idx, "hammer")
  for m : melee_types
    ?!melee_aoe_types.Contains(m)
      melee_aoe_types.Add(m)
  for r : ranged_types
    ?(r = "wand" | r = "staff") & 
    ^!magic_types.Contains(r)
      magic_types.Add(r)
    ?!ranged_aoe_types.Contains(r)
      ranged_aoe_types.Add(r)
  for a : [[melee_types, aa_melee_types],
  ^[melee_aoe_types, aa_aoe_types]]
    var source = a[0]
    var dest = a[1]
    ?source.Contains("heavy hammer")
      dest.Add("heavy hammer")
    ?source.Contains("hammer")
      dest.Add("hammer")
    for w : source
      ?!string.Equals(w, "heavy hammer") &
      ^!string.Equals(w, "hammer")
        dest.Add(w)

var aa_melee_types = []
var aa_aoe_types = []
var can_ranged = ranged_types.Count() > 0

func _get_offset(ty, elem)
  return all_elem_types.IndexOf(ty) * elem_c +
  ^all_elems.IndexOf(elem)

var _elem_suffixes = ["f", "F", "i", "I", 
"p", "P", "h", "L",]
func _is_elem_effect(suffix)
  ?string.Size(suffix) < 2
    return false
  // check second symbol of the suffix
  return _elem_suffixes.Contains(
  ^string.Sub(suffix, 1, 1))

func _find_first(arr, exclude)
  ?arr.Count() > 0
    for it : arr
      ?!exclude | !string.Equals(exclude, it)
        return it
  return false

// ty: in-game item type
// elem_effect: bool
func get_item(ty, element, elem_effect)
  ?non_elem_types.Contains(ty)
    return ty
  var slot = equipment[_get_offset(ty, element)]
  ?!elem_effect
    found = _find_first(slot[0], _equip_L)
  // if D item not found, try to find dX item
  ?elem_effect | !found
    found = _find_first(slot[1], _equip_L)
  return found

var ignore_st = [ // irrelevant statuses
  "quarterstaff_buff_attack_speed",
  "quarterstaff_buff_stun",
  "bardiche_buff_aoe_chance",
  "bardiche_buff_crit_chance",
  "bardiche_buff_crit_mult",
  "bardiche_buff_move_speed",
]
var statuses = [
  ["berserk", "Berserk", "+"], 
  ["smite", "Smite", "+"], 
  ["pick_pocket", "Pickpocket", "+"],
  ["vampiric", "Vamp", "+"],
  ["lucky_crit_multi", "Lucky", "+"],
  ["invisibility", "Invis", "+"],
  ["debuff_damage", "DmgDown", "-"],
  ["debuff_duration_damage", "DmgDown", "-"],
  ["spider_debuff_damage", "DmgDown", "-"],
  ["dysangelos_debuff_damage", "DmgDown", "-"],
  ["puff_debuff_damage", "DmgDown", "-"],
  ["debuff_yeti_chill", "AtkSlow", "-"],
  ["debuff_attack_speed", "AtkSlow", "-"],
  ["debuff_move_speed", "MoveSlow", "-"],
  ["debuff_chill", "Chill", "-"],
  ["stun", "Stun", "-"],
  ["pallas_phase2_debuff", "RangeDown", "-"],
  ["debuff_dot", "FireDoT", "-"],
]
var dmg_debuffs = [
  "debuff_damage", "debuff_duration_damage",
  "spider_debuff_damage", "puff_debuff_damage"
]
var slow_debuffs = [
  "debuff_chill", "debuff_move_speed"
]
var mirror = "poena_mirror"
func _parse_statuses()
  st_good.Clear()
  st_bad.Clear()
  dmg_down_stacks = 0
  range_down_stacks = 0
  pickpocket_stacks = 0
  slowed = false
  berserk = false
  stunned = false
  smitten = false
  for s : [buffs.string, debuffs.string]
    // format: *:name:count:duration,...
    var splt = string.Split(s, ":", ",", false)
    var arr_size = splt.Count()
    ?arr_size > 0
      // iterate over names (2nd field)
      for i = 1 .. arr_size - 3
        var st_uid = splt[i]
        var st_amount = int.Parse(splt[i+1])
        var st_dur = int.Parse(splt[i+2])
        ?dmg_debuffs.Contains(st_uid)
          dmg_down_stacks = dmg_down_stacks + 
          ^st_amount
        :?slow_debuffs.Contains(st_uid)
          slowed = true
        :?string.Equals(st_uid, 
        ^"pallas_phase2_debuff")
          range_down_stacks = st_amount
        :?string.Equals(st_uid, "stun")
          stunned = st_dur
        :?string.Equals(st_uid, "smite")
          smitten = true
        :?string.Equals(st_uid, "berserk")
          berserk = true
        :?string.Equals(st_uid, "pick_pocket")
          pickpocket_stacks = st_amount
        var idx = status_uids.IndexOf(st_uid)
        ?idx ! -1
          var st_info = statuses[idx]
          var st_s = string.Format("{0}({1}) " + 
          ^"{2}", st_info[1], st_amount,
          ^time.FormatDigital(st_dur))
          ?st_info[2] = "+"
            st_good.Add(st_s)
          :
            st_bad.Add(st_s)
        :?!ignore_st.Contains(st_uid) &
        ^!st_x.Contains(st_uid)
          // log unknown statuses for debug
          st_x.Add(st_uid)
        i = i + 3

func _prepare_statuses()
  for st_info : statuses
    status_uids.Add(st_info[0])

func get_foe_elems()
  ?foe = aether
    return ["aether", "vigor"]
  ?foe = fire
    return ["fire", "aether"]
  ?foe = ice
    return ["ice", "fire"]
  ?foe = poison
    return ["poison", "ice"]
  ?foe = vigor
    return ["vigor", "poison"]
  return ["", false]

func _set_elems()
  _elems.Clear()
  var foe_elems = get_foe_elems() // strong,weak
  ?low_hp
    _elems.Add("vigor")
  ?foe_elems[1]
    _elems.Add(foe_elems[1])
  for e : all_elems
    ?(e ! foe_elems[0]) & (e ! foe_elems[1]) &
    ^(!low_hp | e ! "vigor")
      _elems.Add(e)
  ?_elems.Count() = 0
    _elems.Add("default")

var weapon_ranges = ["sword", 5, "hammer", 5,
"quarterstaff", 5, "big sword", 6, "arm", 6, 
"heavy hammer", 7, "bardiche", 9, "staff", 10,
"blade", 11, "wand", 20, "heavy crossbow", 22,
"repeating", 22, "crossbow", 22]
func _weapon_range(weapon)
  var idx = weapon_ranges.IndexOf(weapon)
  ?idx = -1
    return 5
  return weapon_ranges[idx + 1]

var melee_range = 5
var melee_aoe_range = 5
var ranged_aoe_range = 16
func _prepare_ranges()
  ?melee_types.Count() > 0
    melee_range = 
    ^_weapon_range(melee_types[0])
  ?melee_aoe_types.Count() > 0
    melee_aoe_range = 
    ^_weapon_range(melee_aoe_types[0])
  ?ranged_aoe_types.Count() > 0
    ranged_aoe_range = 
    ^_weapon_range(ranged_aoe_types[0])

var cooldowns = []
var can_use = []
func _prepare_abilities()
  ?!can_use_abilities.Contains("mind")
    can_use_abilities.Add("mind")
  for r : can_use_abilities
    cooldowns.Add(0)
    can_use.Add(false)

// no -1 because we added "mind"
var skill_count = can_use_abilities.Count()
var can_mind = false
func _maintain_abilities()
  for i = 0 .. skill_count
    var r = can_use_abilities[i]
    cooldowns[i] = item.GetCooldown(r)
    can_use[i] = cooldowns[i] <= 0
    ?string.Equals(r, "mind")
      can_mind = can_use[i]

func get_cd(ability)
  return 
  ^cooldowns[can_use_abilities.IndexOf(ability)]

var move_r = ["quarterstaff", "bash", "dash"]
func disable_r(ability)
  ?ability = "all_dash"
    for a : move_r
      can_use[can_use_abilities.IndexOf(a)] = 
      ^false
    return
  can_use[can_use_abilities.IndexOf(ability)] =
  ^false

func _maintain_lock()
  ?stunned
    set_lock("stun", stunned)
  :
    clear_lock("stun")
  ?lock
    ?lock_timer <= 0
      lock = false
    :
      lock_timer--
  :
    lock_timer = 0  

func prelude()
  // reset/update dynamic global vars
  ?enable_hit_tracking
    track_hits()
  _parse_statuses()
  _maintain_abilities()
  _maintain_lock()
  low_hp = hp < (maxhp * low_hp_threshold)
  _set_elems() // needs to know `low_hp`
  _equip_L = false
  _equip_R = false
  stance = "unknown"
  foe_s = foe.state
  foe_t = foe.time
  foe_ehp = foe.armor + foe.hp
  foe_dist = foe.distance  
  eff_dist = foe_dist + range_down_stacks
  foe_buffs = foe.buffs.string
  foe_debuffs = foe.debuffs.string
  is_boss = (foe = boss)
  phys_immune = (foe = immune_to_physical)
  can_aoe = (foe.count >= aoe_treshold)

func dbg(e)
  ?ui_show_debug
    ?!errors.Contains(e)
      errors.Add(e)

var debuff_hash = "sl={0},st={1},d={2},r={3}"
func track_hits()
  var hp_diff = last_frame_hp - hp
  var _debuffs = string.Format(debuff_hash,
  ^slowed, stunned & stunned > 0, 
  ^dmg_down_stacks > 0, range_down_stacks > 0)
  ?hp_diff > 0 | 
  ^(last_frame_debuffs ! _debuffs)
    >`20,2,#red,Got hit!
    >`20,3,Last frame info:
    >`20,4,hp = @last_frame_hp@ (diff = 
    ^@hp_diff@), 
    ^armor = @last_frame_armor@
    >`20,5,id = @last_frame_foe@
    >`20,6,dist = @last_frame_dist@
    >`20,7,state = @last_frame_state@
    >`20,8,time = @last_frame_time@
    >`20,9,stance = @last_frame_stance@
    loc.Pause()
  last_frame_armor = armor
  last_frame_hp = hp
  last_frame_foe = foe.id
  last_frame_dist = foe_dist
  last_frame_state = foe_s
  last_frame_time = foe_t
  last_frame_stance = stance
  last_frame_debuffs = _debuffs

func draw_ui()
  var x = 1
  var y = 22
  ?ui_show_debug
    y = 20
  ?ui_show_statuses
    >`@x@,@y@,#00A300,
    ^+ @string.Join(", ", st_good)@
    >`@x@,@y+1@,#FE6800,
    ^- @string.Join(", ", st_bad)@
    >`@x@,@y+2@,#F008B2,
    ^? @string.Join(", ", st_x)@
  ?ui_show_cd
    y = 6
    for r : all_abilities
      ?!move_r.Contains(r) & 
      ^can_use_abilities.Contains(r)
        var cd = get_cd(r)
        ?r = "skeleton_arm"
          r = "Arm"
        >`@x@,@y@,#@colorize(cd)@,
        ^@string.Capitalize(r)@ 
        ^@time.FormatDigital(cd)@
        y++
    >`@x@,@y@,
    ^#@colorize(get_cd("quarterstaff"))@,QS
    x = x + 2
    ?can_use_abilities.Contains("bash")
      >`@x@,@y@,@gray@,/
      x++
      >`@x@,@y@,
      ^#@colorize(get_cd("bash"))@,B
      x++
    ?can_use_abilities.Contains("dash")
      >`@x@,@y@,@gray@,/
      x++
      >`@x@,@y@,
      ^#@colorize(get_cd("dash"))@,D
      x++
  ?ui_show_debug
    x = 1
    y = 14
    ?foe
      >`@x@,@y@,@gray@,id: @foe.id@
      >`@x@,@y+1@,@gray@,State: @foe_s@
      >`@x@,@y+2@,@gray@,Time: @foe_t@
      >`@x@,@y+3@,@gray@,Dist: @foe_dist@
      >`@x@,@y+4@,@gray@,Count: @foe.count@
    y = 23
    >`@x@,@y@,#blue,Lock: @lock@ (@lock_timer@)
    >`@x@,@y+1@,#blue,Stance: @stance@
    >`@x@,@y+2@,@gray@,@loc.stars@* 
    ^@time.FormatDigital(totaltime)@ @foe@
    var _weapon = " (L)"
    x = screen.w - 10
    y = 23
    ?_equip_L
      x = x - string.Size(_equip_L)
      _weapon = _equip_L + _weapon
    >`@x@,@y@,#blue,@_weapon@
    _weapon = " (R)"
    x = screen.w - 10
    ?_equip_R
      x = x - string.Size(_equip_R)
      _weapon = _equip_R + _weapon
    >`@x@,@y+1@,#blue,@_weapon@
    
    var ey = 2
    for err : errors
      >`20,@ey@,#red,@err@
      ey++

func colorize(cd)
  ?cd > 0
    return "red"
  return "green"

func brew_pot()
  brew tar + bronze // vampiric

func reset_loop()
  lock = false
  lock_timer = 0
  at_boss = false
  swing_evaded = false
  dont_chill = false
  cache.Clear()
  st_x.Clear()
  enable_hit_tracking = false

?loc.begin
  _prepare_statuses()
  _prepare_items()
  _prepare_ranges()
  _prepare_abilities()
  ?item.potion = empty
    brew_pot()
  // ?loc = halls
  //   prefer_ranged = true
  //   ranged_types = ["wand"]
  // ?loc = caves
  //   prefer_ranged = true
:?loc.loop
  reset_loop()
:?ai.enabled & !ai.paused
  prelude()
  progress()
:
  idle()
draw_ui()