// "scribble"
// StoneScript automation for Stone Story RPG
// Ver. 1.1
// Project: https://github.com/livercat/scribble
// by livercat

/***************
**  #Intro    **
***************/
// Some variable names are shorter
// than I would prefer for readability,
// but Mindstone has line limit of 49 chars

// I use a mix of function arguments and
// global variables for various pieces of logic.
// I would prefer not to use global vars at all
// to make it harder to miss something and easier
// to follow the logic, but since we don't
// have optional or default arguments,
// functions would have very ugly signatures.
// So func argument are used for weapon switching
// where it's important to make sure everything
// lines up correctly.

// I also use a mix of conditional branching (:?)
// and early return from functions. Early returns
// reduce line lenght and make funcs more 
// readable. They are neat!

// Main logic is in following functions:
// draw_ui() - draws UI :)
// prelude() - collects info from game state
//   into global vars
// progress() - entry point for combat logic
//   and boss handling
// fight() - main logic for choosing range and
//   type of weapons/abilities
// melee(), ranged(), aoe(), elem() - equip
//   appropriate weapons

//  *** Table of Contents ***
// You can Ctrl-F for these anchors to quickly
// go to the corresponding code
//   #Weapons - configure your weapons
//   #Settings - runtime and UI settings
//   #Progress - (verb) entry point for the rest
//               of the combat logic
//   #Combat - logic for weapon switching 
//             and ability use
//   #Abilities - granular logic and conditions
//                for abilities' prerequisites
//   #Bosses - specific boss mechanics
//   #Internals - var declarations and boring
//                internal functions
//   #WeaponCache - we don't talk about that :<
//   #Runtime - actual place where the script is 
//              executed


/***************
**  #Weapons  **
***************/
// Format:
// ["weapon type",
//   ["element", "suffix1", .., "suffixN"]
// ]
// Only list items that you actually want to use,
// otherwise script can grab a random *0
// you got from a chest

// Full list of suffixes:
// Defensive: staffs, warhammers, shields
//   "au", "af", "ai", "ap", "ah", "A"
// Offensive: staffs, warhammers, swords, xbows
//   "dU", "dF", "dI", "dP", "dL", "D"
// Exclusive to staffs and warhammers:
//   "aU", "aF", "aI", "aP", "aL",
//   "du", "df", "di", "dp", "dh"

// Each elemental weapon aside from staffs
// and warhammers has two variants: "D" or "dX",
// where "X" is the elemental modifier
// ("A" and "ax" for shields).
// Staffs and warhammers instead have six! 
// "A", "D", "ax", "aX", "dx", "dX".
// You can mutate between them using moondial.

// Modifiers:
// "A": get armor on egage for each foe
// "D": attack bonus vs correct element
// "x": on being hit, chance to: unmake (aether),
//      fire dot, chill (ice), +attack (poison),
//      heal (vigor)
// "X": on attack, chance to: unmake (aether),
//      fire dot, chill (ice), lifesteal (vigor),
//      reduce foe attack (poison)

// Also note that vigor's modifiers are different
// between A and D variants:
// "L" for offensive lifesteal and "h" for
// defensive "heal on being hit",
// so there are no "l" or "H" modifiers.

var elemental_items = [
  ["warhammer", [
    ["aether", "D"],
  ]],
  ["wand", [
    ["fire", "D"],
    ["poison", "D"],
    ["vigor", "D"],
  ]],
  ["sword", [
    ["aether", "D"],
    ["fire", "dF"],
    ["ice", "dI"],
    ["poison", "dP"],
    ["vigor", "dL"],
  ]],
  ["shield", [
    ["vigor", "ah"],
    ["poison", "ap"],
  ]],
]
// [aether, fire, ice, poison, vigor]
var weapons = [
  ["sword", ["D"],
  ]],
  ["big sword", [
    ["fire", "D"],
    ["poison", "D"],
    ["vigor", "D"],
  ]],
  ["shield", [
    ["vigor", "ah"],
    ["poison", "ap"],
  ]],
  ["wand", [
    ["vigor", "ah"],
    ["poison", "ap"],
  ]],
]
var complex_weapons = [
  ["staff", [
    ["vigor", "ah"],
    ["poison", "ap"],
  ]],
  ["warhammer", [
    ["aether", "D"],
    ["fire", "dF"],
    ["ice", "dI"],
    ["poison", "dP"],
    ["vigor", "dL"],
  ]],

]
var warhammers = []
var wands = []
var swords = []
var shields = []
func cache_items()
  var arr
  for category : elemental_items
    ?category = "warhammer"
      arr = warhammers
    :?category = "wand"
      arr = wands
    :?category = "sword"
      arr = swords
    :?category = "shield"
      arr = shields
    for element : category

// type: wand, sword, etc
// element: aether, fire, etc
// for_debuff: bool (true/false)
func get_item(type, element, for_debuff)
  

// Items with special abilities.
// Supported: "dashing", "bardiche", 
// "heavy hammer"
var special_items = [
  "dashing", "bardiche", "heavy hammer",
]
// Lost Items
// Supported: bashing, blade, arm
var lost_items = [
  "bashing", "blade", "arm",
]

// Weapon type to prefer for melee aoe
// "staff", "bardiche", "heavy hammer" will 2h.
// "wands", "big swords" will dual-wield 1h.
// "" will disable melee aoe and will dual-wield
// or 1h + shield
var melee_aoe = "bardiche"
// Weapon type to prefer for ranged aoe
// "staff" will 2h, "wands" will dual-wield 1h.
// "" will disable ranged aoe except
// for phys-immune foes and will use repeating
// xbow instead.
var ranged_aoe = "wands"

// Ranged single target
var ranged_st = "repeating crossbow"

/*********************
**     #Settings    **
*********************/

// Show ability cooldowns
var ui_show_cd = true
// Show your buffs/debuffs
var ui_show_statuses = true
// Show debug info (noisy, useful for research)
var ui_show_debug = true

// How many regular enemies are needed
// to start using AOE weapons instead of
// single target
var aoe_treshold = 4

// Low HP threshold in fraction of 1.
// When on low HP, will prioritize vigor shield
// and weapons over dps
var low_hp_threshold = 0.5

// Find a suitable amount based on your dI weapon
var max_chill = 6

// Slower but safer, useful if you don't have 
// good melee weapons, but have a repeating xbow
var prefer_ranged = false

// Set to true if you're doing Pallas quests
// for the Blade.
// Stages: "bolesh"
var smite_quest = "bolesh"
// Depends on level/enchants of the Blade
var smite_damage = 85
// At least this many enemies must be present
// to trigger Smite
var smite_treshold = 7

// set to true if you're doing Skeleton Arm
// quests.
// It will prioritize pickpocketing in combat,
// and will try to only use it when non-boss foes
// will die from the ability
var pickpocket_quest = false
// These depend on level/enchants of the Arm
var arm_damage = 32
var max_pickpocket = 2

/*********************
**     #Progress    **
*********************/
func progress()
  ?healwalk() // no enemies nearby
    return true
  :?foe = undamageable
    return shield_block(true)
  :?!is_boss & !at_boss
    // regular enemies
    free_mind = true
    return fight()

  // only bosses below
  stance = "boss combat"
  ?loc = rocky // TODO handle courier boss
    fight_dysan()
  :?loc = deadwood
    fight_xyloalgia()
  :?loc = caves
    fight_bolesh() // TODO ceiling decorator
  :?loc = fungus_forest_boss
    fight_mushroom()
  :?loc = undead_crypt_boss
    fight_pallas()
  :?loc = bronze_guardian
    fight_bronze_guardian()
  :?loc = icy_ridge
    fight_hrimnir()
  :?loc = nagaraja
    fight_nagajara()
  :
    // unknown boss
    melee_boss("auto")

func idle()
  stance = "out of combat"
  ?pickup.distance < 8
    equipL star
    equipR triskelion
  :?hp < maxhp
    equipL ouroboros
    equipR triskelion
  :
    equipL triskelion
    shield()
  return true

func healwalk()
  ?foe & foe_dist < 23
    ?hp < (maxhp / 4) & item.potion ! empty &
    ^(item.potion = "healing" | 
    ^item.potion = "vampiric")
      activate potion
    return false // start combat instead
  :?pickup.distance < 8
    equipL star
    equipR triskelion
  :?can_qs_dash()
    qs_dash()
  :
    idle()
  stance = "out of combat"
  return true // continue healwalking

/********************
**     #Combat    **
********************/
// TODO: need to move wands out of ranged into aoe or elemental
func fight()
  // chooses general approach to the combat
  ?foe_dist < 7 & mindCD <= 0 & foe = explode
    return backflip()
  :?phys_immune | foe = magic_vulnerability
    return auto_elemental()
  :?foe_dist < 8 & pickpocket_quest 
  ^& should_slap()
    return slap() // prioritize skeleton quest
  :?must_melee_foe()
    return auto_melee()
  :?prefer_ranged | must_ranged_foe()
    return auto_ranged()
  :?foe_dist > 16 | (foe_dist > 10 & can_aoe)
    return auto_ranged()
  :
    return auto_melee()

func auto_melee()
  ?use_abilities()
    return true
  :?low_hp
    return melee("def")
  :?can_aoe & foe_dist < 8
    return aoe("melee")
  :
    return melee("dps")

// mode: "dps" | "def"
func melee(mode)
  ?mode = "def"
    stance = "melee def"
  :?mode = "dps"
    stance = "melee dps"
  :
    dbg("unsupported mode for " +
    ^"melee(): " + mode)
    return false
  _found = get_1h_weapon("melee")
  ?!_found
      dbg("can't find melee weapon for mode=" + 
      ^mode)
    _found = "sword"
  return left_hand(_found) & 
  ^offhand(mode, "melee")

func auto_ranged()
  ?use_abilities()
    return true
  :?foe_dist > 20 & !phys_immune
    return ranged("single")
  :?low_hp
    return ranged("def")
  :?can_aoe
    return aoe("ranged")
  :
    return ranged("dps")

// mode: "dps" | "def" | "single"
func ranged(mode)
  ?mode = "def"
    stance = "ranged def"
  :?mode = "dps"
    stance = "ranged dps"
  :?!(mode = "single")
    dbg("unsupported mode for ranged(): " +
    ^mode)
    return false
  ?(foe = magic_resist | mode = "single") & 
  ^best_wpns[t_best_2h_r]
    stance = "ranged single target"
    equip @best_wpns[t_best_2h_r]@
    return
  _found = get_1h_weapon("ranged")
  ?!_found
    ?mode = "dps" & best_wpns[t_best_2h_r]
      stance = "ranged single target"
      equip @best_wpns[t_best_2h_r]@
      return
    :
      dbg("can't find ranged wand for mode=" + 
      ^mode)
      _found = "wand"
  return left_hand(_found) & 
  ^offhand(mode, "ranged")

func auto_elemental()
  ?use_abilities()
    return true
  :?foe_dist <= 11 & foe_ehp > 0 & can_backflip()
    return backflip()
  :?low_hp
    return elemental("def")
  :
    return elemental("dps")

// mode: "dps" | "def"
func elemental(mode)
  _found = get_1h_weapon("ranged")
  ?!_found
    dbg("can't find elemental wand for mode=" + 
    ^mode)
    _found = "wand"
  left_hand(_found)
  ?mode = "def"
    stance = "elemental def"
    return offhand(mode, "shield")
  :?mode = "dps"
    stance = "elemental dps"
    return offhand(mode, "ranged")
  :
    dbg("unsupported mode for elemental(): " +
    ^mode)
    return false

// mode: "melee" | "ranged"
func aoe(mode)
  ?mode = "ranged"
    stance = "ranged aoe"
    _found = get_1h_weapon("ranged")
    ?!_found
      dbg("can't find aoe wand for mode=" + 
      ^mode)
      _found = "wand"
    return left_hand(_found) & 
    ^offhand("dps", "ranged")
  :?mode = "melee"
    ?best_wpns[t_best_2h_m]
      equip @best_wpns[t_best_2h_m]@
      return true
    :
      return melee("def")
  :
    dbg("unsupported mode for aoe(): " +
    ^mode)
    return false

func left_hand(weapon)
  _used = weapon
  equipL @weapon@
  return true

// mode: "dps" | "def"
// type: "ranged" | "melee" | "shield"
func offhand(mode, type)
  ?type ! "ranged" & dash()
    return true
  :?mode = "def"
    shield()
  :?mode = "dps"
    _found = get_1h_weapon(type)
    ?_found
      equipR @_found@
    :
      dbg("can't find offhand for mode=" + 
      ^mode + ", type=" + type)
      shield()
  :
    dbg("unsupported mode for " +
    ^"offhand(): " + mode)
    return false
  return true

func shield()
  _found = get_1h_weapon("shield")
  ?_found
    equipR @_found@
  :
    dbg("can't find shield")
    equipR shield
  return true

func dash()
  ?!disable_dash & 
  ^foe_dist >= 10 & foe_dist <= 16 &
  ^(bashCD <= 0 | dashCD <= 0) &
  ^can_activate()
    ?ability_wpns[bash_idx] & bashCD <= 0 &
    ^!disable_bash
      equipR @bashing@
      return true
    :?ability_wpns[dash_idx] & dashCD <= 0
      equipR @dashing@
      return true
  return false

// type: "ranged" | "melee" | "shield"
func get_1h_weapon(type)
  ?type = "melee"
    ?foe.armor > 0
      type = t_aa
    :
      type = t_1h
  :?type = "ranged"
    type = t_wand
  :?type = "shield"
    type = t_shield
  :
    dbg("unsupported type for " +
    ^"get_1h_weapon(): " + type)
    return false
  // maybe heal up
  ?(aether_foe | low_hp) & 
  ^available(vigor_wpns[type])
    return vigor_wpns[type]
  // then find correct element
  :?fire_foe & available(aether_wpns[type])
    return aether_wpns[type]
  :?ice_foe & available(fire_wpns[type])
    return fire_wpns[type]
  :?poison_foe & available(ice_wpns[type])
    return ice_wpns[type]
  :?vigor_foe & 
  ^available(poison_wpns[type])
    return poison_wpns[type]
  // then your best weapon
  :?available(best_wpns[type])
    return best_wpns[type]
  // then best offhand
  :?type < 3 & available(best_wpns[type + 4])
    return best_wpns[type + 4]
  // then another best melee type
  :?type = t_aa
    ?available(best_wpns[t_1h])
      return best_wpns[t_1h]
    :?available(best_wpns[t_1h + 4])
      return best_wpns[t_1h + 4]
  :?type = t_1h
    ?available(best_wpns[t_aa])
      return best_wpns[t_aa]
    :?available(best_wpns[t_aa + 4])
      return best_wpns[t_aa + 4]
  return false

func available(weapon)
  return weapon ! false & 
  ^(!_used | _used ! weapon)

func shield_block(stay_still)
  stance = "shield block"
  ?stay_still
    equipL quest
  shield()

func must_ranged_foe()
  return foe = mosquito | 
  ^foe = huge_mosquito | 
  ^foe = fire_elemental | foe = ant

func must_melee_foe()
  return foe = immune_to_ranged | foe = ranged | 
  ^foe = cult_guard // poisons on being hit

// mode: "dps" | "def" | "auto"
func melee_boss(mode)
  ?mode = "auto"
    ?low_hp
      mode = "def"
    :
      mode = "dps"
  ?!use_abilities() // if no abilities are done
    ?!debuff(mode) // and no debuffs are needed
      return melee(mode)

// mode: "dps" | "def"
func debuff(mode)
  // note: don't bother debuffing
  // regular eneimes, it's faster to kill them
  ?foe_buffs = disable_debuff | 
  ^foe_buffs = mirror
    return false
  _found = false
  ?!(foe_debuffs = foe_poisoned) &
  ^!(foe = immune_to_debuff_damage)
    _found = poison_1h
  :?!(foe_debuffs = foe_on_fire) &
  ^!(foe = immune_to_debuff_dot)
    _found = fire_1h
  :?!(foe_debuffs = max_chill_s) &
  ^!(foe = immune_to_debuff_chill)
    _found = ice_1h
  ?_found
    stance = "debuffing"
    left_hand(_found)
    ?mode = "def"
      offhand(mode, "shield")
    :?mode = "dps"
      offhand(mode, "melee")
    :
      dbg("unsupported mode for " +
      ^"debuff(): " + mode)
    return true
  :
    return false

func aac(weapon)
  // attack animation cancelling:
  // equipping a different weapon
  // right after the attack cancels
  // the backswing animation,
  // effectively increasing your
  // attack speed
  ?weapon = heavy_ham
    // clips itself too much
    equip @weapon@
    return
  ?ai.idle & !berserk & !slowed
    equip wand
  equip @weapon@
  return true

/********************
**    #Abilities   **
********************/

// Note on functions below:
// can_<something>() checks hard prerequisites:
//   cooldowns, statuses, etc.
// should_<something>() checks fight logic:
//   number of enemies, statuses, etc.
// <something>() actually uses trues to use
//   the ability without doing checks itself

// quarterstaff
func can_qs_dash()
  return staffCD <= 0 & can_activate()

// quarterstaff
func qs_dash()
  equip quarterstaff
  ?item.CanActivate("quarterstaff")
    activate R

// Mind Stone
func can_backflip()
  // don't check this condition
  // for boss mechanics (when free_mind is false)
  return free_mind & mindCD <= 0 &
   // don't jump into the wall
  ^screen.FromWorldX(pos.x) > 5
  
// Mind Stone
func backflip()
  stance = "mind stone R"
  equipL mind
  shield()

// skeleton arm
func can_slap()
  ?!ability_wpns[arm_idx] | foe_dist > 6 |
  ^phys_immune | disable_abilities |
  ^!can_activate()
    return false
  ?pp_amount < max_pickpocket & !slowed & !low_hp
    return true // get to max buffs
  return armCD > 0 & !disable_steal &
  ^pp_amount >= max_pickpocket

// skeleton arm
func should_slap()
  return can_slap() & (!pickpocket_quest |
  ^foe_ehp <= edmg(arm_damage))

// skeleton arm
func slap()
  stance = "skeleton arm R"
  aac(arm)
  ?pp_amount >= max_pickpocket &
  ^item.CanActivate("skeleton_arm")
    activate R
  return true

// blade of the fallen god
func can_smite()
  return ability_wpns[blade_idx] & smiteCD <= 0 &
  ^!disable_abilities &
  ^foe ! pallas & // immune?
  ^can_activate()

// blade of the fallen god
func should_smite()
  return (is_boss | foe.count >= smite_treshold &
  ^foe_ehp<=edmg(smite_damage)) & can_smite()

// blade of the fallen god
func smite()
  stance = "smite R"
  aac(blade)
  ?item.CanActivate("blade")
    activate R
  return true

// heavy hammer
func can_hammer()
  return ability_wpns[ham_idx] & !phys_immune & 
  ^!disable_abilities & foe_dist <= 7 &
  ^(hammerCD <= 0 | hammerCD >= 647) &
  ^can_activate()

// heavy hammer
func should_hammer()
  return foe.armor > 0 & (is_boss | can_aoe) & 
  ^can_hammer()

// heavy hammer
func hammer()
  stance = "heavy hammer R"
  aac(heavy_ham)
  ?item.CanActivate("hammer")
    activate R
  return true

// bardiche
func can_bard()
  return ability_wpns[bard_idx] & foe_dist <= 9 &
  ^(bardCD <= 0 | bardCD >= 870) &
  ^!disable_abilities & !phys_immune &
  ^can_activate()

// bardiche
func should_bard()
  return is_boss & can_bard()

// bardiche
func bardiche()
  stance = "bardiche R"
  aac(bard)
  ?item.CanActivate("bardiche")
    activate R
  return true

func use_abilities()
  ?disable_abilities
    return false
  ?should_hammer()
    return hammer()
  ?should_smite()
    return smite()
  ?should_bard()
    return bardiche()
  ?should_slap()
    return slap()
  return false

func can_activate()
  return ai.enabled & item.CanActivate()

/*****************
**    #Bosses   **
*****************/

func fight_dysan()
  ?foe = phase1
    disable_steal = true
    ?foe.state = 33 & 
    ^foe.time > 23 & foe.time < 26
      // evade big attack
      return melee("def")
    melee_boss("auto")
  :?foe = phase2
    // just match elements
    disable_steal = true
    melee_boss("auto")
  :?foe = phase3
    ?foe.state = 32 & foe.time > 90 |
    ^foe.state = 33 & foe.time < 2
      // prepare for attack
      return melee("def")
    :?foe.state = 115
      ?foe.time = 60
        // dodge the orb ray
        return backflip()
      :?foe.time < 80
        // don't dash into ray
        disable_dash = true
    :?foe.state = 106 | foe.state = 108 |
    ^foe.state = 0
      // transitions
      disable_abilities = true
    :?foe.state = 107 | foe.state = 32
      disable_steal = true
    melee_boss("dps")

func fight_xyloalgia()
  ?foe = phase1
    // Xyloalgia
    return melee_boss("auto")
  // Poena
  disable_steal = true
  ?foe.state = 32 & foe.time > 40
    shield_block(false)
  :?foe_buffs = mirror
    // try to avoid debuffing yourself
    disable_bash = true
    ?use_abilities()
      return
    ?vigor_wpns[t_1h]
      left_hand(vigor_wpns[t_1h])
      shield()
    :?aether_wpns[t_1h]
      left_hand(aether_wpns[t_1h])
      shield()
    :?best_wpns[t_1h]
      left_hand(best_wpns[t_1h])
      shield()
    :
      melee("def")
  :
    melee_boss("auto")

func fight_bolesh()
  ?loc.stars > 5
    disable_steal = true
  ?foe.state = 133 &
  ^(foe.time > 12 & foe.time < 18)
    // try to evade bites
    shield_block(true)
  :?(bardCD <= 0 | bardCD >= 870) &
  ^mindCD <= 0
    melee_boss("auto")
  :?mindCD <= 0 & foe_dist < 10
    backflip()
  :
    ranged("single")

func fight_mushroom()
  ?loc.stars > 5 & foe = phase1
    disable_steal = true
  melee_boss("auto")

func fight_pallas()
  at_boss = true
  disable_steal = true
  ?foe.count > 4
    ?foe_dist < 15 & mindCD <= 0
      backflip()
    :
      elemental("dps")
  :
    melee_boss("auto")

func fight_bronze_guardian()
  disable_steal = true
  ?foe.state = 32 & foe.time = 30
    backflip() // dodge the hammer
  :?foe.state = 33
    // hammer is down
    ?!use_abilities()
      melee("dps") // don't bother debuffing
  :?foe_dist > 15 & foe.state = 2
    ranged("single")

func fight_hrimnir()
  at_boss = true
  ?is_boss & foe.armor > 0
    // initial ice block
    ?should_slap()
      slap() // get free evade stacks
    :
      melee("dps") // don't debuff
  :?loc.stars <= 5 // try to cheese
    ?foe_dist <= 2
      ?!use_abilities()
        melee("dps") // don't debuff
    :?foe_dist <= 5
      // The shovel has an attack range of 1
      // so at white stars we can avoid
      // snowballs by getting close to boss.
      // on higher stars he blows you away
      // immediately
      equip shovel
    : // blown away
      ?slowed
        ranged("single")
      :
        auto_melee()
  :?foe.state = 143 | foe.state = 144 // blowing
    ranged("single")
  :?foe.count > 1 // deal with adds
    ?slowed // don't waste time on movement
      ?foe_dist < 7
        auto_melee()
      :?foe.count > 2
        aoe("ranged")
      :
        ranged("single")
    :?can_smite()
      smite()
    :?can_bard() & foe = ice_wall
      bardiche()
    :?foe.count > 2 // elementals
      aoe("melee")
    :
      auto_melee() // ice wall
  :?slowed
    // don't waste time on movement
    ranged("single")
  :
    melee_boss("auto")

func fight_nagajara()
  disable_steal = true
  // goal is to dodge poison balls
  var x = screen.FromWorldX(pos.x)
  var y = screen.FromWorldZ(pos.z)
  // _detect_poison(x, y) // debug and research

  ?is_poison_near(x, y)
    naga_step++

  ?naga_step = 0
    // start at the xbow range
    ranged("single")
  :?naga_step = 1
    // staff 1st poison
    qs_dash()
    naga_step++
  :?naga_step = 2
    // and continue to shoot
    ranged("single")
  :?naga_step = 3
    // dash into melee
    melee_boss("dps")
  :?naga_step >= 4
    ?mindCD <= 0
      // dodge back and repeat
      backflip()
      naga_step = 0
    :
      // mind stone on CD, try to def
      melee_boss("def")

func is_poison_near(pos_x, pos_y)
  // long and mid range
  ?draw.GetSymbol(pos_x+2, pos_y-6) = "(" |
  // melee
  ^(draw.GetSymbol(pos_x+1, pos_y-6) = "(")
    return true
  return false

func _detect_poison(pos_x, pos_y)
  >`0,0,x=@x@, y=@y@
  for px = pos_x .. pos_x+10
    for py = pos_y-6 .. pos_y
      ?draw.GetSymbol(px, py) = "("
        cache.Add([pos_x, pos_y, px, py])
  arr_size = cache.Count()
  ?arr_size > 0
    for line = 1 .. arr_size
      var v = cache[line-1]
      >`0,@line@,x=@v[0]@, y=@v[1]@, 
      ^px=@v[2]@, py=@v[3]@;

/*********************
**     #Internals   **
*********************/
// `var`s are only initialized once per zone
// and don't reset between loops.
// We can use this to cache some calculations
// so we don't redo them every frame.
// Arrays are especially important, because 
// they're costly to initialize. 
// Use `array.Clear()` instead of `array = []`
// to reset it.

// constants
var ignore_st = [ // irrelevant statuses
  "quarterstaff_buff_attack_speed",
  "quarterstaff_buff_stun",
  "bardiche_buff_aoe_chance",
  "bardiche_buff_crit_chance",
  "bardiche_buff_crit_mult",
  "bardiche_buff_move_speed",
]
var statuses = [
^["smite", "Smite", "+"], 
^["pick_pocket", "Pickpocket", "+"],
^["vampiric", "Vamp", "+"],
^["lucky_crit_multi", "Lucky", "+"],
^["debuff_damage", "DmgDown", "-"],
^["debuff_duration_damage", "DmgDown", "-"],
^["spider_debuff_damage", "DmgDown", "-"],
^["dysangelos_debuff_damage", "DmgDown", "-"],
^["debuff_yeti_chill", "AtkSlow", "-"],
^["debuff_attack_speed", "AtkSlow", "-"],
^["debuff_move_speed", "MoveSlow", "-"],
^["debuff_chill", "Chill", "-"],
^["stun", "Stun", "-"],
^["pallas_phase2_debuff", "RangeDown", "-"],
^["debuff_dot", "FireDoT", "-"],
]
var dmg_debuffs = [
^"debuff_damage", "debuff_duration_damage",
^"spider_debuff_damage",
]
var slow_debuffs = [
^"debuff_chill", "debuff_move_speed"
]
var stun_debuff = "stun"
var max_chill_s = "❄:debuff_chill:" + 
^max_chill + ":"
var foe_poisoned = "∞:debuff_damage:1:"
var foe_on_fire = "φ:debuff_dot:1:"
var disable_debuff = "buff_protection"
var mirror = "poena_mirror"
var pickpocket_buff = "pick_pocket"

// global vars below
// misc
var at_boss = false // to deal with adds
var naga_step = 0 // nagaraja fight
// player status
var stance = "unknown" // chosen combat stance
var low_hp = 0 // hp < (maxhp / 2)
var dmg_down = 0 //total dmg debuff (poison, etc) 
var slowed = false // is player slowed
var stunned = false // is player stunned
var berserk = false // berserk potion TODO
var can_aoe = false // foe.count >= aoe_treshold
var pp_amount = 0 // pickpocket buff amount
// abilities
var free_mind = false // can use mindstone freely
var disable_abilities = false // for some bosses
var disable_steal = false // for some bosses
var disable_dash = false // for some bosses
var disable_bash = false // for poena
// foe status
var foe_ehp = 0 // foe.armor + foe.hp
var phys_immune = false // immune to physical
var foe_buffs = "" // foe.buffs.string
var foe_debuffs = "" // foe.debuffs.string
var foe_dist = 0 // foe.distance
var aether_foe = false // foe = aether
var fire_foe = false // foe = fire
var ice_foe = false // foe = ice
var poison_foe = false // foe = poison
var vigor_foe = false // foe = vigor
var is_boss = false // foe = boss
// cooldowns
var mindCD = 0
var staffCD = 0
var bashCD = 0
var dashCD = 0
var armCD = 0
var hammerCD = 0
var smiteCD = 0
var bardCD = 0
var maskCD = 0

// Pre-define vars for internal functions.
// no idea if it matters for performance,
// but why not.
// Except weapon switching: it breaks
// spectacularly if you reuse the same global
// var for multiple values in a single frame.
var _used = false
var _found = false
// status handling
var splt = [] // splitted buff/debuff string
var st_uid = ""
var st_amount = 0
var st_info = []
var st_dur = 0
var st_s = ""
var st_good = [] // current buffs
var st_bad = [] // current debuffs
var st_x = [] // unknown status effects
var status_uids = []
var arr_size = 0
var idx = 0
var errors = []
var cache = []

func _fill_status_uids()
  for st_info : statuses
    status_uids.Add(st_info[0])

func some(s)
  // true if string is not empty
  return ! string.Equals(s, "")

func edmg(dmg)
  // effective damage after considering debuffs
  return dmg - dmg_down

func parse_statuses()
  st_good.Clear()
  st_bad.Clear()
  dmg_down = 0
  pp_amount = 0
  slowed = false
  berserk = false
  stunned = false
  for s : [buffs.string, debuffs.string]
    // format: *:name:count:duration,...
    splt = string.Split(s, ":", ",", false)
    arr_size = splt.Count()
    ?arr_size > 0
      // iterate over names (2nd field)
      for i = 1 .. arr_size - 3
        st_uid = splt[i]
        st_amount = int.Parse(splt[i+1])

        // flags for combat logic
        ?dmg_debuffs.IndexOf(st_uid) ! -1
          dmg_down = dmg_down + st_amount
        :?slow_debuffs.IndexOf(st_uid) ! -1
          slowed = true
        :?st_uid = stun_debuff
          stunned = true
        :?st_uid = pickpocket_buff
          pp_amount = st_amount

        idx = status_uids.IndexOf(st_uid)
        ?idx ! -1
          st_info = statuses[idx]
          st_dur = int.Parse(splt[i+2])

          st_s = string.Format("{0}({1}) {2}",
          ^st_info[1], st_amount,
          ^time.FormatDigital(st_dur))

          ?st_info[2] = "+"
            st_good.Add(st_s)
          :
            st_bad.Add(st_s)

        :?ignore_st.IndexOf(st_uid) = -1 &
        ^st_x.IndexOf(st_uid) = -1
          // log unknown statuses for debug
          st_x.Add(st_uid)

        i = i + 3

func prelude()
  parse_statuses()

  // reset/update dynamic global vars
  disable_steal = false
  disable_dash = false
  disable_bash = false
  free_mind = false
  ?stunned
    disable_abilities = true
  :
    disable_abilities = false
  _used = false
  stance = "unknown"
  low_hp = hp < (maxhp / 2)
  foe_ehp = foe.armor + foe.hp
  foe_dist = foe.distance
  foe_buffs = foe.buffs.string
  foe_debuffs = foe.debuffs.string
  is_boss = (foe = boss)
  phys_immune = (foe = immune_to_physical)
  can_aoe = (foe.count >= aoe_treshold)

  aether_foe = (foe = aether)
  fire_foe = (foe = fire)
  ice_foe = (foe = ice)
  poison_foe = (foe = poison)
  vigor_foe = (foe = vigor)

  mindCD = item.GetCooldown("mind")
  staffCD = item.GetCooldown("quarterstaff")
  bashCD = item.GetCooldown("bash")
  dashCD = item.GetCooldown("dash")
  armCD = item.GetCooldown("skeleton_arm")
  hammerCD = item.GetCooldown("hammer")
  smiteCD = item.GetCooldown("blade")
  bardCD = item.GetCooldown("bardiche")
  maskCD = item.GetCooldown("mask")

func dbg(e)
  ?ui_show_debug
    ?errors.IndexOf(e) = -1
      errors.Add(e)

func draw_ui()
  ?ui_show_statuses
    >`1,22,#00A300,+ @string.Join(", ", st_good)@
    >`1,23,#FE6800,- @string.Join(", ", st_bad)@
    >`1,24,#F008B2,? @string.Join(", ", st_x)@

  ?ui_show_cd
    var cd_ui_y = 6
    >`1,@cd_ui_y@,#@colorize(mindCD)@,Mind 
    ^@time.FormatDigital(mindCD)@
    ?have_hammer
      cd_ui_y++
      >`1,@cd_ui_y@,#@colorize(hammerCD)@,
      ^Hammer @time.FormatDigital(hammerCD)@
    ?have_bard
      cd_ui_y++
      >`1,@cd_ui_y@,#@colorize(bardCD)@,
      ^Bard @time.FormatDigital(bardCD)@
    ?have_blade
      cd_ui_y++
      >`1,@cd_ui_y@,#@colorize(smiteCD)@,
      ^Blade @time.FormatDigital(smiteCD)@
    ?have_arm
      cd_ui_y++
      >`1,@cd_ui_y@,#@colorize(armCD)@,
      ^Arm @time.FormatDigital(armCD)@
    ?have_mask
      cd_ui_y++
      >`1,@cd_ui_y@,#@colorize(maskCD)@,
      ^Mask @time.FormatDigital(maskCD)@

  ?ui_show_debug
    >`1,21,#blue,Stance: @stance@
    ?foe
      >`1,13,#7A8F93,+ @foe_buffs@
      >`1,14,#7A8F93,id: @foe.id@
      >`1,15,#7A8F93,State: @foe.state@
      >`1,16,#7A8F93,Time: @foe.time@
      >`1,17,#7A8F93,Dist: @foe_dist@
      >`1,18,#7A8F93,Count: @foe.count@
      >`1,25,#7A8F93,@foe@
    var ey = 2
    for err : errors
      >`15,@ey@,#red,@err@
      ey++

func colorize(cd)
  ?cd > 0 | disable_abilities
    return "red"
  return "green" // ready

func brew_pot()
  brew tar + bronze // vampiric

func reset_loop()
  at_boss = false
  naga_step = 0
  cache.Clear()
  st_x.Clear()

/********************
**   #WeaponCache  **
********************/

// I want to support cases where you don't
// have particular weapons, and do it efficiently
// and ergonomically.
// Unfortunately, StoneScript is quite limited,
// and without hashmaps and ternary operators
// we have a lot of boilerplate :(
// warning: scary stuff below

// cache weapon info, it never changes mid-zone.
// to do this, we package caching logic into
// functions and call them once, on `loc.begin`

// arrays with weapons, arranged in
// particular order (see various `idx`).
// this looks very gnarly, but with these arrays
// we can easily check the weapon existence and
// equip it (or use an ability):
// ?aether_wpns[t_1h]
//   equipL @aether_wpns[t_1h]@

// items with active abilities
var ability_wpns = []
var ham_idx = 0
var bard_idx = 1
var dash_idx = 2
var bash_idx = 3
var arm_idx = 4
var blade_idx = 5
func _cache_ability_weapons()
  ?some(heavy_ham)
    ability_wpns.Add(heavy_ham)
  :
    ability_wpns.Add(false)
  ?some(bard)
    ability_wpns.Add(bard)
  :
    ability_wpns.Add(false)
  ?some(dashing)
    ability_wpns.Add(dashing)
  :
    ability_wpns.Add(false)
  ?some(bashing)
    ability_wpns.Add(bashing)
  :
    ability_wpns.Add(false)
  ?some(arm)
    ability_wpns.Add(arm)
  :
    ability_wpns.Add(false)
  ?some(blade)
    ability_wpns.Add(blade)
  :
    ability_wpns.Add(false)
  ?some(mask)
    ability_wpns.Add(mask)
  :
    ability_wpns.Add(false)
// best weapons and shields.
// indexes 0-3 match elemental weapon
// indexes to simplify weapon selection:
// offhand for the type is type + 4
var best_wpns = []
var t_best_1h_off = 4
var t_best_aa_off = 5
var t_best_wand_off = 6
var t_best_2h_m = 7 // melee 2-hander
var t_best_2h_r = 8 // ranged 2-hander
func _cache_best_weapons()
  ?some(best_1h)
    best_wpns.Add(best_1h)
  :
    best_wpns.Add(false)
  ?some(best_aa)
    best_wpns.Add(best_aa)
  :
    best_wpns.Add(false)
  ?some(best_wand)
    best_wpns.Add(best_wand)
  :
    best_wpns.Add(false)
  ?some(best_shield)
    best_wpns.Add(best_shield)
  :
    best_wpns.Add(false)
  ?some(best_1h_offhand)
    best_wpns.Add(best_1h_offhand)
  :
    best_wpns.Add(false)
  ?some(best_aa_offhand)
    best_wpns.Add(best_aa_offhand)
  :
    best_wpns.Add(false)
  ?some(best_wand_offhand)
    best_wpns.Add(best_wand_offhand)
  :
    best_wpns.Add(false)
  ?some(melee_aoe)
    best_wpns.Add(melee_aoe)
  :
    best_wpns.Add(false)
  ?some(ranged_2h)
    best_wpns.Add(ranged_2h)
  :
    best_wpns.Add(false)
// elemental weapons and shields
var aether_wpns = []
var fire_wpns = []
var ice_wpns = []
var poison_wpns = []
var vigor_wpns = []
var t_1h = 0 // 1-hander
var t_aa = 1 // anti-armor
var t_wand = 2
var t_shield = 3
func _cache_aether_weapons()
  ?some(aether_1h)
    aether_wpns.Add(aether_1h)
  :
    aether_wpns.Add(false)
  ?some(aether_aa)
    aether_wpns.Add(aether_aa)
  :
    aether_wpns.Add(false)
  ?some(aether_wand)
    aether_wpns.Add(aether_wand)
  :
    aether_wpns.Add(false)
  ?some(aether_shield)
    aether_wpns.Add(aether_shield)
  :
    aether_wpns.Add(false)
func _cache_fire_weapons()
  ?some(fire_1h)
    fire_wpns.Add(fire_1h)
  :
    fire_wpns.Add(false)
  ?some(fire_aa)
    fire_wpns.Add(fire_aa)
  :
    fire_wpns.Add(false)
  ?some(fire_wand)
    fire_wpns.Add(fire_wand)
  :
    fire_wpns.Add(false)
  ?some(fire_shield)
    fire_wpns.Add(fire_shield)
  :
    fire_wpns.Add(false)
func _cache_ice_weapons()
  ?some(ice_1h)
    ice_wpns.Add(ice_1h)
  :
    ice_wpns.Add(false)
  ?some(ice_aa)
    ice_wpns.Add(ice_aa)
  :
    ice_wpns.Add(false)
  ?some(ice_wand)
    ice_wpns.Add(ice_wand)
  :
    ice_wpns.Add(false)
  ?some(ice_shield)
    ice_wpns.Add(ice_shield)
  :
    ice_wpns.Add(false)
func _cache_poison_weapons()
  ?some(poison_1h)
    poison_wpns.Add(poison_1h)
  :
    poison_wpns.Add(false)
  ?some(poison_aa)
    poison_wpns.Add(poison_aa)
  :
    poison_wpns.Add(false)
  ?some(poison_wand)
    poison_wpns.Add(poison_wand)
  :
    poison_wpns.Add(false)
  ?some(poison_shield)
    poison_wpns.Add(poison_shield)
  :
    poison_wpns.Add(false)
func _cache_vigor_weapons()
  ?some(vigor_1h)
    vigor_wpns.Add(vigor_1h)
  :
    vigor_wpns.Add(false)
  ?some(vigor_aa)
    vigor_wpns.Add(vigor_aa)
  :
    vigor_wpns.Add(false)
  ?some(vigor_wand)
    vigor_wpns.Add(vigor_wand)
  :
    vigor_wpns.Add(false)
  ?some(vigor_shield)
    vigor_wpns.Add(vigor_shield)
  :
    vigor_wpns.Add(false)

/****************
**   #Runtime  **
****************/
?loc.begin
  _cache_ability_weapons()
  _cache_best_weapons()
  _cache_aether_weapons()
  _cache_fire_weapons()
  _cache_ice_weapons()
  _cache_poison_weapons()
  _cache_vigor_weapons()
  _fill_status_uids()
  ?item.potion = empty
    brew_pot()
:?loc.loop
  reset_loop()
:?ai.enabled & !ai.paused
  prelude()
  progress()
  draw_ui()
:
  idle()