var elemental_items = [
  ["warhammer", 
    ["aether", "D"],
    ["poison", "D"],
    ["ice", "D"],
  ],
  ["wand", 
    ["fire", "D"],
    ["poison", "D"],
    ["vigor", "D", "dL"],
  ],
  ["sword", 
    ["aether", "D"],
    ["fire", "dF"],
    ["ice", "dI"],
    ["poison", "dP", "D"],
    ["vigor", "dL"],
    ["default", "vigor sword dL"],
  ],
  ["shield", 
    ["vigor", "ah"],
    ["poison", "A"],
    ["ice", "A"],
    ["aether", "A"],
    ["default", "compound"],
  ],
]

/* Listed item types will be used to find
a weapon for specific range when 
`foe.count < aoe_treshold`. Any weapon types
are supported in both lists. Script will search:
1) type1 + foe_weakness_element
2) type1 + default
If still nothing is found, type2 is checked 
the same way, and so on. If still nothing is
found, then repeat all these steps for each
element except foe's strong element. If foe
has armor, "warhammer" and "heavy hammer" will 
be used for melee first if they're listed. */
var melee_types = [
  "sword", "big sword", "warhammer",]
var ranged_types = [
  "repeating", "wand", "staff", "crossbow",]
/* same but for `foe.count >= aoe_treshold`. If
empty, then will use lists above */
var melee_aoe_types = [
  "bardiche", "big sword", "heavy hammer",]
var ranged_aoe_types = [
  "wand", "staff", "crossbow", "repeating",]

/* If item is not listed here, its R ability
won't be used. Supported: dash, bash, 
bardiche, hammer, blade, skeleton_arm, mask,
quarterstaff */
var can_use_abilities = ["dash", "bash", 
"skeleton_arm", "mask", "blade", "hammer", 
"bardiche", "quarterstaff"]

/* full name of the shield with the highest
evade%, will be used to block big boss attacks*/
var evade_shield = "vigor ah"

/*********************
**     #Settings    **
*********************/
// Show ability cooldowns
var ui_show_cd = true

// Show your buffs/debuffs
var ui_show_statuses = true

// Show debug info (noisy, useful for research)
var ui_show_debug = true

/* How many regular enemies are needed to start 
using AOE weapons instead of single target */
var aoe_treshold = 4

/* Low HP threshold, fraction of 1. When on low 
HP, will prioritize `ah` shield and `dL` weapon 
over foe_weakness_element.
If 1, will always try to lifesteal to max.
If -1, will never force lifesteal. */
var low_hp_threshold = 0.5

// switch to 1h + shield when on Low HP
var use_shield_on_low_hp = true

// Usually script prefers melee, this changes it
var prefer_ranged = false

// Choose amount based on your `dI` weapon
var max_chill = 6

/* Blade of the Fallen God quests.
"bolesh" to kill him with the blade,
"variety" for killing unique enemies */
var bfg_quest = false

/* If you're on the "variety" step of the blade
quest, fill this array with names of the
enemies you've already defeated. */
var bfg_defeated_foes = ["ant", "mosquito"]

// Depends on level/enchants of the Blade
var smite_damage = 85

/* At least this many enemies must be present
to use Smite */
var smite_treshold = 7

/* Set to true if you're doing Skeleton Arm
quests. Prioritizes last-hitting foes with the 
Arm ability */
var pickpocket_quest = false

// These depend on level/enchants of the Arm
var arm_damage = 32
var max_pickpocket = 2

/* Cultist Mask quests.
"simple" - steps 1 and 3 (uses on CD)
"prevent" - step 4: do it in Rocky. Script
will approach the scout, use mask, get hit as
long as the debuff lasts, and quit the zone. */
var mask_quest = "prevent"

/*********************
**     #Progress    **
*********************/
func progress()
  ?healwalk() // no enemies nearby
    return true
  :?foe = explode
    return avoid_explosion()
  :?!is_boss & !at_boss
    /* Add your non-boss zone logic here */
    free_mind = true
    return fight()
  stance = "boss combat"
  ?loc = rocky
    ?foe.id = "acronian_scout"
      return fight_scout()
    return fight_dysan()
  :?loc = deadwood
    return fight_xyloalgia()
  :?loc = caves
    return fight_bolesh()
    // TODO ceiling decorator
  :?loc = fungus_forest_boss
    return fight_mushrooms()
  :?loc = mushroom
    ?foe.id = "epic_snail"
      auto_melee()
  :?loc = undead_crypt_boss
    return fight_pallas()
  :?loc = bronze_guardian
    return fight_bronze_guardian()
  :?loc = icy_ridge
    return fight_hrimnir()
  :?loc = nagaraja
    return fight_nagaraja()
  :
    dbg("Fighting unknown boss")
    auto_melee_boss()

func idle()
  stance = "out of combat"
  ?pickup.distance < 8
    return equip_L("star") & equip_R("trisk")
  :?can_qs_dash()
    return qs_dash()
  :?hp < maxhp
    return equip_L("ouroboros")
  :
    return equip_L("trisk")
  auto_equip_R("shield")
  return true

func healwalk()
  stance = "out of combat"
  ?foe & eff_dist < 23
    ?hp < (maxhp / 4) & item.potion ! empty &
    ^(item.potion = "healing" | 
    ^item.potion = "vampiric")
      activate potion
    return false // start combat instead
  return idle()

func avoid_explosion()
  stance = "avoiding explosion"
  ?foe_dist < 5
    return try_evade()
  equip_L("trisk")
  auto_equip_R("shield")

/********************
**     #Combat    **
********************/
func fight()
  ?phys_immune
    return auto_elemental()
  :?must_melee_foe()
    return auto_melee()
  :?prefer_ranged
    ?foe_dist < 8 & can_backflip()
      return backflip()
    return auto_ranged()
  :
    return auto_melee()

func auto_melee()
  ?use_abilities()
    return true
  :?can_aoe & eff_dist < 8
    return melee("aoe")
  :?low_hp & use_shield_on_low_hp
    return melee("def")
  :
    return melee("dps")

// mode: "dps" | "def" | "aoe"
func melee(mode)
  ?come_closer()
    return true
  ?eff_dist > 6 // get into range
    mode = "def"
  ?mode = "dps"
    stance = "melee dps"
    auto_equip("melee", false)
  :?mode = "aoe"
    stance = "melee aoe"
    auto_equip("melee", true)
  :?mode = "def"
    stance = "melee def"
    auto_equip_L("melee", false)
    auto_equip_R("shield", false)
  ?low_hp
    stance = "low_hp " + stance

func come_closer()
  ?should_qs_dash()
    return qs_dash()
  :?can_dash()
    return dash()
  return false  

func auto_ranged()
  ?use_abilities()
    return true
  :?can_aoe & eff_dist <= 16
    return ranged_aoe()
  :?can_ranged
    return ranged()
  :
    return auto_melee()

func ranged()
  stance = "ranged"
  ?low_hp
    stance = "low_hp ranged"
  auto_equip("ranged", false)

func ranged_aoe()
  stance = "ranged aoe"
  ?low_hp
    stance = "low_hp ranged aoe"
  auto_equip("ranged", true)

func auto_elemental()
  ?use_abilities()
    return true
  :?elemental()
    return true
  :
    return auto_ranged()

func elemental()
  stance = "elemental"
  for ty : ["staff", "wand"]
    ?auto_equip(ty)
      return true
  return false

func can_dash()
  return can("dash") & !disable_dash & 
  ^(have_bashing | have_dashing) &
  ^eff_dist > 10 & eff_dist < 17 &
  ^(bashCD <= 0 & !disable_bash | dashCD <= 0) &
  ^can_activate()

func dash()
  ?have_bashing & bashCD <= 0
    stance = "bashing"
    return equip_R("bashing")
  :?have_dashing & dashCD <= 0
    stance = "dashing"
    return equip_R("dashing")
  return false

func must_ranged_foe()
  return foe.id = mosquito | 
  ^foe.id = huge_mosquito | 
  ^foe.id = fire_elemental | foe = ant

func must_melee_foe()
  return foe = immune_to_ranged | foe = ranged | 
  ^foe.id = cult_guard // poisons on being hit

func auto_melee_boss()
  ?!come_closer()
    ?!use_abilities()
      ?!debuff()
        return auto_melee()

func debuff()
  ?foe_buffs = "buff_protection" | 
  ^foe_buffs = mirror | (loc.stars > 10 & 
  ^foe.id = "bronze_guardian")
    return false
  var consider = []
  ?!(foe_debuffs = "∞:debuff_damage:1:") &
  ^!(foe = immune_to_debuff_damage)
    consider.Add("poison")
  :?!(foe_debuffs = "φ:debuff_dot:1:") &
  ^!(foe = immune_to_debuff_dot)
    consider.Add("fire")
  :?!(foe_debuffs = "❄:debuff_chill:" + 
  ^max_chill + ":") &
  ^!(foe = immune_to_debuff_chill)
    consider.Add("ice")
  var amount = consider.Count()
  ?amount = 0
    return false
  stance = "debuffing"
  var to_search = get_weapon_candidates(
  ^"melee", false)
  var equipped_one = false
  for ty : to_search
    ?!equipped_one
      found = get_item(ty, consider[0], true)
      ?found
        equip_L(found)
        ?_2h_weapons.Contains(found)
          return true
        equipped_one = true
  ?!found
    auto_equip_L("melee", false)
  ?amount = 1
    ?low_hp
      return auto_equip_R("shield")
    return auto_equip_R("melee")
  :
    for ty : to_search
      found = get_item(ty, consider[1], true)
      ?found
        return equip_R(found)
  return false

func equip_L(it)
  equipL @it@
  _equip_L = it
  return true

func equip_R(it)
  equipR @it@
  return true

var _non_elem_weapons = ["bardiche", "arm", 
"heavy hammer", "repeating", "blade"]
// ty: any weapon type | "melee" | "ranged"
// aoe: true/false
func auto_equip_L(ty, aoe)
  ?_non_elem_weapons.Contains(ty)
    return equip_L(ty)
  var to_search = get_weapon_candidates(ty, aoe)
  for el : _elems
    for ty : to_search
      found = get_item(ty, element, false)
  ?found
    return equip_L(found)
  return false

// ty: any weapon type | "melee" | "ranged"
// aoe: true/false
func auto_equip_R(ty, aoe)
  var to_search = get_weapon_candidates(ty, aoe)
  for el : _elems
    for ty : to_search
      found = get_item(ty, element, false)
  ?found
    return equip_R(found)
  return false

var _2h_weapons = _non_elem_weapons
_2h_weapons.Add("staff")
func auto_equip(ty, aoe)
  var to_search = get_weapon_candidates(ty, aoe)
  var equipped_one = false
  for el : _elems
    for ty : to_search
      found = get_item(ty, element, false)
      ?found
        ?!equipped_one
          equip_L(found)
          ?_2h_weapons.Contains(found)
            return true
          equipped_one = true
        :
          equip_R(found)
          return true
  return false

var get_weapon_candidates(ty, aoe)
  ?all_types.Contains(ty)
    return [ty]
  var to_search = melee_types
  var aa = "warhammer"
  ?ty = "melee"
    ?aoe
      to_search = melee_aoe_types
    ?foe.armor > 0
      ?aoe
        aa = "heavy hammer"
      var idx = to_search.IndexOf(aa)
      ?idx ! -1
        to_search.Remove(idx)
        to_search.Insert(0, aa)
  :?ty = "ranged"
    ?aoe
      to_search = ranged_aoe_types
    :
      to_search = ranged_types
  return to_search

/********************
**    #Abilities   **
********************/

// Note on functions below:
// can_<something>() checks hard prerequisites:
//   cooldowns, range, etc.
// should_<something>() checks fight logic:
//   when is it correct to use.
// <something>() actually uses the ability 
// without doing checks itself

func edmg(dmg)
  // effective damage after considering debuffs
  return dmg - dmg_down_stacks

func set_lock(tag, timer)
  ?!lock
    lock = tag
    lock_timer = timer

func clear_lock(tag)
  ?string.Equals(lock, tag)
    lock = false
    lock_timer = 0

func can(ability)
  return !lock | string.Equals(lock, ability)

// quarterstaff
func can_qs_dash()
  return !lock & !disable_dash & have_qs &
  ^staffCD <= 0 & can_activate()

func should_qs_dash()
  return ((prefer_ranged & eff_dist > 28) |
  ^eff_dist > 16) & can_qs_dash()

func qs_dash()
  stance = "staff-dashing"
  equip_L("quarterstaff")
  ?item.CanActivate("quarterstaff")
    activate R
  return true

// Mind Stone
func can_backflip()
  return !lock & free_mind & mindCD <= 0 &
   // don't jump into the wall
  ^screen.FromWorldX(pos.x) > 5
  
func backflip()
  stance = "mind stone R"
  equip_L("mind")
  auto_equip_R("shield", false)

// skeleton arm
func can_slap()
  return !lock & have_arm & eff_dist < 7 &
  ^!phys_immune & armCD <= 0 & !disable_steal &
  ^can_activate()

func should_slap()
  return can_slap() & (!pickpocket_quest |
  ^foe_ehp <= edmg(arm_damage))

func slap()
  stance = "skeleton arm R"
  aac("skeleton arm")
  ?pickpocket_stacks >= max_pickpocket &
  ^item.CanActivate("skeleton_arm")
    activate R
  return true

// blade of the fallen god
func can_smite()
  return !lock & have_blade & 
  ^!disable_smite & smiteCD <= 0 & 
  ^eff_dist <= 20 & (foe ! pallas) & // immune
  ^can_activate()

func should_smite()
  ?bfg_quest = "variety"
    ?foe_ehp<=edmg(smite_damage) & can_smite()
      for e : bfg_defeated_foes
        ?foe = e
          return false
      return true
    return false
  return (is_boss | foe.count >= smite_treshold
  ^& foe_ehp<=edmg(smite_damage)) & can_smite()

func smite()
  stance = "smite R"
  aac("blade")
  ?item.CanActivate("blade")
    activate R
  return true

func can_hammer()
  return can("hammer") & have_ham & 
  ^!phys_immune & eff_dist <= 7 &
  ^can_activate()

func should_hammer()
  return foe.armor > 0 & (is_boss | can_aoe) & 
  ^can_hammer()

var hammer_frames = 13
func hammer()
  set_lock("hammer", hammer_frames)
  stance = "heavy hammer R"
  aac("heavy hammer")
  ?item.CanActivate("hammer")
    activate R
  return true

func can_bard()
  return can("bardiche") & have_bard & 
  ^eff_dist <= 9 & !phys_immune & can_activate()

func should_bard()
  return is_boss & can_bard()

var bard_frames = 30
func bardiche()
  set_lock("bardiche", bard_frames)
  stance = "bardiche R"
  aac("bardiche")
  ?item.CanActivate("bardiche")
    activate R
  return true

func can_mask()
  return !lock & have_mask & maskCD <= 0 &
  ^(foe ! nagaraja) & can_activate()

func should_mask()
  return (is_boss | mask_quest) & can_mask()

func mask()
  stance = "mask R"
  equipR mask
  ?item.CanActivate("mask")
    activate R
  return true

func use_abilities()
  // prioritize quests
  ?string.Equals(mask_quest, "simple") &
  ^can_mask()
    return mask()
  ?pickpocket_quest & can_slap()
    return slap()
  // then use where needed
  ?should_hammer()
    return hammer()
  ?should_smite()
    return smite()
  ?should_bard()
    return bardiche()
  ?should_slap()
    return slap()
  // use mask right before debuffing
  ?should_mask()
    return mask()
  return false

func can_activate()
  return ai.enabled & item.CanActivate()

func aac(weapon)
  equip @weapon@
  ?!berserk & !slowed & ai.idle
    ?string.Equals(lock, "hammer") | 
    ^string.Equals(lock, "bardiche")
      return false
    equip wand
  equip @weapon@
  return true

/*****************
**    #Bosses   **
*****************/

func shield_block()
  stance = "shield block"
  equip_R(evade_shield)

func shield_block_and_halt()
  stance = "shield block and halt"
  equip_L("quest")
  equip_R(evade_shield)

func fight_scout()
  ?string.Equals(mask_quest, "prevent")
    equip_L("quest")
    ?foe.state = 32 & foe.time > 11 & can_mask()
      return mask()
    ?maskCD > 0 & foe_debuffs ! "debuff_feeble"
      return loc.Leave()
    ?have_dashing
      equip_R("dashing")
  :
    auto_melee_boss()    

func fight_dysan() // REDO
  ?foe = phase1
    disable_steal = true
    ?foe.state = 33 & foe.time = 24
      // block big attack
      return shield_block()
  :?foe = phase2
    disable_steal = true
    var elems = get_foe_elems() // strong, weak
    ?elems[1]
      // set global elements
      _elems = [elems[1], "default"]
    auto_equip("melee")
  :?foe = phase3
    ?foe.state = 32 & foe.time > 90
      // prepare for attack
      return shield_block()
    :?foe.state = 115
      ?foe.time = 60
        // dodge the orb ray
        return backflip()
      :?foe.time < 80
        // don't dash into ray
        disable_dash = true
    :?foe.state = 106 | foe.state = 108 |
    ^foe.state = 0
      return shield_block()
    :?foe.state = 107 | foe.state = 32
      disable_steal = true
  auto_melee_boss()

func fight_xyloalgia()
  ?foe = phase1 // Xyloalgia
    return auto_melee_boss()
  // Poena
  disable_steal = true
  ?foe_buffs = mirror
    return shield_block_and_halt() // :(
  :?foe.state = 32 & foe.time = 41
    return shield_block()
  auto_melee_boss()

func fight_bolesh()
  // Get close, debuff/use abilities, then
  // jump to ranged before the first melee bite,
  // and continue shooting and blocking.
  ?loc.stars > 5
    disable_steal = true
  ?foe.state = 133 &
  ^(foe.time > 14 & foe.time < 17)
    // block bite and don't move from ranged
    return shield_block_and_halt()
  :?foe.state = 142 & foe.time > 53
    // evade melee bite
    return backflip()
  :?bfg_quest = "bolesh" & 
  ^(foe_ehp < edmg(smite_damage))
    ?come_closer()
      return true
    :?eff_dist <= 11
      return equip_L(blade)
    auto_melee_boss()
  :?mindCD<=0 & foe_buffs ! "spider_buff_damage"
    return auto_melee_boss()
  :?mindCD <= 0 & foe_dist < 10
    return backflip()
  ranged()
  
func try_evade()
  ?mindCD <= 0
    return backflip()
  return shield_block()

func fight_mushrooms()
  disable_steal = true
  ?foe = phase1
    ?loc.stars < 11
      big_swing = 48
    :
      big_swing = 51
    ?foe.state = 32 & foe.time = big_swing
      // only the first swing is accurate,
      // then its timing is affected by chill
      return try_evade()
    :?foe.state = 32 & 
    ^foe.time > big_swing - bard_frames
      disable_bard = true
    :?foe.state = 32 & 
    ^foe.time > big_swing - hammer_frames
      disable_hammer = true
    :?foe.state = 33
      // pellets, V = 1 frame / sec
      ?foe.time = foe_dist + 4
        return shield_block()
      // prevent interrupts
      lock_abilities("shrooms")
  :?foe = mushroom_boss_fat
    ?loc.stars < 11
      big_swing = 56
    :
      big_swing = 59
    ?foe.state = 32
      ?foe.time = big_swing
        // only accurate for the first punch
        // then it's affected by chill/stun
        return try_evade()
      :?foe.time > (big_swing - 15)
        // prevent interrupts
        lock_abilities("shrooms")
    :
      // TODO detect pellets
      return auto_melee_boss()
  : // Enoki themself
    // TODO detect pellets
    ?eff_dist > 6 & !come_closer()
      return melee("def")
  auto_melee_boss()

func fight_pallas() // REDO
  at_boss = true
  disable_steal = true
  ?foe.count > 2
    ?foe_dist < 15 & mindCD <= 0
      return backflip()
    return elemental_aoe()
  auto_melee_boss()

func fight_bronze_guardian() // TIMINGS
  disable_steal = true
  ?foe.state = 32 & foe.time = 30
    return backflip() // dodge the hammer
  ?foe.state = 33 // hammer is down
    ?!use_abilities()
      melee("dps") // don't bother debuffing
  :
    ranged()

func fight_hrimnir() // REDO
  at_boss = true
  ?is_boss & foe.armor > 0
    // initial ice block, don't debuff
    return auto_melee()
  :?loc.stars <= 5 // try to cheese
    ?foe_dist <= 2
      ?!use_abilities()
        return auto_melee() // don't debuff
    :?foe_dist <= 5
      // The shovel has an attack range of 1
      // so at white stars we can avoid
      // snowballs by getting close to boss.
      // on higher stars he blows you away
      // immediately
      equip shovel
    : // blown away, get back
      return auto_melee()
  :?foe.state = 143 | foe.state = 144 // blowing
    return ranged()
  :?foe.count > 1 // deal with adds
    ?can_smite()
      return smite()
    :?foe.count > 2
      ?can_hammer()
        return hammer()
      return elemental_aoe()
    :?eff_dist < 11
      return auto_melee()
    :?can_bard() & foe.id = ice_wall
      return bardiche()
    return auto_melee()
  :?slowed
    ranged()
  :
    auto_melee_boss()

func fight_nagaraja()
  // TODO: dodge boulder
  disable_steal = true
  // goal is to dodge poison balls
  var x = screen.FromWorldX(pos.x)
  var y = screen.FromWorldZ(pos.z)
  // _detect_poison(x, y) // debug and research

  ?is_poison_near(x, y)
    naga_step++

  ?naga_step = 0
    // start at the xbow range
    ranged()
  :?naga_step = 1
    // staff 1st poison
    qs_dash()
    naga_step++
  :?naga_step = 2
    // and continue to shoot
    ranged()
  :?naga_step = 3
    // dash into melee
    auto_melee_boss()
  :?naga_step >= 4
    ?mindCD <= 0
      // dodge back and repeat
      backflip()
      naga_step = 0
    :
      // mind stone on CD, try to def
      melee("def")

func is_poison_near(pos_x, pos_y)
  // long and mid range
  ?draw.GetSymbol(pos_x+2, pos_y-6) = "(" |
  // melee
  ^(draw.GetSymbol(pos_x+1, pos_y-6) = "(")
    return true
  return false

func _detect_poison()
  var x = screen.FromWorldX(pos.x)
  var y = screen.FromWorldZ(pos.z)
  >`0,0,x=@x@, y=@y@
  for px = pos_x .. pos_x+10
    for py = pos_y-6 .. pos_y
      ?draw.GetSymbol(px, py) = "("
        cache.Add([pos_x, pos_y, px, py])
  var arr_size = cache.Count()
  ?arr_size > 0
    for line = 1 .. arr_size
      var v = cache[line-1]
      >`0,@line@,x=@v[0]@, y=@v[1]@, 
      ^px=@v[2]@, py=@v[3]@;

/*********************
**     #Internals   **
*********************/
// global vars below
// misc
var at_boss = false // to deal with adds
var naga_step = 0 // nagaraja fight
var big_swing = 0 // mushrooms
// player status
var stance = "unknown" // chosen combat stance
var low_hp = false // hp < (maxhp * threshold)
var dmg_down_stacks = 0 // poison
var range_down_stacks = 0
var pickpocket_stacks = 0 // pickpocket buff
var smitten = false // have smite buff
var slowed = false // is player slowed
var stunned = false // is player stunned
var berserk = false // potion
var can_aoe = false
// abilities
var lock = false
var lock_timer = false
var free_mind = false
// foe status
var foe_ehp = 0 // foe.armor + foe.hp
var foe_dist = 0 // foe_dist
var eff_dist = 0 // foe_dist + range_debuff
var foe_buffs = "" // foe.buffs.string
var foe_debuffs = "" // foe.debuffs.string
var is_boss = false // foe = boss
var phys_immune = false // immune to physical
// hit tracking
var enable_hit_tracking = false
var last_frame_dist = 0
var last_frame_armor = 0
var last_frame_hp = 0
var last_frame_foe = ""
var last_frame_dist = 0
var last_frame_state = -1
var last_frame_time = -1

// Pre-define vars for internal functions.
var found = false
var ty = false
var _equip_L = false
var _elems = []
var st_good = [] // current buffs
var st_bad = [] // current debuffs
var st_x = [] // unknown status effects
var status_uids = []
var errors = []
var cache = []

var all_types = [
  "sword", "big sword", "wand",
  "shield", "crossbow", "staff", 
  "warhammer",
  ]
var type_c = all_types.Count()
var all_elems = [
  "aether", "fire", "ice", "poison", "vigor",
  "default",
  ]
var elem_c = all_elems.Count()
var equipment = [
  // The items cache, consists of subarrays:
  // [[damage/armor items], [buff/debuff items]]
  // Each item type gets a subarray for each
  // element, and the types are placed in
  // sequence. For example: first 6 subarrays 
  // belong to "sword", the next 6 to 
  // "big sword", and so on. See also: get_item()
]
// "{element} {type} {suffix + enchant}"
var name_template = "{0} {1} {2}"
func _prepare_items()
  // add placeholders for every subarray
  for i = 0 .. (type_c * elem_c) - 1
    equipment.Add([[], []])
   // `it` is [type, [elem, s1, sn], [elem2...]]
  for it : elemental_items
    ?it.Count() > 1
      for i = 1 .. it.Count() - 1
        //`el_it` is ["elem", "s1", "sn"]
        var el_it = it[i]
        ?el_it.Count() > 1
          ty = it[0] // item type
          var elem = el_it[0] // item element
          var offset = _get_offset(ty, elem)
          // for every suffix in list
          for j = 1 .. el_it.Count() - 1
            var suffix = el_it[j]
            // `slot` is [[dmg], [effect]]
            var slot = equipment[offset]
            var full_name
            ?elem = "default"
              full_name = suffix
              ?!slot[0].Contains(full_name)
                slot[0].Add(full_name)
            :
              full_name = string.Format(
              ^name_template, elem, ty, suffix)
              ?_is_elem_effect(suffix) & 
              ^!slot[1].Contains(full_name)
                slot[1].Add(full_name)
              :?!slot[0].Contains(full_name)
                slot[0].Add(full_name)
  for m : melee_types
    melee_aoe_types.Add(m)
  for r : ranged_types
    ranged_aoe_types.Add(r)

var can_ranged = ranged_types.Count() > 0

func _get_offset(ty, elem)
  return all_types.IndexOf(ty) * elem_c +
  ^all_elems.IndexOf(elem)

var _elem_suffixes = [
  "f", "F", "i", "I", "p", "P", "h", "L",]
func _is_elem_effect(suffix)
  ?string.Size(suffix) < 2
    return false
  // check second symbol of the suffix
  return string.Contains(_elem_suffixes,
  ^string.Sub(suffix, 1, 1))

func _find_first(arr, exclude)
  ?arr.Count() > 0
    for it : arr
      ?!exclude | !string.Equals(exclude, it)
        return it
  return false

// ty: in-game item type
// elem_effect: bool
func get_item(ty, element, elem_effect)
  var slot = equipment[_get_offset(ty, element)]
  ?!elem_effect
    found = _find_first(slot[0], _equip_L)
  // if D item not found, try to find dX item
  ?elem_effect | !found
    found = _find_first(slot[1], _equip_L)
  return found

var ignore_st = [ // irrelevant statuses
  "quarterstaff_buff_attack_speed",
  "quarterstaff_buff_stun",
  "bardiche_buff_aoe_chance",
  "bardiche_buff_crit_chance",
  "bardiche_buff_crit_mult",
  "bardiche_buff_move_speed",
]
var statuses = [
  ["berserk", "Berserk", "+"], 
  ["smite", "Smite", "+"], 
  ["pick_pocket", "Pickpocket", "+"],
  ["vampiric", "Vamp", "+"],
  ["lucky_crit_multi", "Lucky", "+"],
  ["invisibility", "Invis", "+"],
  ["debuff_damage", "DmgDown", "-"],
  ["debuff_duration_damage", "DmgDown", "-"],
  ["spider_debuff_damage", "DmgDown", "-"],
  ["dysangelos_debuff_damage", "DmgDown", "-"],
  ["puff_debuff_damage", "DmgDown", "-"],
  ["debuff_yeti_chill", "AtkSlow", "-"],
  ["debuff_attack_speed", "AtkSlow", "-"],
  ["debuff_move_speed", "MoveSlow", "-"],
  ["debuff_chill", "Chill", "-"],
  ["stun", "Stun", "-"],
  ["pallas_phase2_debuff", "RangeDown", "-"],
  ["debuff_dot", "FireDoT", "-"],
]
var dmg_debuffs = [
  "debuff_damage", "debuff_duration_damage",
  "spider_debuff_damage", "puff_debuff_damage"
]
var slow_debuffs = [
  "debuff_chill", "debuff_move_speed"
]
var mirror = "poena_mirror"
func _parse_statuses()
  st_good.Clear()
  st_bad.Clear()
  dmg_down_stacks = 0
  range_down_stacks = 0
  pickpocket_stacks = 0
  slowed = false
  berserk = false
  stunned = false
  smitten = false
  for s : [buffs.string, debuffs.string]
    // format: *:name:count:duration,...
    var splt = string.Split(s, ":", ",", false)
    var arr_size = splt.Count()
    ?arr_size > 0
      // iterate over names (2nd field)
      for i = 1 .. arr_size - 3
        var st_uid = splt[i]
        var st_amount = int.Parse(splt[i+1])
        var st_dur = int.Parse(splt[i+2])
        ?dmg_debuffs.Contains(st_uid)
          dmg_down_stacks = dmg_down_stacks + 
          ^st_amount
        :?slow_debuffs.Contains(st_uid)
          slowed = true
        :?string.Equals(st_uid, 
          ^"pallas_phase2_debuff")
          range_down_stacks = st_amount
        :?string.Equals(st_uid, "stun")
          stunned = st_dur
        :?string.Equals(st_uid, "smite")
          smitten = true
        :?string.Equals(st_uid, "berserk")
          berserk = true
        :?string.Equals(st_uid, "pick_pocket")
          pickpocket_stacks = st_amount
        var idx = status_uids.IndexOf(st_uid)
        ?idx ! -1
          var st_info = statuses[idx]
          var st_s = string.Format("{0}({1}) " + 
          ^"{2}", st_info[1], st_amount,
          ^time.FormatDigital(st_dur))
          ?st_info[2] = "+"
            st_good.Add(st_s)
          :
            st_bad.Add(st_s)
        :?ignore_st.Contains(st_uid) &
        ^!st_x.Contains(st_uid)
          // log unknown statuses for debug
          st_x.Add(st_uid)
        i = i + 3

func _prepare_statuses()
  for st_info : statuses
    status_uids.Add(st_info[0])

func track_hits()
  var hp_diff = last_frame_hp - hp
  ?hp_diff > 0
    >`20,2,#red,Got hit!
    >`20,3,Last frame info:
    >`20,4,hp = @last_frame_hp@ (diff = 
    ^@hp_diff@), 
    ^armor = @last_frame_armor@
    >`20,5,id = @last_frame_foe@
    >`20,6,dist = @last_frame_dist@
    >`20,7,state = @last_frame_state@
    >`20,8,time = @last_frame_time@
    loc.Pause()
  last_frame_armor = armor
  last_frame_hp = hp
  last_frame_foe = foe.id
  last_frame_dist = foe_dist
  last_frame_state = foe.state
  last_frame_time = foe.time

func get_foe_elems()
  ?foe = aether
    return ["aether", "vigor"]
  ?foe = fire
    return ["fire", "aether"]
  ?foe = ice
    return ["ice", "fire"]
  ?foe = poison
    return ["poison", "ice"]
  ?foe = vigor
    return ["vigor", "aether"]
  return ["", false]

func _set_elems()
  _elems.Clear()
  var foe_elems = get_foe_elems()
  ?low_hp
    _elems.Add("vigor")
  ?foe_elems[1]
    _elems.Add(foe_elems[1])
  _elems.Add("default")
  for e : all_elems
    ?(e ! foe_elems[0]) &  (e ! "default") &
    ^(!low_hp | e ! "vigor")
      _elems.Add(e)

var all_abilities = [
  "mind", "hammer", "bardiche", "blade",
  "skeleton_arm", "dash", "bash", "mask", 
  "quarterstaff", 
]
var abilities_count = all_abilities.Count() - 1
var cooldowns = []
var have_r = []
func _prepare_abilities()
  for r : all_abilities
    cooldowns.Add(0)
    have_r.Add(can_use_abilities.Contains(r))

func _maintain_abilities()
  for i = 0 .. abilities_count
    var r = all_abilities[i]
    ?r = "arm"
      r = "skeleton_arm"
    :
    cooldowns[i] = item.GetCooldown(r)
    have_r[i] = cooldowns[i] <= 0

func get_cd(ability)
  ?ability = "arm"
    ability = "skeleton_arm"
  return 
  ^cooldowns[all_abilities.IndexOf(ability)]

func _maintain_lock()
  ?stunned
    set_lock("stun", stunned)
  :
    clear_lock("stun")
  ?lock
    ?lock_timer <= 0
      lock = false
    :
      lock_timer--
  :
    lock_timer = 0  

func prelude()
  // reset/update dynamic global vars
  ?enable_hit_tracking
    track_hits()
  _parse_statuses()
  _maintain_abilities()
  _maintain_lock()
  low_hp = hp < (maxhp * low_hp_threshold)
  _set_elems() // needs to know `low_hp`
  _equip_L = false
  stance = "unknown"
  foe_ehp = foe.armor + foe.hp
  foe_dist = foe.distance  
  eff_dist = foe_dist + range_down_stacks
  foe_buffs = foe.buffs.string
  foe_debuffs = foe.debuffs.string
  is_boss = (foe = boss)
  phys_immune = (foe = immune_to_physical)
  can_aoe = (foe.count >= aoe_treshold)

func dbg(e)
  ?ui_show_debug
    ?!errors.Contains(e)
      errors.Add(e)

var move_r = ["quarterstaff", "bash", "dash"]
func draw_ui()
  var sy = 22
  ?ui_show_debug
    sy = 20
  ?ui_show_statuses
    >`1,@sy@,#00A300,
    ^+ @string.Join(", ", st_good)@
    >`1,@sy+1@,#FE6800,
    ^- @string.Join(", ", st_bad)@
    >`1,@sy+2@,#F008B2,
    ^? @string.Join(", ", st_x)@
  ?ui_show_cd
    var cd_ui_y = 6
    for r : all_abilities
      ?!move_r.Contains(r) & 
      ^can_use_abilities.Contains(r)
        var cd = get_cd(r)
        ?r = "skeleton_arm"
          r = "Arm"
        >`1,@cd_ui_y@,#@colorize(cd, true)@,
        ^@string.Capitalize(r)@ 
        ^@time.FormatDigital(cd)@
        cd_ui_y++
  ?ui_show_debug
    var cd_ui_x = 1
    >`@cd_ui_x@,@cd_ui_y@,
    ^#@colorize(get_cd("quarterstaff"), 
    ^can_qs_dash())@,QS
    cd_ui_x = cd_ui_x + 2
    ?can_use_abilities.Contains("bash")
      >`@cd_ui_x@,@cd_ui_y@,#7A8F93,/
      cd_ui_x++
      >`@cd_ui_x@,@cd_ui_y@,
      ^#@colorize(get_cd("bash"))@,B
      cd_ui_x++
    ?can_use_abilities.Contains("dash")
      >`@cd_ui_x@,@cd_ui_y@,#7A8F93,/
      cd_ui_x++
      >`@cd_ui_x@,@cd_ui_y@,
      ^#@colorize(get_cd("dash"))@,D
      cd_ui_x++
    >`1,23,#blue,Lock: @lock@ @lock_timer@
    >`1,24,#blue,Stance: @stance@
    ?foe
      >`1,14,#7A8F93,id: @foe.id@
      >`1,15,#7A8F93,State: @foe.state@
      >`1,16,#7A8F93,Time: @foe.time@
      >`1,17,#7A8F93,Dist: @foe_dist@
      >`1,18,#7A8F93,Count: @foe.count@
    >`1,25,#7A8F93,@loc.stars@* 
    ^@time.FormatDigital(totaltime)@ @foe@
    var ey = 2
    for err : errors
      >`20,@ey@,#red,@err@
      ey++

func colorize(cd, allowed)
  ?cd > 0
    return "red"
  ?!allowed
    return "FE6800"
  return "green"

func brew_pot()
  brew tar + bronze // vampiric

func reset_loop()
  lock = false
  lock_timer = 0
  at_boss = false
  naga_step = 0
  cache.Clear()
  st_x.Clear()

?loc.begin
  _prepare_statuses()
  _prepare_items()
  _prepare_abilities()
  ?item.potion = empty
    brew_pot()
  ?loc = Mine
    melee_aoe_weapon = "heavy hammer"
:?loc.loop
  reset_loop()
:?ai.enabled & !ai.paused
  prelude()
  progress()
:
  idle()
// test()
draw_ui()
// loc.Pause()