/* Set up your elemental and default items */
var elemental_items = [
  ["hammer", 
    ["aether", "D"],
    ["poison", "D"],
    ["ice", "D"],
  ],
  ["wand", 
    ["vigor", "D", "dL"],
  ],
  ["sword", 
    ["aether", "D"],
    ["fire", "dF", "D"],
    ["ice", "dI"],
    ["poison", "dP", "D"],
    ["vigor", "dL"],
    ["default", "vigor sword dL", 
                "poison sword D"],
  ],
  ["shield", 
    ["vigor", "ah", "A"],
    ["poison", "A"],
    ["ice", "A"],
    ["aether", "A"],
    ["fire", "A"],
    ["default", "vigor shield ah"],
  ],
]
/* These non-elemental items can be used as 
weapon types in the lists below. */
var special_weapons = ["bardiche", "blade", 
"heavy hammer", "repeater", "arm"]

/* By default script prefers to use melee, and
only uses ranged for scripted bosses, against
specific enemies like mosquitoes and wasps.
What script considers when selecting a weapon:
1. Match foe's weak element.
2. Use hammers or heavy hammer if foe has armor.
3. Use single-target or AoE weapons based on
   `foe.count`.
4. If you're on low HP, uses lifesteal and heal
   weapons/shields.
5. If it's a boss, or if you have Smite buff,
   debuffs the enemy.
Settings below can change this logic. */

/* Weapon type priority for single targets:
1. First type + foe's weak element.
2. Default weapon of the first type.
3. Second type + foe's weak element.
4. Etc. 
If a weapon type isn't listed here, it will not
ever be used. */
var for_melee_single_target = [
  "sword", "big sword", "hammer",
]

/* How many regular enemies are needed to start 
using AoE weapons instead of single target. */
var aoe_treshold = 4

/* Weapons to use for melee AoE, same priority 
logic as the regular melee. */
var for_melee_aoe = [
  "arm","bardiche", "heavy hammer", "big sword",
]

/* If this is set to `true`, script will prefer
to use ranged items from lists below instead of
melee. */
var prefer_ranged = false

/* Will prefer ranged only for these enemies */
var ranged_foes = ["mosquito", "huge_mosquito",
"wasp", "ant"]

/* Used for scripted bosses, for `ranged_foes`,
or when `prefer_ranged` is true. */
var for_ranged_single_target = ["repeating"]

/* Weapons to use for ranged AoE. Ranged AoE is
triggered by the same threshold as melee AoE. */
var for_ranged_aoe = ["wand", "staff"]

/* Weapons to use against `immune_to_physical`
enemies. */
var for_phys_immune = ["wand", "staff"]

/* Full name of the shield with the highest
evade%, will be used to block big boss attacks*/
var evade_shield = "vigor ah"

/* Fraction of HP to consider low. When on low 
HP, will prioritize `ah` shield and `dL` weapon 
over foe's elemental weakness.
If 1, will always try to lifesteal to max.
If 0, will never force lifesteal. */
var low_hp_threshold = 1

// Switch to 1h + shield when `low_hp_threshold`
var use_shield_on_low_hp = false

/* if true, will debuff even regular enemies
when you have the Smite buff active. */
var debuff_on_smite = true

// Depends on level/enchants of the Blade.
var smite_damage = 85

/* At least this many enemies must be present
to use Smite. */
var smite_treshold = 7

/* If item is not listed here, its `R` ability
won't be used. Supported: dash, bash, 
bardiche, hammer, blade, skeleton_arm, mask,
quarterstaff. */
var useable_abilities = ["dash", "bash", 
"skeleton_arm", "mask", "blade", "hammer", 
"bardiche", "quarterstaff"]

// Choose amount based on your `dI` weapon
var max_chill_stacks = 6

/* Blade of the Fallen God quests.
"bolesh" to kill him with the blade,
"variety" for killing unique enemies */
var bfg_quest = false

/* If you're on the "variety" step of the BFG
quest, fill this array with names of the
enemies you've already defeated. */
var bfg_defeated_foes = ["ant", "mosquito"]

/* Set to true if you're doing Skeleton Arm
quests. Prioritizes last-hitting foes with the 
Arm ability */
var pickpocket_quest = false

// These depend on level/enchants of the Arm
var arm_damage = 44
var max_pickpocket_stacks = 3

/* Cultist Mask quests.
"simple" - steps 1 and 3 (uses on CD)
"prevent" - step 4: do it in Rocky. Script
will approach the scout, use mask, get hit as
long as the debuff lasts, and quit the zone. */
var mask_quest = "prevent"

// Show ability cooldowns in UI
var ui_show_cd = true

// Show your buffs/debuffs in UI
var ui_show_statuses = true

// Show debug info (noisy, useful for research)
var ui_show_debug = true

/*********************
**     #Progress    **
*********************/
func progress()
  ?healwalk() // no enemies nearby
    return true
  ?foe = explode
    return avoid_explosion()
  ?!is_boss & !at_boss
    /* Add your non-boss zone logic here */
    free_mind = true
    return fight()
  stance = "boss combat"
  ?loc = rocky
    ?foe.id = "acronian_scout"
      return fight_scout()
    return fight_dysan()
  :?loc = deadwood
    return fight_xyloalgia()
  :?loc = caves
    ?foe.id = "cool_bat" // TODO stunlock
      return auto_melee_miniboss()
    return fight_bolesh()
  :?loc = fungus_forest_boss
    return fight_mushrooms()
  :?loc = mushroom
    ?foe.id = "epic_snail"
      return auto_melee_miniboss()
  :?loc = undead_crypt_boss
    return fight_pallas()
  :?loc = halls
    ranged("aoe")
    stance = "miniboss " + stance
    return
  :?loc = bronze_guardian
    return fight_bronze_guardian()
  :?loc = icy_ridge
    return fight_hrimnir()
  :?loc = nagaraja
    return fight_nagaraja()
  :
    dbg("Fighting unknown boss: " + foe.id)
    auto_melee_boss()

func healwalk()
  stance = "healwalk"
  ?foe & (foe_dist < 23)
    ?hp < (maxhp / 4) & item.potion ! empty &
    ^(item.potion = "healing" | 
    ^item.potion = "vampiric")
      activate potion
    return false // start combat instead
  ?pickup.distance < 9
    return equip_L("star") & equip_R("trisk")
  :?can_qs_dash()
    return qs_dash()
  found = auto_equip_shield()
  ?!found
    return equip_L("ouroboros") & 
    ^equip_R("trisk")
  ?hp < maxhp
    return equip_L("ouroboros")
  return equip_L("trisk")

func avoid_explosion()
  stance = "avoiding explosion"
  ?foe_dist < 5
    disable_r("any_dash")
    return try_evade()
  return melee("def")

/********************
**     #Combat    **
********************/
func fight()
  ?phys_immune | foe = magic_vulnerability
    return auto_ranged()
  :?must_melee_foe()
    return auto_melee()
  :?must_ranged_foe() 
  ^& foe_dist > melee_aoe_range & can_aoe
    return auto_ranged()
  :?prefer_ranged
    ?foe_dist < 8
      ?can_backflip()
        return backflip()
      return auto_melee()
    return auto_ranged()
  :
    return auto_melee()

func must_ranged_foe()
  return ranged_foes.Contains(foe.id) 

func must_melee_foe()
  return foe = immune_to_ranged | foe = ranged

func auto_melee()
  ?use_abilities()
    return true
  :?can_aoe & eff_dist <= melee_aoe_range
    return melee("aoe")
  :?low_hp & use_shield_on_low_hp
    return melee("def")
  :
    return melee("dps")

// mode: "dps" | "def" | "aoe"
func melee(mode)
  ?dash_closer()
    return true
  var eff_range
  ?!low_hp & should_debuff()
    var is_aoe = mode = "aoe"
    ?try_equip_debuff("melee", is_aoe)
      mode = "debuff"
  ?mode = "dps"
    stance = "melee dps"
    eff_range = melee_range
    auto_equip_dps("melee", false)
  :?mode = "aoe"
    stance = "melee aoe"
    eff_range = melee_aoe_range
    auto_equip_dps("melee", true)
  :?mode = "def"
    stance = "melee def"
    eff_range = melee_range
    auto_equip_L("melee", false)
  ?found_type
    eff_range = get(weapon_ranges, found_type)
  ?eff_dist > eff_range
    stance = "getting into melee"
    // use shiled while walking up
    ?is_2hander(found_type)
      _equip_L = false
      auto_equip_L("melee", false)
    ?!is_2hander(found_type)
      auto_equip_shield()
  ?low_hp
    stance = "low_hp " + stance

func dash_closer()
  ?can_dash()
    return dash()
  :?should_qs_dash()
    return qs_dash()
  return false  

func auto_ranged()
  ?use_abilities()
    return true
  :?can_aoe & for_ranged_aoe.Count() > 0 & 
  ^eff_dist <= ranged_range
    return ranged("aoe")
  :?for_ranged_single_target.Count() > 0
    return ranged("single")
  :
    return auto_melee()

// mode: aoe | single
func ranged(mode)
  var is_aoe = mode="aoe"
  stance = "ranged"
  ?is_aoe
    stance = "ranged aoe"
  ?!low_hp & should_debuff()
    ?try_equip_debuff("ranged", is_aoe)
      return
  auto_equip_dps("ranged", is_aoe)
  ?low_hp
    stance = "low_hp " + stance

func can_dash()
  return (can_use("dash") | can_use("bash"))
  ^& eff_dist > 10 & eff_dist < 17 &
  ^can_activate()

func dash()
  ?can_use("bash")
    stance = "bashing"
    return equip_R("bashing")
  :?can_use("dash")
    stance = "dashing"
    return equip_R("dashing")
  return false

func auto_melee_boss()
  auto_melee()
  stance = "boss " + stance

func auto_melee_miniboss()
  disable_r("blade")
  disable_r("mask")
  auto_melee()
  stance = "miniboss " + stance

/**********************
** #Weapon switching **
**********************/

var _equip_L = false
func equip_L(it)
  // sets global flag, so the next `get_item()`
  // in this frame will not return the same item
  _equip_L = it
  ?is_2hander(it) | is_2hander(found_type)
    return aac(it)
  equipL @it@
  return it

var _equip_R = false
func equip_R(it)
  // for debug
  _equip_R = it
  ?is_2hander(it) | is_2hander(found_type)
    return aac(it)
  equipR @it@
  return it

func is_2hander(ty)
  return ty & _2h_types.Contains(ty)

// range: "melee" | "ranged"
// aoe: true/false
func auto_equip_L(range, aoe)
  found = select_dps_weapon(range, aoe)
  ?found
    return equip_L(found)
  return false

// range: "melee" | "ranged"
// aoe: true/false
func auto_equip_R(range, aoe)
  found = select_dps_weapon(range, aoe)
  ?found
    return equip_R(found)
  return auto_equip_shield()

func auto_equip_shield()
  found = false
  found_type = false
  ?low_hp
    found = get_item("shield", "vigor", "mod")
  ?!found
    found = get_item("shield", _elem, "stats")
  ?!found
    found = get_item("shield", "default", "")
  ?found
    return equip_R(found)
  return false
  
// range: "melee" | "ranged"
// aoe: true/false
func auto_equip_dps(range, aoe)
  found = select_dps_weapon(range, aoe)
  ?!found
    return false
  equip_L(found)
  ?is_2hander(found_type)
    return found
  found = select_dps_weapon(range, aoe)
  ?found
    return equip_R(found)

func select_dps_weapon(range, aoe)
  found = false
  ?low_hp
    // heal on low hp
    found = select_weapon(range, aoe, 
    ^"vigor", "mod")
  ?!found
    // default case: match element
    found = select_weapon(range, aoe, 
    ^_elem, "stats")
  return found

func try_equip_debuff(range, aoe)
  var amount = debuff_elems.Count()
  ?amount = 0
    return false
  found = false
  var found_idx = -1
  for i = 0 .. amount - 1
    ?!found
      found = select_debuff_weapon(range, aoe,
      ^debuff_elems[i])
    ?found & found_idx = -1
      found_idx = i
  ?!found // no debuff weapons at all
    return false
  ?found_type & elem_types.Contains(found_type)
    stance = "debuffing"
  equip_L(found)
  ?is_2hander(found_type)
    return true
  found = false
  ?found_idx + 1 < amount
    // debuff another element with right hand
    for i = found_idx + 1 .. amount - 1
      ?!found
        found = select_debuff_weapon(range, aoe,
        ^debuff_elems[i])
    ?found
      return equip_R(found)
  ?!found // no debuff weapons for right hand
    return auto_equip_R(range, aoe)

func select_debuff_weapon(range, aoe, elem)
  found = select_weapon(range, aoe, elem, "mod")
  ?!found & range = "melee"
    found = select_weapon("ranged", aoe, elem, 
    ^"mod")
  return found

func select_weapon(range, aoe, elem, purpose)
  found = false
  found_type = false
  var types = get_preferred_types(range, aoe)
  for ty : types
    ?!elem_types.Contains(ty)
      found_type = ty
      return ty
    found = get_item(ty, elem, purpose)
    ?!found & purpose = "stats"
      found = get_item(ty, elem, "mod")
      ?!found
        found = get_item(ty, "default", "")
    ?found
      found_type = ty
      return found
  return false

func get_preferred_types(range, aoe)
  ?phys_immune | foe = magic_vulnerability
    return for_phys_immune
  var types = for_melee_single_target
  ?range = "melee"
    ?aoe
      types = for_melee_aoe
    ?foe.armor > 0
      ?aoe
        types = aa_aoe_types
      :
        types = aa_st_types
  :
    ?aoe
      types = for_ranged_aoe
    :
      types = for_ranged_single_target
  return types

func get_item(ty, elem, purpose)
  var h
  ?elem = "default"
    h = hash([ty, "default"])
  :
    h = hash([ty, elem, purpose])
  var items = try_get(all_items, h)
  ?items = None | items.Count() = 0
    return false
  for it : items
    ?!_equip_L | !string.Equals(it, _equip_L)
      return it
  return false

func should_debuff()
  return (is_boss | (debuff_on_smite &
  ^get(my_statuses, "smite"))) &
  ^!(foe.buffs.string = "poena_mirror") & 
  ^!get(foe_debuffs, "buff_protection") &
  ^check_foe_debuffs()

var debuff_elems = []
func check_foe_debuffs()
  debuff_elems.Clear()
  ?can_be_debuffed("debuff_damage")
    debuff_elems.Add("poison")
  ?can_be_debuffed("debuff_dot")
    debuff_elems.Add("fire")
  ?can_be_debuffed("debuff_chill")
    debuff_elems.Add("ice")
  ?debuff_elems.Count() = 0
    return false
  return debuff_elems

func can_be_debuffed(debuff_uid)
  ?(foe = "immune_to_" + debuff_uid)
    return false
  ?debuff_uid = "debuff_chill"
    return get(foe_debuffs, debuff_uid) 
    ^< max_chill_stacks
  return !get(foe_debuffs, debuff_uid)

/********************
**    #Abilities   **
********************/
func get_cd(ability)
  return get(cooldowns, ability)

func allowed(ability)
  return get(abilities, ability)

func edmg(dmg)
  return dmg - get(my_statuses, "damage_down")

func is_locked_by(tag)
  return lock & string.Equals(lock, tag)

func set_lock(tag, timer)
  ?!lock
    lock = tag
    lock_timer = timer

func clear_lock(tag)
  ?is_locked_by(tag)
    lock = false
    lock_timer = 0

func can_use(ability)
  ?lock
    return is_locked_by(ability)
  return allowed(ability)

func can_qs_dash()
  return can_use("quarterstaff") & 
  ^can_activate()

func should_qs_dash()
  return (prefer_ranged & eff_dist > 28) |
  ^(eff_dist > 16 | 
  ^eff_dist < 11 & eff_dist > 5) & can_qs_dash()

func qs_dash()
  stance = "staff-dashing"
  equip_L("quarterstaff")
  ?item.CanActivate("quarterstaff")
    activate R
  return true

func can_backflip()
  return can_use("mind") & free_mind &
   // don't jump into the wall
  ^screen.FromWorldX(pos.x) > 5
  
func backflip()
  stance = "mind stone R"
  auto_equip_shield()
  return equip_L("mind")

func can_slap()
  return can_use("skeleton_arm") & 
  ^eff_dist < 7 & !phys_immune & can_activate()

func should_slap()
  return can_slap() & (!pickpocket_quest |
  ^foe_ehp <= edmg(arm_damage))

func slap()
  stance = "skeleton arm R"
  aac("arm")
  ?get(my_statuses, "pick_pocket") >= 
  ^max_pickpocket_stacks &
  ^item.CanActivate("skeleton_arm")
    activate R
  return true

func can_smite()
  return can_use("blade") & 
  ^eff_dist <= 20 & (foe ! pallas) &
  ^can_activate()

func should_smite()
  ?bfg_quest = "variety"
    ?foe_ehp<=smite_damage & can_smite()
      for e : bfg_defeated_foes
        ?foe = e
          return false
      return true
    return false
  return (is_boss | foe.count >= smite_treshold
  ^& foe_ehp <= smite_damage) & can_smite()

func smite()
  stance = "smite R"
  aac("blade")
  ?item.CanActivate("blade")
    activate R
  return true

func can_hammer()
  return can_use("hammer") & !phys_immune & 
  ^eff_dist <= 21 & can_activate()

func should_hammer()
  ?!can_hammer()
    return false
  var should_stun = debuff_on_smite & 
  ^get(my_statuses, "smite") & 
  ^(foe ! immune_to_stun)

  return (is_boss | can_aoe & eff_dist < 10) &
  ^(foe = spawner | foe.armor > 0 | should_stun)

var hammer_frames = 15
func hammer()
  set_lock("hammer", hammer_frames)
  stance = "heavy hammer R"
  aac("heavy hammer")
  ?item.CanActivate("hammer")
    activate R
  return true

func can_bard()
  return can_use("bardiche") & eff_dist <= 9 & 
  ^!phys_immune & can_activate()

func should_bard()
  return is_boss & can_bard()

var bard_frames = 30
func bardiche()
  set_lock("bardiche", bard_frames)
  stance = "bardiche R"
  aac("bardiche")
  ?item.CanActivate("bardiche")
    activate R
  return true

func can_mask()
  return can_use("mask") &
  ^(foe ! nagaraja) & can_activate()

func should_mask()
  return (mask_quest = "simple" | 
  ^is_boss & eff_dist<=melee_range) & can_mask()

func mask()
  stance = "mask R"
  equip_R("mask")
  ?item.CanActivate("mask")
    activate R
  return true

func use_abilities()
  ?get(my_statuses, "aspd_down") > 0
    return false // timings will be screwed
  // prioritize quests
  ?mask_quest = "simple" & can_mask()
    return mask()
  ?pickpocket_quest & can_slap()
    return slap()
  // then use where needed
  ?should_hammer()
    return hammer()
  ?should_smite()
    return smite()
  ?should_bard()
    return bardiche()
  ?should_slap()
    return slap()
  // use mask right before debuffing
  ?should_mask()
    return mask()
  return false

func can_activate()
  return ai.enabled & item.CanActivate()

func aac(weapon)
  _equip_L = weapon
  equip @weapon@
  ?ai.idle & 
  ^!(weapon = "repeating" | weapon = "crossbow"
  ^| weapon = "staff")
    ?lock & (is_locked_by("hammer") | 
    ^is_locked_by("bardiche"))
      return false
    equip wand
  equip @weapon@
  return weapon

/*****************
**    #Bosses   **
*****************/
  
func try_evade()
  ?can_mind
    return backflip()
  return shield_block_big_hit()

func evade_at(t)
  ?foe_t = t
    return try_evade()
  ?foe_t < t & get_cd("mind") <= (t - foe_t)
    // abilities that would be interrupted
    ?foe_t > (t - bard_frames)
      disable_r("bardiche")
    ?foe_t > (t - hammer_frames)
      disable_r("hammer")
  return false

func shield_block()
  ?lock // don't interrupt abilities
    return false
  stance = "shield block"
  return auto_equip_L("melee", false) & 
  ^equip_R(evade_shield)

func shield_block_big_hit()
  stance = "shield block big hit"
  return equip_L("quest")& equip_R(evade_shield)

func fight_scout()
  ?mask_quest & string.Equals(mask_quest, 
  ^"prevent")
    equip_L("quest")
    ?foe_s = 32 & foe_t > 11 & can_mask()
      return mask()
    ?get_cd("mask") > 0 & 
    ^!get(foe_debuffs, "debuff_feeble")
      return loc.Leave()
    ?have_dashing
      equip_R("dashing")
  :
    auto_melee_miniboss()  

func fight_dysan() // REDO
  disable_r("skeleton_arm")
  ?foe = phase1
    ?foe_s = 33 & foe_t = 24
      // block big attack
      return shield_block()
  :?foe = phase2
    auto_equip_dps("melee", false)
  :?foe = phase3
    ?foe_s = 32 & foe_t > 90
      // prepare for attack
      return shield_block()
    :?foe_s = 115
      ?foe_t = 60
        // dodge the orb ray
        return backflip()
      :?foe_t < 80
        // don't dash into ray
        disable_r("any_dash")
    :?foe_s = 106 | foe_s = 108 |
    ^foe_s = 0
      return shield_block()
  auto_melee_boss()

func fight_xyloalgia()
  ?foe = phase1 // Xyloalgia
    // TODO: root
    return auto_melee_boss()
  // Poena
  // TODO: permastun
  disable_r("skeleton_arm")
  ?foe.buffs.string = "poena_mirror"
    return shield_block_big_hit() // :(
  :?foe_s = 32 & foe_t = 41
    return shield_block()
  auto_melee_boss()

func fight_bolesh()
  // Get close, debuff/use abilities, then
  // jump to ranged before the first melee bite,
  // and continue shooting and blocking.
  // TODO: potion
  ?loc.stars > 5
    disable_r("skeleton_arm")
  ?foe_s = 133 & ((foe_t > 9 & foe_t < 12) | 
  ^(foe_t > 14 & foe_t < 17))
    // block bite and don't move from ranged
    return shield_block_big_hit()
  :?foe_s = 142 & evade_at(60)
    // evade melee bite
    return
  :?can_mind & 
  ^!(foe.buffs.string = "spider_buff_damage")
    return auto_melee_boss()
  :?bfg_quest & bfg_quest = "bolesh" & 
  ^(foe_ehp < smite_damage * 1.5)
    ?eff_dist <= 11
      return equip_L("blade")
    return melee("def")
  :
    ranged("single")

func fight_mushrooms()
  disable_r("skeleton_arm")
  ?base_big_swing = 0
    ?shroom_phase = 1
      base_big_swing = 46
    :
      base_big_swing = 26
  // thanks to user `fruloo` from the discord!
  var delay = 7*get(foe_debuffs, "debuff_chill")
  ?foe = phase1
    ?foe_s = 32 & 
    ^evade_at(base_big_swing + delay)
      return
    :?foe_s = 33 & foe_t = foe_dist + 4
      return shield_block()
  :?foe = mushroom_boss_fat
    shroom_phase = 2
    ?get(foe_debuffs, "stun")
      base_big_swing = base_big_swing + 1
    ?foe_s = 32 & 
    ^evade_at(base_big_swing + delay)
      return
  auto_melee_boss()

func fight_pallas()
  disable_r("skeleton_arm")
  ?foe = phase1
    ?foe_s = 32 & foe_t = 68
      return shield_block()
    return auto_melee_boss()
  :?foe = phase2 & foe.count > 2
    return ranged("aoe") // deal with ghosts
  auto_melee_boss()

func fight_bronze_guardian()
  disable_r("skeleton_arm")
  ?foe_s = 32 & foe_t = 33 & armor < foe.damage
    return backflip() // dodge the hammer
  :?foe_s = 33 // hammer is down
    return auto_melee_boss()
  ranged("single")

func fight_hrimnir()
  at_boss = true
  ?is_snowball_near()
    return shield_block()
  var melee_ball = 23 + 
  ^7*get(foe_debuffs, "debuff_chill")
  ?foe_dist <= 6 & 
  ^foe_s = 32 & foe_t >= melee_ball
    return shield_block()
  :?draw.GetSymbol(56, 13) = "o"
    return ranged("single")
  :?is_boss & foe.count = 1
    ?foe.armor > 0 // don't waste abilities
      return melee("dps")
    return auto_melee_boss()
  :?foe.count > 2
    ?can_hammer() & 
    ^get(my_statuses, "speed_down") = 0 &
    ^screen.FromWorldX(pos.x) < 40
      return hammer()
    return melee("aoe")
  return auto_melee()

var dists = [3, 4]
func is_snowball_near()
  var x = screen.FromWorldX(pos.x)
  var y = screen.FromWorldZ(pos.z)
  for dist : dists
    ?draw.GetSymbol(x+dist, y-3) = "(" &
    ^draw.GetSymbol(x+dist+1, y-3) = "_" & 
    ^draw.GetSymbol(x+dist+2, y-3) = ")"
      return true
  return false

var naga_step = 0
func fight_nagaraja()
  // dodge poison balls & plink away
  disable_r("skeleton_arm")
  ?foe_s = 112 & foe_t = 59 & foe_dist < 10
    ?can_mind // boulder
      naga_step = 0
      return backflip() // dodge back and repeat
    return shield_block() // try to block
  var x = screen.FromWorldX(pos.x)
  var y = screen.FromWorldZ(pos.z)
  var near = false
  ?is_poison_near(x, y)
    near = true
    naga_step++
  ?naga_step = 0
    ?!use_abilities()
      ranged("single") //start at the xbow range
  :?naga_step = 1
    qs_dash() // quarterstaff the 1st poison
    naga_step++
  :?naga_step = 2
    ?!use_abilities()
      ranged("single") // and continue to shoot
  :?naga_step = 3
    auto_melee_boss() // dash into melee
  :?naga_step >= 4
    ?can_mind
      backflip() // dodge back and repeat
      naga_step = 0
    :?near
      shield_block() // try to block
    :
      auto_melee_boss()

func is_poison_near(pos_x, pos_y)
  // long and mid range
  ?draw.GetSymbol(pos_x+2, pos_y-6) = "(" |
  // melee
  ^(draw.GetSymbol(pos_x+1, pos_y-6) = "(")
    return true
  return false

/*********************
**     #Internals   **
*********************/
var at_boss = false // to disable default fight
var base_big_swing = 0 // mushrooms
var shroom_phase = 1
// player status
var stance = "unknown" // chosen combat stance
var low_hp = false // hp < (maxhp * threshold)
var can_aoe = false
var found = false
var found_type = false
var _elem = "default"
// abilities
var lock = false
var lock_timer = false
var free_mind = false
// foe status
var foe_s = 0 // foe.state
var foe_t = 0 // foe.time
var foe_ehp = 0 // foe.armor + foe.hp
var foe_dist = 0 // foe_dist
var eff_dist = 0 // foe_dist + range_debuff
var is_boss = false // foe = boss
var phys_immune = false // immune to physical

var elem_types = [
  "sword", "big sword", "wand", "shield", 
  "crossbow", "staff", "hammer",
]
var _2h_types = ["bardiche", "arm", "blade", 
"heavy hammer", "repeating", "staff",
"quarterstaff", "shovel"]
var all_elems = [
  "aether", "fire", "ice", "poison", "vigor",
]
var aa_st_types = []
var aa_aoe_types = []
var all_items = [/*
hash, [weapon1, weapon2,], hash, [weapon3], ...
for example:
sword-aether-stats, [aether sword D],
hammer-fire-mod, [fire hammer dF],
wand-default, [stone wand + 10],
*/]
func _prepare_items()
   // [type, [elem, s1, sn], [elem2...]]
  for item_type : elemental_items
    ?item_type.Count() > 1
      var ty = item_type[0]
      // for each element
      for i = 1 .. item_type.Count() - 1
        var suffixes = item_type[i]
        ?suffixes.Count() > 1
          // suffixes: ["elem", "s1", "sn"]
          _categorize_item(ty, suffixes)
  for a : [
  ^[for_melee_single_target, aa_st_types],
  ^[for_melee_aoe, aa_aoe_types]]
    var source = a[0]
    var dest = a[1]
    ?source.Contains("heavy hammer")
      dest.Add("heavy hammer")
    ?source.Contains("hammer")
      dest.Add("hammer")
    for w : source
      ?w ! "hammer"
        dest.Add(w)

func _categorize_item(ty, suffixes)
  var elem = suffixes[0]
  for j = 1 .. suffixes.Count() - 1
    var suffix = suffixes[j]
    ?elem = "default"
      add_item(hash([ty, "default"]), suffix)
    :
      var full_name = string.Join(" ", 
      ^[elem, ty, suffix])
      var purpose = get_purpose(suffix)
      var h = hash([ty, elem, purpose])
      add_item(h, full_name)

func hash(parts)
  return string.Join("-", parts)

var elem_mods = ["f", "F", "i", "I", 
"p", "P", "h", "L",]
func get_purpose(suffix)
  ?string.Size(suffix) > 1 &
  ^elem_mods.Contains(string.Sub(suffix, 1, 1))
    return "mod"
  return "stats"

func add_item(hash, _name)
  var idx = all_items.IndexOf(hash)
  var arr
  ?idx = -1
    arr = [_name]
    all_items.Add(hash)
    all_items.Add(arr)
  :
    arr = all_items[idx + 1]
    ?!arr.Contains(_name)
      arr.Add(_name)

var all_statuses = [
  ["berserk", "Berserk", "+"], 
  ["smite", "Smite", "+"], 
  ["pick_pocket", "Pickpocket", "+"],
  ["vampiric", "Vamp", "+"],
  ["lucky_crit_multi", "Lucky", "+"],
  ["invisibility", "Invis", "+"],
  ["debuff_damage", "DmgDown", "-"],
  ["debuff_duration_damage", "DmgDown", "-"],
  ["spider_debuff_damage", "DmgDown", "-"],
  ["dysangelos_debuff_damage", "DmgDown", "-"],
  ["puff_debuff_damage", "DmgDown", "-"],
  ["debuff_yeti_chill", "AtkSlow", "-"],
  ["debuff_attack_speed", "AtkSlow", "-"],
  ["debuff_move_speed", "MoveSlow", "-"],
  ["debuff_chill", "Chill", "-"],
  ["stun", "Stun", "-"],
  ["pallas_phase2_debuff", "RangeDown", "-"],
  ["debuff_dot", "FireDoT", "-"],
]
var status_uids = []
func _prepare_statuses()
  for info : all_statuses
    status_uids.Add(info[0])

var my_buffs = []
var my_debuffs = []
var my_weird = []
var my_statuses = ["slow", false, "berserk", 
false, "smite", false, "stun", false, 
"range_down",0,"damage_down",0,"aspd_down",0,
"pick_pocket",0, 
]
func _update_statuses()
  my_buffs.Clear()
  my_debuffs.Clear()
  for i = 1 .. my_statuses.Count() - 1
    ?i < 9
      my_statuses[i] = false
    :
      my_statuses[i] = 0
    i++
  for s : [buffs.string, debuffs.string]
    // format: *:name:count:duration,...
    var splt = string.Split(s, ":", ",", false)
    var arr_size = splt.Count()
    ?arr_size > 0
      // iterate over names (2nd field)
      for i = 1 .. arr_size - 3
        _parse_status(splt, i)
        i = i + 3

var ignore_statuses = [
  "quarterstaff_buff_attack_speed",
  "quarterstaff_buff_stun",
  "bardiche_buff_aoe_chance",
  "bardiche_buff_crit_chance",
  "bardiche_buff_crit_mult",
  "bardiche_buff_move_speed",
]
var dmg_debuffs = [
  "debuff_damage", "debuff_duration_damage",
  "spider_debuff_damage", "puff_debuff_damage"
]
var slow_debuffs = [
  "debuff_chill", "debuff_move_speed"
]
var aspd_debuffs = [
  "debuff_chill", "debuff_attack_speed",
  "debuff_yeti_chill",
]
var range_debuffs = [
  "pallas_phase2_debuff"
]
var buff_template = "{0}({1}) {2}"
func _parse_status(splt, i)
  var uid = splt[i]
  var idx = status_uids.IndexOf(uid)
  ?idx = -1
    ?!ignore_statuses.Contains(uid) &
    ^!my_weird.Contains(uid)
      my_weird.Add(uid)
    return
  var info = all_statuses[idx] // uid, name, +/-
  var num = int.Parse(splt[i+1])
  var dur = int.Parse(splt[i+2])
  var _name = string.Format(buff_template, 
  ^info[1], num, time.FormatDigital(dur))
  ?info[2] = "+"
    my_buffs.Add(_name)
  :
    my_debuffs.Add(_name)
  var n
  ?dmg_debuffs.Contains(uid)
    n = get(my_statuses, "damage_down")
    set(my_statuses, "damage_down", n + num)
  :?aspd_debuffs.Contains(uid)
    n = get(my_statuses, "aspd_down")
    set(my_statuses, "aspd_down", n + num)
  :?range_debuffs.Contains(uid)
    n = get(my_statuses, "range_down")
    set(my_statuses, "range_down", n + num)
  :?string.Equals(uid, "pick_pocket")
    set(my_statuses, "pick_pocket", num)
  :?my_statuses.Contains(uid)
    set(my_statuses, uid, true)
  ?slow_debuffs.Contains(uid)
    set(my_statuses, "slow", true)

var foe_debuffs = ["debuff_damage", false,
"debuff_dot", false, "debuff_feeble", false, 
"buff_protection", false, "stun", false, 
"debuff_chill", 0]
func _update_foe_debuffs()
  foe_debuffs[foe_debuffs.Count() - 1] = 0
  for i = 1 .. foe_debuffs.Count() - 3
    foe_debuffs[i] = false
    i++
  var splt = string.Split(foe.debuffs.string,
  ^":", ",", false)
  var arr_size = splt.Count()
  ?arr_size = 0
    return
  for i = 1 .. arr_size - 3
    var uid = splt[i]
    var idx = foe_debuffs.IndexOf(uid)
    ?idx ! -1
      idx++
      ?string.Equals(uid, "debuff_chill")
        foe_debuffs[idx] = int.Parse(splt[i+1])
      :?string.Equals(uid, "stun")
        foe_debuffs[idx] = int.Parse(splt[i+2])
      :
        foe_debuffs[idx] = true
    i = i + 3

func get_foe_weak_elem()
  ?foe = aether
    return "vigor"
  ?foe = fire
    return "aether"
  ?foe = ice
    return "fire"
  ?foe = poison
    return "ice"
  ?foe = vigor
    return "poison"
  return "default"

var all_abilities = [
  "mind", "hammer", "bardiche", "blade",
  "skeleton_arm", "mask", "quarterstaff", 
  "dash", "bash",
]
var cooldowns = ["mind", 0]
var abilities = ["mind", false]
func _prepare_abilities()
  for r : useable_abilities
    ?!all_abilities.Contains(r)
      panic("Unknown ability: " + r)
    ?!abilities.Contains(r)
      set(cooldowns, r, 0)
      set(abilities, r, false)

var can_mind = false
func _update_abilities()
  for i = 0 .. abilities.Count() - 2
    var r = abilities[i]
    var cd = item.GetCooldown(r)
    set(cooldowns, r, cd)
    set(abilities, r, cd <= 0)
    ?string.Equals(r, "mind")
      can_mind = cd <= 0
    i++

var move_r = ["quarterstaff", "bash", "dash"]
func disable_r(ability)
  ?ability = "any_dash"
    for r : move_r
      set(abilities, r, false)
  :
    set(abilities, ability, false)

func get(dict, k)
  var idx = dict.IndexOf(k)
  ?idx = -1
    panic("Bad dict key: k=" + k)
  return dict[idx + 1]

var None = "~NONE~" // to distinguish from false
func try_get(dict, k)
  var idx = dict.IndexOf(k)
  ?idx = -1
    return None
  return dict[idx + 1]

func set(dict, k, v)
  var idx = dict.IndexOf(k)
  ?idx = -1
    dict.Add(k)
    dict.Add(v)
  :
    dict[idx + 1] = v

var weapon_ranges = ["sword", 5, "hammer", 5,
"quarterstaff", 5, "big sword", 6, "arm", 6, 
"heavy hammer", 7, "bardiche", 9, "staff", 10,
"blade", 11, "wand", 20, "heavy crossbow", 22,
"repeating", 22, "crossbow", 22]
var melee_range = 5
var melee_aoe_range = 5
var ranged_range = 20
func _prepare_ranges()
  var a = for_melee_single_target
  ?a.Count() > 0
    melee_range = get(weapon_ranges, a[0])
  a = for_melee_aoe
  ?a.Count() > 0
    melee_aoe_range = get(weapon_ranges, a[0])
  a = for_ranged_aoe
  ?a.Count() > 0
    ranged_range = get(weapon_ranges, a[0])

func _update_lock()
  clear_lock("stun")
  ?get(my_statuses, "stun")
    set_lock("stun", 0)
  ?lock
    ?lock_timer <= 0
      lock = false
    :
      lock_timer--
  :
    lock_timer = 0

func _update_game_state()
  _equip_L = false
  _equip_R = false
  found = false
  found_type = false
  _elem = get_foe_weak_elem()
  stance = "unknown"
  low_hp = hp < (maxhp * low_hp_threshold)
  foe_s = foe.state
  foe_t = foe.time
  foe_ehp = foe.armor + foe.hp
  foe_dist = foe.distance  
  eff_dist = foe_dist + get(my_statuses, 
  ^"range_down")
  is_boss = (foe = boss)
  phys_immune = (foe = immune_to_physical)
  can_aoe = (foe.count >= aoe_treshold)

func prelude()
  // reset/update dynamic global vars
  ?enable_hit_tracking
    track_hits()
  _update_statuses()
  _update_foe_debuffs()
  _update_abilities()
  _update_lock()
  _update_game_state()

var errors = []
func dbg(e)
  ?ui_show_debug
    ?!errors.Contains(e)
      errors.Add(e)

func panic(e)
  >`20,5,#red,@e@
  loc.Pause()

var enable_hit_tracking = false
var last_frame_dist = 0
var last_frame_armor = 0
var last_frame_hp = 0
var last_frame_foe = ""
var last_frame_dist = 0
var last_frame_state = -1
var last_frame_time = -1
var last_frame_stance = ""
var debuff_hash = "sl={0},st={1},d={2},r={3},
^aspd={4}"
var last_frame_debuffs = string.Format(
^debuff_hash, false, false, 0, 0, 0)
func track_hits()
  var hp_diff = last_frame_hp - hp
  var _debuffs = string.Format(debuff_hash,
  ^get(my_statuses, "slow"), 
  ^get(my_statuses, "stun"), 
  ^get(my_statuses, "damage_down"),
  ^get(my_statuses, "range_down"),
  ^get(my_statuses, "aspd_down"))
  ?hp_diff > 0 | 
  ^(last_frame_debuffs ! _debuffs)
    var y = 2
    >`20,@y@,#red,Got hit!
    >`20,@y+1@,Last frame info:
    >`20,@y+2@,hp = @last_frame_hp@ (diff = 
    ^@hp_diff@)
    >`20,@y+3@,armor = @last_frame_armor@
    >`20,@y+4@,id = @last_frame_foe@
    >`20,@y+5@,dist = @last_frame_dist@
    >`20,@y+6@,state = @last_frame_state@
    >`20,@y+7@,time = @last_frame_time@
    >`20,@y+8@,stance = @last_frame_stance@
    loc.Pause()
  last_frame_armor = armor
  last_frame_hp = hp
  last_frame_foe = foe.id
  last_frame_dist = foe_dist
  last_frame_state = foe_s
  last_frame_time = foe_t
  last_frame_stance = stance
  last_frame_debuffs = _debuffs

var gray = "#7A8F93"
func draw_ui()
  var x = 1
  var y = 22
  ?ui_show_debug
    y = 20
  ?ui_show_statuses
    >`@x@,@y@,#00A300,
    ^+ @string.Join(", ", my_buffs)@
    >`@x@,@y+1@,#FE6800,
    ^- @string.Join(", ", my_debuffs)@
    >`@x@,@y+2@,#F008B2,
    ^? @string.Join(", ", my_weird)@
  ?ui_show_cd
    y = 6
    for r : all_abilities
      ?!move_r.Contains(r) & 
      ^abilities.Contains(r)
        var cd = get_cd(r)
        ?r = "skeleton_arm"
          r = "Arm"
        >`@x@,@y@,#@colorize(cd)@,
        ^@string.Capitalize(r)@ 
        ^@time.FormatDigital(cd)@
        y++
    >`@x@,@y@,
    ^#@colorize(get_cd("quarterstaff"))@,QS
    x = x + 2
    ?abilities.Contains("bash")
      >`@x@,@y@,@gray@,/
      x++
      >`@x@,@y@,
      ^#@colorize(get_cd("bash"))@,B
      x++
    ?abilities.Contains("dash")
      >`@x@,@y@,@gray@,/
      x++
      >`@x@,@y@,
      ^#@colorize(get_cd("dash"))@,D
      x++
  ?ui_show_debug
    x = 1
    y = 14
    ?foe
      >`@x@,@y@,@gray@,id: @foe.id@
      >`@x@,@y+1@,@gray@,State: @foe_s@
      >`@x@,@y+2@,@gray@,Time: @foe_t@
      >`@x@,@y+3@,@gray@,Dist: @foe_dist@
      >`@x@,@y+4@,@gray@,Count: @foe.count@
    y = 23
    >`@x@,@y@,#blue,Lock: @lock@ (@lock_timer@)
    >`@x@,@y+1@,#blue,Stance: @stance@
    >`@x@,@y+2@,@gray@,@loc.stars@* 
    ^@time.FormatDigital(totaltime)@ @foe@
    var _weapon = " (L)"
    x = screen.w - 10
    y = 23
    ?_equip_L
      x = x - string.Size(_equip_L)
      _weapon = _equip_L + _weapon
    >`@x@,@y@,#blue,@_weapon@
    _weapon = " (R)"
    x = screen.w - 10
    ?_equip_R
      x = x - string.Size(_equip_R)
      _weapon = _equip_R + _weapon
    >`@x@,@y+1@,#blue,@_weapon@
    
    var ey = 2
    for err : errors
      >`20,@ey@,#red,@err@
      ey++

func colorize(cd)
  ?cd > 0
    return "red"
  return "green"

func brew_pot()
  brew tar + bronze // vampiric

func reset_loop()
  lock = false
  lock_timer = 0
  my_weird.Clear()
  enable_hit_tracking = false
  // bosses
  at_boss = false
  naga_step = 0
  base_big_swing = 0
  shroom_phase = 1

?loc.begin
  _prepare_statuses()
  _prepare_items()
  _prepare_ranges()
  _prepare_abilities()
  ?item.potion = empty
    brew_pot()
  // ?loc = halls
  //   prefer_ranged = true
  //   for_ranged_single_target = ["wand"]
  // ?loc = caves
  //   prefer_ranged = true
:?loc.loop
  reset_loop()
:?ai.enabled & !ai.paused
  prelude()
  progress()
:
  healwalk()
draw_ui()